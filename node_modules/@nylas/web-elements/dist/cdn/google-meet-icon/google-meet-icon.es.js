const L = {
  allRenderFn: !1,
  cmpDidLoad: !0,
  cmpDidUnload: !1,
  cmpDidUpdate: !0,
  cmpDidRender: !0,
  cmpWillLoad: !0,
  cmpWillUpdate: !0,
  cmpWillRender: !0,
  connectedCallback: !0,
  disconnectedCallback: !0,
  element: !0,
  event: !0,
  hasRenderFn: !0,
  lifecycle: !0,
  hostListener: !0,
  hostListenerTargetWindow: !0,
  hostListenerTargetDocument: !0,
  hostListenerTargetBody: !0,
  hostListenerTargetParent: !1,
  hostListenerTarget: !0,
  member: !0,
  method: !0,
  mode: !0,
  observeAttribute: !0,
  prop: !0,
  propMutable: !0,
  reflect: !0,
  scoped: !0,
  shadowDom: !0,
  slot: !0,
  cssAnnotations: !0,
  state: !0,
  style: !0,
  formAssociated: !1,
  svg: !0,
  updatable: !0,
  vdomAttribute: !0,
  vdomXlink: !0,
  vdomClass: !0,
  vdomFunctional: !0,
  vdomKey: !0,
  vdomListener: !0,
  vdomRef: !0,
  vdomPropOrAttr: !0,
  vdomRender: !0,
  vdomStyle: !0,
  vdomText: !0,
  watchCallback: !0,
  taskQueue: !0,
  hotModuleReplacement: !1,
  isDebug: !1,
  isDev: !1,
  isTesting: !1,
  hydrateServerSide: !1,
  hydrateClientSide: !1,
  lifecycleDOMEvents: !1,
  lazyLoad: !1,
  profile: !1,
  slotRelocation: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: !1,
  hydratedAttribute: !1,
  hydratedClass: !0,
  scriptDataOpts: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: !1,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: !1,
  invisiblePrehydration: !0,
  propBoolean: !0,
  propNumber: !0,
  propString: !0,
  constructableCSS: !0,
  cmpShouldUpdate: !0,
  devTools: !1,
  shadowDelegatesFocus: !0,
  initializeNextTick: !1,
  asyncLoading: !1,
  asyncQueue: !1,
  transformTagName: !1,
  attachStyles: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: !1
};
let E, j, R, oe = !1, H = !1, W = !1, S = !1, Z = null, B = !1;
const x = (e, t = "") => () => {
}, be = "slot-fb{display:contents}slot-fb[hidden]{display:none}", G = "http://www.w3.org/1999/xlink", I = {}, ke = "http://www.w3.org/2000/svg", me = "http://www.w3.org/1999/xhtml", Le = (e) => e != null, z = (e) => (e = typeof e, e === "object" || e === "function");
function Te(e) {
  var t, n, s;
  return (s = (n = (t = e.head) === null || t === void 0 ? void 0 : t.querySelector('meta[name="csp-nonce"]')) === null || n === void 0 ? void 0 : n.getAttribute("content")) !== null && s !== void 0 ? s : void 0;
}
const v = (e, t, ...n) => {
  let s = null, l = null, c = null, o = !1, r = !1;
  const i = [], u = (a) => {
    for (let d = 0; d < a.length; d++)
      s = a[d], Array.isArray(s) ? u(s) : s != null && typeof s != "boolean" && ((o = typeof e != "function" && !z(s)) && (s = String(s)), o && r ? i[i.length - 1].$text$ += s : i.push(o ? w(null, s) : s), r = o);
  };
  if (u(n), t) {
    t.key && (l = t.key), t.name && (c = t.name);
    {
      const a = t.className || t.class;
      a && (t.class = typeof a != "object" ? a : Object.keys(a).filter((d) => a[d]).join(" "));
    }
  }
  if (typeof e == "function")
    return e(t === null ? {} : t, i, _e);
  const f = w(e, null);
  return f.$attrs$ = t, i.length > 0 && (f.$children$ = i), f.$key$ = l, f.$name$ = c, f;
}, w = (e, t) => {
  const n = {
    $flags$: 0,
    $tag$: e,
    $text$: t,
    $elm$: null,
    $children$: null
  };
  return n.$attrs$ = null, n.$key$ = null, n.$name$ = null, n;
}, xe = {}, Ee = (e) => e && e.$tag$ === xe, _e = {
  forEach: (e, t) => e.map(Q).forEach(t),
  map: (e, t) => e.map(Q).map(t).map(Ae)
}, Q = (e) => ({
  vattrs: e.$attrs$,
  vchildren: e.$children$,
  vkey: e.$key$,
  vname: e.$name$,
  vtag: e.$tag$,
  vtext: e.$text$
}), Ae = (e) => {
  if (typeof e.vtag == "function") {
    const n = Object.assign({}, e.vattrs);
    return e.vkey && (n.key = e.vkey), e.vname && (n.name = e.vname), v(e.vtag, n, ...e.vchildren || []);
  }
  const t = w(e.vtag, e.vtext);
  return t.$attrs$ = e.vattrs, t.$children$ = e.vchildren, t.$key$ = e.vkey, t.$name$ = e.vname, t;
}, Re = (e) => st.map((t) => t(e)).find((t) => !!t), Ce = (e, t) => e != null && !z(e) ? t & 4 ? e === "false" ? !1 : e === "" || !!e : t & 2 ? parseFloat(e) : t & 1 ? String(e) : e : e, X = /* @__PURE__ */ new WeakMap(), Me = (e, t, n) => {
  let s = U.get(e);
  it && n ? (s = s || new CSSStyleSheet(), typeof s == "string" ? s = t : s.replaceSync(t)) : s = t, U.set(e, s);
}, Oe = (e, t, n) => {
  var s;
  const l = ie(t, n), c = U.get(l);
  if (e = e.nodeType === 11 ? e : b, c)
    if (typeof c == "string") {
      e = e.head || e;
      let o = X.get(e), r;
      if (o || X.set(e, o = /* @__PURE__ */ new Set()), !o.has(l)) {
        {
          r = b.createElement("style"), r.innerHTML = c;
          const i = (s = p.$nonce$) !== null && s !== void 0 ? s : Te(b);
          i != null && r.setAttribute("nonce", i), e.insertBefore(r, e.querySelector("link"));
        }
        t.$flags$ & 4 && (r.innerHTML += be), o && o.add(l);
      }
    } else e.adoptedStyleSheets.includes(c) || (e.adoptedStyleSheets = [...e.adoptedStyleSheets, c]);
  return l;
}, Fe = (e) => {
  const t = e.$cmpMeta$, n = e.$hostElement$, s = t.$flags$, l = x("attachStyles", t.$tagName$), c = Oe(n.shadowRoot ? n.shadowRoot : n.getRootNode(), t, e.$modeName$);
  s & 10 && (n["s-sc"] = c, n.classList.add(c + "-h"), s & 2 && n.classList.add(c + "-s")), l();
}, ie = (e, t) => "sc-" + (t && e.$flags$ & 32 ? e.$tagName$ + "-" + t : e.$tagName$), K = (e, t, n, s, l, c) => {
  if (n !== s) {
    let o = te(e, t), r = t.toLowerCase();
    if (t === "class") {
      const i = e.classList, u = J(n), f = J(s);
      i.remove(...u.filter((a) => a && !f.includes(a))), i.add(...f.filter((a) => a && !u.includes(a)));
    } else if (t === "style") {
      for (const i in n)
        (!s || s[i] == null) && (i.includes("-") ? e.style.removeProperty(i) : e.style[i] = "");
      for (const i in s)
        (!n || s[i] !== n[i]) && (i.includes("-") ? e.style.setProperty(i, s[i]) : e.style[i] = s[i]);
    } else if (t !== "key")
      if (t === "ref")
        s && s(e);
      else if (!e.__lookupSetter__(t) && t[0] === "o" && t[1] === "n") {
        if (t[2] === "-" ? t = t.slice(3) : te(D, r) ? t = r.slice(2) : t = r[2] + t.slice(3), n || s) {
          const i = t.endsWith(ce);
          t = t.replace(we, ""), n && p.rel(e, t, n, i), s && p.ael(e, t, s, i);
        }
      } else {
        const i = z(s);
        if ((o || i && s !== null) && !l)
          try {
            if (e.tagName.includes("-"))
              e[t] = s;
            else {
              const f = s ?? "";
              t === "list" ? o = !1 : (n == null || e[t] != f) && (e[t] = f);
            }
          } catch {
          }
        let u = !1;
        r !== (r = r.replace(/^xlink\:?/, "")) && (t = r, u = !0), s == null || s === !1 ? (s !== !1 || e.getAttribute(t) === "") && (u ? e.removeAttributeNS(G, t) : e.removeAttribute(t)) : (!o || c & 4 || l) && !i && (s = s === !0 ? "" : s, u ? e.setAttributeNS(G, t, s) : e.setAttribute(t, s));
      }
  }
}, He = /\s/, J = (e) => e ? e.split(He) : [], ce = "Capture", we = new RegExp(ce + "$"), re = (e, t, n, s) => {
  const l = t.$elm$.nodeType === 11 && t.$elm$.host ? t.$elm$.host : t.$elm$, c = e && e.$attrs$ || I, o = t.$attrs$ || I;
  for (s in c)
    s in o || K(l, s, c[s], void 0, n, t.$flags$);
  for (s in o)
    K(l, s, c[s], o[s], n, t.$flags$);
}, P = (e, t, n, s) => {
  const l = t.$children$[n];
  let c = 0, o, r, i;
  if (oe || (W = !0, l.$tag$ === "slot" && (E && s.classList.add(E + "-s"), l.$flags$ |= l.$children$ ? (
    // slot element has fallback content
    2
  ) : (
    // slot element does not have fallback content
    1
  ))), l.$text$ !== null)
    o = l.$elm$ = b.createTextNode(l.$text$);
  else if (l.$flags$ & 1)
    o = l.$elm$ = b.createTextNode("");
  else {
    if (S || (S = l.$tag$ === "svg"), o = l.$elm$ = b.createElementNS(S ? ke : me, l.$flags$ & 2 ? "slot-fb" : l.$tag$), S && l.$tag$ === "foreignObject" && (S = !1), re(null, l, S), Le(E) && o["s-si"] !== E && o.classList.add(o["s-si"] = E), l.$children$)
      for (c = 0; c < l.$children$.length; ++c)
        r = P(e, l, c, o), r && o.appendChild(r);
    l.$tag$ === "svg" ? S = !1 : o.tagName === "foreignObject" && (S = !0);
  }
  return o["s-hn"] = R, l.$flags$ & 3 && (o["s-sr"] = !0, o["s-cr"] = j, o["s-sn"] = l.$name$ || "", i = e && e.$children$ && e.$children$[n], i && i.$tag$ === l.$tag$ && e.$elm$ && C(e.$elm$, !1)), o;
}, C = (e, t) => {
  p.$flags$ |= 1;
  const n = e.childNodes;
  for (let s = n.length - 1; s >= 0; s--) {
    const l = n[s];
    l["s-hn"] !== R && l["s-ol"] && (fe(l).insertBefore(l, q(l)), l["s-ol"].remove(), l["s-ol"] = void 0, l["s-sh"] = void 0, W = !0), t && C(l, t);
  }
  p.$flags$ &= -2;
}, ae = (e, t, n, s, l, c) => {
  let o = e["s-cr"] && e["s-cr"].parentNode || e, r;
  for (o.shadowRoot && o.tagName === R && (o = o.shadowRoot); l <= c; ++l)
    s[l] && (r = P(null, n, l, e), r && (s[l].$elm$ = r, o.insertBefore(r, q(t))));
}, $e = (e, t, n) => {
  for (let s = t; s <= n; ++s) {
    const l = e[s];
    if (l) {
      const c = l.$elm$;
      he(l), c && (H = !0, c["s-ol"] ? c["s-ol"].remove() : C(c, !0), c.remove());
    }
  }
}, Pe = (e, t, n, s, l = !1) => {
  let c = 0, o = 0, r = 0, i = 0, u = t.length - 1, f = t[0], a = t[u], d = s.length - 1, $ = s[0], h = s[d], y, g;
  for (; c <= u && o <= d; )
    if (f == null)
      f = t[++c];
    else if (a == null)
      a = t[--u];
    else if ($ == null)
      $ = s[++o];
    else if (h == null)
      h = s[--d];
    else if (F(f, $, l))
      _(f, $, l), f = t[++c], $ = s[++o];
    else if (F(a, h, l))
      _(a, h, l), a = t[--u], h = s[--d];
    else if (F(f, h, l))
      (f.$tag$ === "slot" || h.$tag$ === "slot") && C(f.$elm$.parentNode, !1), _(f, h, l), e.insertBefore(f.$elm$, a.$elm$.nextSibling), f = t[++c], h = s[--d];
    else if (F(a, $, l))
      (f.$tag$ === "slot" || h.$tag$ === "slot") && C(a.$elm$.parentNode, !1), _(a, $, l), e.insertBefore(a.$elm$, f.$elm$), a = t[--u], $ = s[++o];
    else {
      for (r = -1, i = c; i <= u; ++i)
        if (t[i] && t[i].$key$ !== null && t[i].$key$ === $.$key$) {
          r = i;
          break;
        }
      r >= 0 ? (g = t[r], g.$tag$ !== $.$tag$ ? y = P(t && t[o], n, r, e) : (_(g, $, l), t[r] = void 0, y = g.$elm$), $ = s[++o]) : (y = P(t && t[o], n, o, e), $ = s[++o]), y && fe(f.$elm$).insertBefore(y, q(f.$elm$));
    }
  c > u ? ae(e, s[d + 1] == null ? null : s[d + 1].$elm$, n, s, o, d) : o > d && $e(t, c, u);
}, F = (e, t, n = !1) => e.$tag$ === t.$tag$ ? e.$tag$ === "slot" ? e.$name$ === t.$name$ : n ? !0 : e.$key$ === t.$key$ : !1, q = (e) => e && e["s-ol"] || e, fe = (e) => (e["s-ol"] ? e["s-ol"] : e).parentNode, _ = (e, t, n = !1) => {
  const s = t.$elm$ = e.$elm$, l = e.$children$, c = t.$children$, o = t.$tag$, r = t.$text$;
  let i;
  r === null ? (S = o === "svg" ? !0 : o === "foreignObject" ? !1 : S, o === "slot" || re(e, t, S), l !== null && c !== null ? Pe(s, l, t, c, n) : c !== null ? (e.$text$ !== null && (s.textContent = ""), ae(s, null, t, c, 0, c.length - 1)) : l !== null && $e(l, 0, l.length - 1), S && o === "svg" && (S = !1)) : (i = s["s-cr"]) ? i.parentNode.textContent = r : e.$text$ !== r && (s.data = r);
}, de = (e) => {
  const t = e.childNodes;
  for (const n of t)
    if (n.nodeType === 1) {
      if (n["s-sr"]) {
        const s = n["s-sn"];
        n.hidden = !1;
        for (const l of t)
          if (l !== n) {
            if (l["s-hn"] !== n["s-hn"] || s !== "") {
              if (l.nodeType === 1 && (s === l.getAttribute("slot") || s === l["s-sn"])) {
                n.hidden = !0;
                break;
              }
            } else if (l.nodeType === 1 || l.nodeType === 3 && l.textContent.trim() !== "") {
              n.hidden = !0;
              break;
            }
          }
      }
      de(n);
    }
}, k = [], ue = (e) => {
  let t, n, s;
  for (const l of e.childNodes) {
    if (l["s-sr"] && (t = l["s-cr"]) && t.parentNode) {
      n = t.parentNode.childNodes;
      const c = l["s-sn"];
      for (s = n.length - 1; s >= 0; s--)
        if (t = n[s], !t["s-cn"] && !t["s-nr"] && t["s-hn"] !== l["s-hn"] && !L.experimentalSlotFixes)
          if (Y(t, c)) {
            let o = k.find((r) => r.$nodeToRelocate$ === t);
            H = !0, t["s-sn"] = t["s-sn"] || c, o ? (o.$nodeToRelocate$["s-sh"] = l["s-hn"], o.$slotRefNode$ = l) : (t["s-sh"] = l["s-hn"], k.push({
              $slotRefNode$: l,
              $nodeToRelocate$: t
            })), t["s-sr"] && k.map((r) => {
              Y(r.$nodeToRelocate$, t["s-sn"]) && (o = k.find((i) => i.$nodeToRelocate$ === t), o && !r.$slotRefNode$ && (r.$slotRefNode$ = o.$slotRefNode$));
            });
          } else k.some((o) => o.$nodeToRelocate$ === t) || k.push({
            $nodeToRelocate$: t
          });
    }
    l.nodeType === 1 && ue(l);
  }
}, Y = (e, t) => e.nodeType === 1 ? e.getAttribute("slot") === null && t === "" || e.getAttribute("slot") === t : e["s-sn"] === t ? !0 : t === "", he = (e) => {
  e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(he);
}, Ue = (e, t, n = !1) => {
  var s, l, c, o, r;
  const i = e.$hostElement$, u = e.$cmpMeta$, f = e.$vnode$ || w(null, null), a = Ee(t) ? t : v(null, null, t);
  if (R = i.tagName, u.$attrsToReflect$ && (a.$attrs$ = a.$attrs$ || {}, u.$attrsToReflect$.map(([d, $]) => a.$attrs$[$] = i[d])), n && a.$attrs$)
    for (const d of Object.keys(a.$attrs$))
      i.hasAttribute(d) && !["key", "ref", "style", "class"].includes(d) && (a.$attrs$[d] = i[d]);
  a.$tag$ = null, a.$flags$ |= 4, e.$vnode$ = a, a.$elm$ = f.$elm$ = i.shadowRoot || i, E = i["s-sc"], j = i["s-cr"], oe = (u.$flags$ & 1) !== 0, H = !1, _(f, a, n);
  {
    if (p.$flags$ |= 1, W) {
      ue(a.$elm$);
      for (const d of k) {
        const $ = d.$nodeToRelocate$;
        if (!$["s-ol"]) {
          const h = b.createTextNode("");
          h["s-nr"] = $, $.parentNode.insertBefore($["s-ol"] = h, $);
        }
      }
      for (const d of k) {
        const $ = d.$nodeToRelocate$, h = d.$slotRefNode$;
        if (h) {
          const y = h.parentNode;
          let g = h.nextSibling;
          {
            let T = (s = $["s-ol"]) === null || s === void 0 ? void 0 : s.previousSibling;
            for (; T; ) {
              let m = (l = T["s-nr"]) !== null && l !== void 0 ? l : null;
              if (m && m["s-sn"] === $["s-sn"] && y === m.parentNode && (m = m.nextSibling, !m || !m["s-nr"])) {
                g = m;
                break;
              }
              T = T.previousSibling;
            }
          }
          (!g && y !== $.parentNode || $.nextSibling !== g) && $ !== g && (!$["s-hn"] && $["s-ol"] && ($["s-hn"] = $["s-ol"].parentNode.nodeName), y.insertBefore($, g), $.nodeType === 1 && ($.hidden = (c = $["s-ih"]) !== null && c !== void 0 ? c : !1));
        } else
          $.nodeType === 1 && (n && ($["s-ih"] = (o = $.hidden) !== null && o !== void 0 ? o : !1), $.hidden = !0);
      }
    }
    H && de(a.$elm$), p.$flags$ &= -2, k.length = 0;
  }
  if (L.experimentalScopedSlotChanges && u.$flags$ & 2)
    for (const d of a.$elm$.childNodes)
      d["s-hn"] !== R && !d["s-sh"] && (n && d["s-ih"] == null && (d["s-ih"] = (r = d.hidden) !== null && r !== void 0 ? r : !1), d.hidden = !0);
  j = void 0;
}, De = (e, t) => {
}, pe = (e, t) => (e.$flags$ |= 16, De(e, e.$ancestorComponent$), at(() => je(e, t))), je = (e, t) => {
  const n = e.$hostElement$, s = x("scheduleUpdate", e.$cmpMeta$.$tagName$), l = n;
  let c;
  return t ? c = A(l, "componentWillLoad") : c = A(l, "componentWillUpdate"), c = V(c, () => A(l, "componentWillRender")), s(), V(c, () => Ne(e, l, t));
}, V = (e, t) => Be(e) ? e.then(t) : t(), Be = (e) => e instanceof Promise || e && e.then && typeof e.then == "function", Ne = async (e, t, n) => {
  const s = e.$hostElement$, l = x("update", e.$cmpMeta$.$tagName$);
  s["s-rc"], n && Fe(e);
  const c = x("render", e.$cmpMeta$.$tagName$);
  We(e, t, s, n), c(), l(), ze(e);
}, We = (e, t, n, s) => {
  try {
    Z = t, t = t.render && t.render(), e.$flags$ &= -17, e.$flags$ |= 2, (L.hasRenderFn || L.reflect) && (L.vdomRender || L.reflect) && (L.hydrateServerSide || Ue(e, t, s));
  } catch (i) {
    O(i, e.$hostElement$);
  }
  return Z = null, null;
}, ze = (e) => {
  const t = e.$cmpMeta$.$tagName$, n = e.$hostElement$, s = x("postUpdate", t), l = n;
  e.$ancestorComponent$, A(l, "componentDidRender"), e.$flags$ & 64 ? (A(l, "componentDidUpdate"), s()) : (e.$flags$ |= 64, A(l, "componentDidLoad"), s());
}, A = (e, t, n) => {
  if (e && e[t])
    try {
      return e[t](n);
    } catch (s) {
      O(s);
    }
}, qe = (e, t) => M(e).$instanceValues$.get(t), Ze = (e, t, n, s) => {
  const l = M(e), c = e, o = l.$instanceValues$.get(t), r = l.$flags$, i = c;
  n = Ce(n, s.$members$[t][0]);
  const u = Number.isNaN(o) && Number.isNaN(n);
  if (n !== o && !u) {
    l.$instanceValues$.set(t, n);
    {
      if (s.$watchers$ && r & 128) {
        const a = s.$watchers$[t];
        a && a.map((d) => {
          try {
            i[d](n, o, t);
          } catch ($) {
            O($, c);
          }
        });
      }
      if ((r & 18) === 2) {
        if (i.componentShouldUpdate && i.componentShouldUpdate(n, o, t) === !1)
          return;
        pe(l, !1);
      }
    }
  }
}, Ge = (e, t, n) => {
  var s;
  const l = e.prototype;
  if (t.$members$) {
    e.watchers && (t.$watchers$ = e.watchers);
    const c = Object.entries(t.$members$);
    c.map(([o, [r]]) => {
      (r & 31 || r & 32) && Object.defineProperty(l, o, {
        get() {
          return qe(this, o);
        },
        set(i) {
          Ze(this, o, i, t);
        },
        configurable: !0,
        enumerable: !0
      });
    });
    {
      const o = /* @__PURE__ */ new Map();
      l.attributeChangedCallback = function(r, i, u) {
        p.jmp(() => {
          var f;
          const a = o.get(r);
          if (this.hasOwnProperty(a))
            u = this[a], delete this[a];
          else {
            if (l.hasOwnProperty(a) && typeof this[a] == "number" && this[a] == u)
              return;
            if (a == null) {
              const d = M(this), $ = d == null ? void 0 : d.$flags$;
              if ($ && !($ & 8) && $ & 128 && u !== i) {
                const y = this, g = (f = t.$watchers$) === null || f === void 0 ? void 0 : f[r];
                g == null || g.forEach((T) => {
                  y[T] != null && y[T].call(y, u, i, r);
                });
              }
              return;
            }
          }
          this[a] = u === null && typeof this[a] == "boolean" ? !1 : u;
        });
      }, e.observedAttributes = Array.from(/* @__PURE__ */ new Set([
        ...Object.keys((s = t.$watchers$) !== null && s !== void 0 ? s : {}),
        ...c.filter(
          ([r, i]) => i[0] & 15
          /* MEMBER_FLAGS.HasAttribute */
        ).map(([r, i]) => {
          var u;
          const f = i[1] || r;
          return o.set(f, r), i[0] & 512 && ((u = t.$attrsToReflect$) === null || u === void 0 || u.push([r, f])), f;
        })
      ]));
    }
  }
  return e;
}, Ie = async (e, t, n, s) => {
  let l;
  if (!(t.$flags$ & 32) && (t.$flags$ |= 32, l = e.constructor, customElements.whenDefined(n.$tagName$).then(() => t.$flags$ |= 128), l.style)) {
    let o = l.style;
    typeof o != "string" && (o = o[t.$modeName$ = Re(e)]);
    const r = ie(n, t.$modeName$);
    if (!U.has(r)) {
      const i = x("registerStyles", n.$tagName$);
      Me(r, o, !!(n.$flags$ & 1)), i();
    }
  }
  t.$ancestorComponent$, pe(t, !0);
}, ee = (e) => {
}, Qe = (e) => {
  if (!(p.$flags$ & 1)) {
    const t = M(e), n = t.$cmpMeta$, s = x("connectedCallback", n.$tagName$);
    t.$flags$ & 1 ? (ge(e, t, n.$listeners$), t != null && t.$lazyInstance$ ? ee(t.$lazyInstance$) : t != null && t.$onReadyPromise$ && t.$onReadyPromise$.then(() => ee(t.$lazyInstance$))) : (t.$flags$ |= 1, // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
    n.$flags$ & 12 && Xe(e), n.$members$ && Object.entries(n.$members$).map(([l, [c]]) => {
      if (c & 31 && e.hasOwnProperty(l)) {
        const o = e[l];
        delete e[l], e[l] = o;
      }
    }), Ie(e, t, n)), s();
  }
}, Xe = (e) => {
  const t = e["s-cr"] = b.createComment("");
  t["s-cn"] = !0, e.insertBefore(t, e.firstChild);
}, Ke = async (e) => {
  if (!(p.$flags$ & 1)) {
    const t = M(e);
    t.$rmListeners$ && (t.$rmListeners$.map((n) => n()), t.$rmListeners$ = void 0);
  }
}, Je = (e, t) => {
  const n = {
    $flags$: t[0],
    $tagName$: t[1]
  };
  n.$members$ = t[2], n.$listeners$ = t[3], n.$watchers$ = e.$watchers$, n.$attrsToReflect$ = [], !se && n.$flags$ & 1 && (n.$flags$ |= 8);
  const s = e.prototype.connectedCallback, l = e.prototype.disconnectedCallback;
  return Object.assign(e.prototype, {
    __registerHost() {
      tt(this, n);
    },
    connectedCallback() {
      Qe(this), s && s.call(this);
    },
    disconnectedCallback() {
      Ke(this), l && l.call(this);
    },
    __attachShadow() {
      se ? this.attachShadow({
        mode: "open",
        delegatesFocus: !!(n.$flags$ & 16)
      }) : this.shadowRoot = this;
    }
  }), e.is = n.$tagName$, Ge(e, n);
}, ge = (e, t, n, s) => {
  n && n.map(([l, c, o]) => {
    const r = Ve(e, l), i = Ye(t, o), u = et(l);
    p.ael(r, c, i, u), (t.$rmListeners$ = t.$rmListeners$ || []).push(() => p.rel(r, c, i, u));
  });
}, Ye = (e, t) => (n) => {
  try {
    L.lazyLoad || e.$hostElement$[t](n);
  } catch (s) {
    O(s);
  }
}, Ve = (e, t) => t & 4 ? b : t & 8 ? D : t & 16 ? b.body : e, et = (e) => lt ? {
  passive: (e & 1) !== 0,
  capture: (e & 2) !== 0
} : (e & 2) !== 0, ye = /* @__PURE__ */ new WeakMap(), M = (e) => ye.get(e), tt = (e, t) => {
  const n = {
    $flags$: 0,
    $hostElement$: e,
    $cmpMeta$: t,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  return ge(e, n, t.$listeners$), ye.set(e, n);
}, te = (e, t) => t in e, O = (e, t) => (0, console.error)(e, t), U = /* @__PURE__ */ new Map(), st = [], D = typeof window < "u" ? window : {}, b = D.document || { head: {} }, nt = D.HTMLElement || class {
}, p = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (e) => e(),
  raf: (e) => requestAnimationFrame(e),
  ael: (e, t, n, s) => e.addEventListener(t, n, s),
  rel: (e, t, n, s) => e.removeEventListener(t, n, s),
  ce: (e, t) => new CustomEvent(e, t)
}, se = (
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  !0
), lt = /* @__PURE__ */ (() => {
  let e = !1;
  try {
    b.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        e = !0;
      }
    }));
  } catch {
  }
  return e;
})(), ot = (e) => Promise.resolve(e), it = /* @__PURE__ */ (() => {
  try {
    return new CSSStyleSheet(), typeof new CSSStyleSheet().replaceSync == "function";
  } catch {
  }
  return !1;
})(), ne = [], ve = [], ct = (e, t) => (n) => {
  e.push(n), B || (B = !0, t && p.$flags$ & 4 ? rt(N) : p.raf(N));
}, le = (e) => {
  for (let t = 0; t < e.length; t++)
    try {
      e[t](performance.now());
    } catch (n) {
      O(n);
    }
  e.length = 0;
}, N = () => {
  le(ne), le(ve), (B = ne.length > 0) && p.raf(N);
}, rt = (e) => ot().then(e), at = /* @__PURE__ */ ct(ve, !0), $t = ".sc-google-meet-icon-h{display:flex}", ft = $t, Se = Je(class extends nt {
  constructor() {
    super(), this.__registerHost(), this.width = "20", this.height = "20";
  }
  render() {
    return v("svg", { key: "9f03ccab4f00c2158f84c03376a7e6c5d99a7b00", width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, v("g", { key: "f93575ecf387c45f3d162cd792d8b71ec92563b8", "clip-path": "url(#clip0_22_6251)" }, v("path", { key: "39b8d6701c1b61e51a6c74e92a16ca2224648605", d: "M11.3145 10.1036L13.2642 12.3321L15.8859 14.0076L16.343 10.1173L15.8859 6.31384L13.2139 7.78584L11.3145 10.1036Z", fill: "#00832D" }), v("path", { key: "62a4fb15a3568df59831c65ff7a298cda96f566a", d: "M0 13.6464V16.9607C0 17.7184 0.613714 18.3321 1.37143 18.3321H4.68571L5.37143 15.827L4.68571 13.6464L2.41143 12.9607L0 13.6464Z", fill: "#0066DA" }), v("path", { key: "77387898e00bfdca723ee5a30b663fda4d166c82", d: "M4.68571 1.875L0 6.56071L2.41143 7.24643L4.68571 6.56071L5.36 4.40986L4.68571 1.875Z", fill: "#E94235" }), v("path", { key: "a332ef42bee0a2cefa85edab05ed57eb44b2f3fd", d: "M4.68571 6.56067H0V13.6464H4.68571V6.56067Z", fill: "#2684FC" }), v("path", { key: "80c315571da0c068cbe01410c1449fc2e3b9f6d1", d: "M18.8798 3.85895L15.8855 6.31381V14.0075L18.8935 16.4738C19.3438 16.8258 20.0021 16.5047 20.0021 15.9321V4.38923C20.0021 3.80981 19.329 3.49209 18.8798 3.85895ZM11.3141 10.1035V13.6464H4.68555V18.3321H14.5141C15.2718 18.3321 15.8855 17.7184 15.8855 16.9607V14.0075L11.3141 10.1035Z", fill: "#00AC47" }), v("path", { key: "c5ebdb0105b0515af8fba4ceebe23f390e13a241", d: "M14.5141 1.875H4.68555V6.56071H11.3141V10.1036L15.8855 6.31614V3.24643C15.8855 2.48871 15.2718 1.875 14.5141 1.875Z", fill: "#FFBA00" })), v("defs", { key: "0f8ba76223090e75c94366e833a394a51446f8a9" }, v("clipPath", { key: "2ba697058c4419abdaf524d6f77b34b11f24ac8a", id: "clip0_22_6251" }, v("rect", { key: "35df545d162e5c7385a4d9c756293d76527e604b", width: "20", height: "20", fill: "white" }))));
  }
  static get style() {
    return ft;
  }
}, [2, "google-meet-icon", {
  width: [1],
  height: [1]
}]);
function dt() {
  if (typeof customElements > "u")
    return;
  ["google-meet-icon"].forEach((t) => {
    switch (t) {
      case "google-meet-icon":
        customElements.get(t) || customElements.define(t, Se);
        break;
    }
  });
}
const ht = Se, pt = dt;
export {
  ht as GoogleMeetIcon,
  pt as defineCustomElement
};
