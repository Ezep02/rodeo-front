const x = {
  allRenderFn: !1,
  cmpDidLoad: !0,
  cmpDidUnload: !1,
  cmpDidUpdate: !0,
  cmpDidRender: !0,
  cmpWillLoad: !0,
  cmpWillUpdate: !0,
  cmpWillRender: !0,
  connectedCallback: !0,
  disconnectedCallback: !0,
  element: !0,
  event: !0,
  hasRenderFn: !0,
  lifecycle: !0,
  hostListener: !0,
  hostListenerTargetWindow: !0,
  hostListenerTargetDocument: !0,
  hostListenerTargetBody: !0,
  hostListenerTargetParent: !1,
  hostListenerTarget: !0,
  member: !0,
  method: !0,
  mode: !0,
  observeAttribute: !0,
  prop: !0,
  propMutable: !0,
  reflect: !0,
  scoped: !0,
  shadowDom: !0,
  slot: !0,
  cssAnnotations: !0,
  state: !0,
  style: !0,
  formAssociated: !1,
  svg: !0,
  updatable: !0,
  vdomAttribute: !0,
  vdomXlink: !0,
  vdomClass: !0,
  vdomFunctional: !0,
  vdomKey: !0,
  vdomListener: !0,
  vdomRef: !0,
  vdomPropOrAttr: !0,
  vdomRender: !0,
  vdomStyle: !0,
  vdomText: !0,
  watchCallback: !0,
  taskQueue: !0,
  hotModuleReplacement: !1,
  isDebug: !1,
  isDev: !1,
  isTesting: !1,
  hydrateServerSide: !1,
  hydrateClientSide: !1,
  lifecycleDOMEvents: !1,
  lazyLoad: !1,
  profile: !1,
  slotRelocation: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: !1,
  hydratedAttribute: !1,
  hydratedClass: !0,
  scriptDataOpts: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: !1,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: !1,
  invisiblePrehydration: !0,
  propBoolean: !0,
  propNumber: !0,
  propString: !0,
  constructableCSS: !0,
  cmpShouldUpdate: !0,
  devTools: !1,
  shadowDelegatesFocus: !0,
  initializeNextTick: !1,
  asyncLoading: !1,
  asyncQueue: !1,
  transformTagName: !1,
  attachStyles: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: !1
};
let E, D, w, lt = !1, B = !1, W = !1, y = !1, I = null, M = !1;
const L = (t, e = "") => () => {
}, St = "slot-fb{display:contents}slot-fb[hidden]{display:none}", Q = "http://www.w3.org/1999/xlink", X = {}, xt = "http://www.w3.org/2000/svg", Tt = "http://www.w3.org/1999/xhtml", Lt = (t) => t != null, N = (t) => (t = typeof t, t === "object" || t === "function");
function Et(t) {
  var e, n, s;
  return (s = (n = (e = t.head) === null || e === void 0 ? void 0 : e.querySelector('meta[name="csp-nonce"]')) === null || n === void 0 ? void 0 : n.getAttribute("content")) !== null && s !== void 0 ? s : void 0;
}
const k = (t, e, ...n) => {
  let s = null, o = null, i = null, l = !1, a = !1;
  const r = [], u = (c) => {
    for (let f = 0; f < c.length; f++)
      s = c[f], Array.isArray(s) ? u(s) : s != null && typeof s != "boolean" && ((l = typeof t != "function" && !N(s)) && (s = String(s)), l && a ? r[r.length - 1].$text$ += s : r.push(l ? F(null, s) : s), a = l);
  };
  if (u(n), e) {
    e.key && (o = e.key), e.name && (i = e.name);
    {
      const c = e.className || e.class;
      c && (e.class = typeof c != "object" ? c : Object.keys(c).filter((f) => c[f]).join(" "));
    }
  }
  if (typeof t == "function")
    return t(e === null ? {} : e, r, wt);
  const $ = F(t, null);
  return $.$attrs$ = e, r.length > 0 && ($.$children$ = r), $.$key$ = o, $.$name$ = i, $;
}, F = (t, e) => {
  const n = {
    $flags$: 0,
    $tag$: t,
    $text$: e,
    $elm$: null,
    $children$: null
  };
  return n.$attrs$ = null, n.$key$ = null, n.$name$ = null, n;
}, _t = {}, Ot = (t) => t && t.$tag$ === _t, wt = {
  forEach: (t, e) => t.map(Y).forEach(e),
  map: (t, e) => t.map(Y).map(e).map(Ht)
}, Y = (t) => ({
  vattrs: t.$attrs$,
  vchildren: t.$children$,
  vkey: t.$key$,
  vname: t.$name$,
  vtag: t.$tag$,
  vtext: t.$text$
}), Ht = (t) => {
  if (typeof t.vtag == "function") {
    const n = Object.assign({}, t.vattrs);
    return t.vkey && (n.key = t.vkey), t.vname && (n.name = t.vname), k(t.vtag, n, ...t.vchildren || []);
  }
  const e = F(t.vtag, t.vtext);
  return e.$attrs$ = t.vattrs, e.$children$ = t.vchildren, e.$key$ = t.vkey, e.$name$ = t.vname, e;
}, At = (t) => ne.map((e) => e(t)).find((e) => !!e), Ct = (t, e) => t != null && !N(t) ? e & 4 ? t === "false" ? !1 : t === "" || !!t : e & 2 ? parseFloat(t) : e & 1 ? String(t) : t : t, G = /* @__PURE__ */ new WeakMap(), Rt = (t, e, n) => {
  let s = U.get(t);
  re && n ? (s = s || new CSSStyleSheet(), typeof s == "string" ? s = e : s.replaceSync(e)) : s = e, U.set(t, s);
}, Bt = (t, e, n) => {
  var s;
  const o = rt(e, n), i = U.get(o);
  if (t = t.nodeType === 11 ? t : v, i)
    if (typeof i == "string") {
      t = t.head || t;
      let l = G.get(t), a;
      if (l || G.set(t, l = /* @__PURE__ */ new Set()), !l.has(o)) {
        {
          a = v.createElement("style"), a.innerHTML = i;
          const r = (s = h.$nonce$) !== null && s !== void 0 ? s : Et(v);
          r != null && a.setAttribute("nonce", r), t.insertBefore(a, t.querySelector("link"));
        }
        e.$flags$ & 4 && (a.innerHTML += St), l && l.add(o);
      }
    } else t.adoptedStyleSheets.includes(i) || (t.adoptedStyleSheets = [...t.adoptedStyleSheets, i]);
  return o;
}, Ft = (t) => {
  const e = t.$cmpMeta$, n = t.$hostElement$, s = e.$flags$, o = L("attachStyles", e.$tagName$), i = Bt(n.shadowRoot ? n.shadowRoot : n.getRootNode(), e, t.$modeName$);
  s & 10 && (n["s-sc"] = i, n.classList.add(i + "-h"), s & 2 && n.classList.add(i + "-s")), o();
}, rt = (t, e) => "sc-" + (e && t.$flags$ & 32 ? t.$tagName$ + "-" + e : t.$tagName$), K = (t, e, n, s, o, i) => {
  if (n !== s) {
    let l = et(t, e), a = e.toLowerCase();
    if (e === "class") {
      const r = t.classList, u = J(n), $ = J(s);
      r.remove(...u.filter((c) => c && !$.includes(c))), r.add(...$.filter((c) => c && !u.includes(c)));
    } else if (e === "style") {
      for (const r in n)
        (!s || s[r] == null) && (r.includes("-") ? t.style.removeProperty(r) : t.style[r] = "");
      for (const r in s)
        (!n || s[r] !== n[r]) && (r.includes("-") ? t.style.setProperty(r, s[r]) : t.style[r] = s[r]);
    } else if (e !== "key")
      if (e === "ref")
        s && s(t);
      else if (!t.__lookupSetter__(e) && e[0] === "o" && e[1] === "n") {
        if (e[2] === "-" ? e = e.slice(3) : et(P, a) ? e = a.slice(2) : e = a[2] + e.slice(3), n || s) {
          const r = e.endsWith(it);
          e = e.replace(Ut, ""), n && h.rel(t, e, n, r), s && h.ael(t, e, s, r);
        }
      } else {
        const r = N(s);
        if ((l || r && s !== null) && !o)
          try {
            if (t.tagName.includes("-"))
              t[e] = s;
            else {
              const $ = s ?? "";
              e === "list" ? l = !1 : (n == null || t[e] != $) && (t[e] = $);
            }
          } catch {
          }
        let u = !1;
        a !== (a = a.replace(/^xlink\:?/, "")) && (e = a, u = !0), s == null || s === !1 ? (s !== !1 || t.getAttribute(e) === "") && (u ? t.removeAttributeNS(Q, e) : t.removeAttribute(e)) : (!l || i & 4 || o) && !r && (s = s === !0 ? "" : s, u ? t.setAttributeNS(Q, e, s) : t.setAttribute(e, s));
      }
  }
}, jt = /\s/, J = (t) => t ? t.split(jt) : [], it = "Capture", Ut = new RegExp(it + "$"), at = (t, e, n, s) => {
  const o = e.$elm$.nodeType === 11 && e.$elm$.host ? e.$elm$.host : e.$elm$, i = t && t.$attrs$ || X, l = e.$attrs$ || X;
  for (s in i)
    s in l || K(o, s, i[s], void 0, n, e.$flags$);
  for (s in l)
    K(o, s, i[s], l[s], n, e.$flags$);
}, j = (t, e, n, s) => {
  const o = e.$children$[n];
  let i = 0, l, a, r;
  if (lt || (W = !0, o.$tag$ === "slot" && (E && s.classList.add(E + "-s"), o.$flags$ |= o.$children$ ? (
    // slot element has fallback content
    2
  ) : (
    // slot element does not have fallback content
    1
  ))), o.$text$ !== null)
    l = o.$elm$ = v.createTextNode(o.$text$);
  else if (o.$flags$ & 1)
    l = o.$elm$ = v.createTextNode("");
  else {
    if (y || (y = o.$tag$ === "svg"), l = o.$elm$ = v.createElementNS(y ? xt : Tt, o.$flags$ & 2 ? "slot-fb" : o.$tag$), y && o.$tag$ === "foreignObject" && (y = !1), at(null, o, y), Lt(E) && l["s-si"] !== E && l.classList.add(l["s-si"] = E), o.$children$)
      for (i = 0; i < o.$children$.length; ++i)
        a = j(t, o, i, l), a && l.appendChild(a);
    o.$tag$ === "svg" ? y = !1 : l.tagName === "foreignObject" && (y = !0);
  }
  return l["s-hn"] = w, o.$flags$ & 3 && (l["s-sr"] = !0, l["s-cr"] = D, l["s-sn"] = o.$name$ || "", r = t && t.$children$ && t.$children$[n], r && r.$tag$ === o.$tag$ && t.$elm$ && H(t.$elm$, !1)), l;
}, H = (t, e) => {
  h.$flags$ |= 1;
  const n = t.childNodes;
  for (let s = n.length - 1; s >= 0; s--) {
    const o = n[s];
    o["s-hn"] !== w && o["s-ol"] && ($t(o).insertBefore(o, q(o)), o["s-ol"].remove(), o["s-ol"] = void 0, o["s-sh"] = void 0, W = !0), e && H(o, e);
  }
  h.$flags$ &= -2;
}, ct = (t, e, n, s, o, i) => {
  let l = t["s-cr"] && t["s-cr"].parentNode || t, a;
  for (l.shadowRoot && l.tagName === w && (l = l.shadowRoot); o <= i; ++o)
    s[o] && (a = j(null, n, o, t), a && (s[o].$elm$ = a, l.insertBefore(a, q(e))));
}, dt = (t, e, n) => {
  for (let s = e; s <= n; ++s) {
    const o = t[s];
    if (o) {
      const i = o.$elm$;
      pt(o), i && (B = !0, i["s-ol"] ? i["s-ol"].remove() : H(i, !0), i.remove());
    }
  }
}, Pt = (t, e, n, s, o = !1) => {
  let i = 0, l = 0, a = 0, r = 0, u = e.length - 1, $ = e[0], c = e[u], f = s.length - 1, d = s[0], p = s[f], b, g;
  for (; i <= u && l <= f; )
    if ($ == null)
      $ = e[++i];
    else if (c == null)
      c = e[--u];
    else if (d == null)
      d = s[++l];
    else if (p == null)
      p = s[--f];
    else if (R($, d, o))
      _($, d, o), $ = e[++i], d = s[++l];
    else if (R(c, p, o))
      _(c, p, o), c = e[--u], p = s[--f];
    else if (R($, p, o))
      ($.$tag$ === "slot" || p.$tag$ === "slot") && H($.$elm$.parentNode, !1), _($, p, o), t.insertBefore($.$elm$, c.$elm$.nextSibling), $ = e[++i], p = s[--f];
    else if (R(c, d, o))
      ($.$tag$ === "slot" || p.$tag$ === "slot") && H(c.$elm$.parentNode, !1), _(c, d, o), t.insertBefore(c.$elm$, $.$elm$), c = e[--u], d = s[++l];
    else {
      for (a = -1, r = i; r <= u; ++r)
        if (e[r] && e[r].$key$ !== null && e[r].$key$ === d.$key$) {
          a = r;
          break;
        }
      a >= 0 ? (g = e[a], g.$tag$ !== d.$tag$ ? b = j(e && e[l], n, a, t) : (_(g, d, o), e[a] = void 0, b = g.$elm$), d = s[++l]) : (b = j(e && e[l], n, l, t), d = s[++l]), b && $t($.$elm$).insertBefore(b, q($.$elm$));
    }
  i > u ? ct(t, s[f + 1] == null ? null : s[f + 1].$elm$, n, s, l, f) : l > f && dt(e, i, u);
}, R = (t, e, n = !1) => t.$tag$ === e.$tag$ ? t.$tag$ === "slot" ? t.$name$ === e.$name$ : n ? !0 : t.$key$ === e.$key$ : !1, q = (t) => t && t["s-ol"] || t, $t = (t) => (t["s-ol"] ? t["s-ol"] : t).parentNode, _ = (t, e, n = !1) => {
  const s = e.$elm$ = t.$elm$, o = t.$children$, i = e.$children$, l = e.$tag$, a = e.$text$;
  let r;
  a === null ? (y = l === "svg" ? !0 : l === "foreignObject" ? !1 : y, l === "slot" || at(t, e, y), o !== null && i !== null ? Pt(s, o, e, i, n) : i !== null ? (t.$text$ !== null && (s.textContent = ""), ct(s, null, e, i, 0, i.length - 1)) : o !== null && dt(o, 0, o.length - 1), y && l === "svg" && (y = !1)) : (r = s["s-cr"]) ? r.parentNode.textContent = a : t.$text$ !== a && (s.data = a);
}, ft = (t) => {
  const e = t.childNodes;
  for (const n of e)
    if (n.nodeType === 1) {
      if (n["s-sr"]) {
        const s = n["s-sn"];
        n.hidden = !1;
        for (const o of e)
          if (o !== n) {
            if (o["s-hn"] !== n["s-hn"] || s !== "") {
              if (o.nodeType === 1 && (s === o.getAttribute("slot") || s === o["s-sn"])) {
                n.hidden = !0;
                break;
              }
            } else if (o.nodeType === 1 || o.nodeType === 3 && o.textContent.trim() !== "") {
              n.hidden = !0;
              break;
            }
          }
      }
      ft(n);
    }
}, m = [], ut = (t) => {
  let e, n, s;
  for (const o of t.childNodes) {
    if (o["s-sr"] && (e = o["s-cr"]) && e.parentNode) {
      n = e.parentNode.childNodes;
      const i = o["s-sn"];
      for (s = n.length - 1; s >= 0; s--)
        if (e = n[s], !e["s-cn"] && !e["s-nr"] && e["s-hn"] !== o["s-hn"] && !x.experimentalSlotFixes)
          if (Z(e, i)) {
            let l = m.find((a) => a.$nodeToRelocate$ === e);
            B = !0, e["s-sn"] = e["s-sn"] || i, l ? (l.$nodeToRelocate$["s-sh"] = o["s-hn"], l.$slotRefNode$ = o) : (e["s-sh"] = o["s-hn"], m.push({
              $slotRefNode$: o,
              $nodeToRelocate$: e
            })), e["s-sr"] && m.map((a) => {
              Z(a.$nodeToRelocate$, e["s-sn"]) && (l = m.find((r) => r.$nodeToRelocate$ === e), l && !a.$slotRefNode$ && (a.$slotRefNode$ = l.$slotRefNode$));
            });
          } else m.some((l) => l.$nodeToRelocate$ === e) || m.push({
            $nodeToRelocate$: e
          });
    }
    o.nodeType === 1 && ut(o);
  }
}, Z = (t, e) => t.nodeType === 1 ? t.getAttribute("slot") === null && e === "" || t.getAttribute("slot") === e : t["s-sn"] === e ? !0 : e === "", pt = (t) => {
  t.$attrs$ && t.$attrs$.ref && t.$attrs$.ref(null), t.$children$ && t.$children$.map(pt);
}, Dt = (t, e, n = !1) => {
  var s, o, i, l, a;
  const r = t.$hostElement$, u = t.$cmpMeta$, $ = t.$vnode$ || F(null, null), c = Ot(e) ? e : k(null, null, e);
  if (w = r.tagName, u.$attrsToReflect$ && (c.$attrs$ = c.$attrs$ || {}, u.$attrsToReflect$.map(([f, d]) => c.$attrs$[d] = r[f])), n && c.$attrs$)
    for (const f of Object.keys(c.$attrs$))
      r.hasAttribute(f) && !["key", "ref", "style", "class"].includes(f) && (c.$attrs$[f] = r[f]);
  c.$tag$ = null, c.$flags$ |= 4, t.$vnode$ = c, c.$elm$ = $.$elm$ = r.shadowRoot || r, E = r["s-sc"], D = r["s-cr"], lt = (u.$flags$ & 1) !== 0, B = !1, _($, c, n);
  {
    if (h.$flags$ |= 1, W) {
      ut(c.$elm$);
      for (const f of m) {
        const d = f.$nodeToRelocate$;
        if (!d["s-ol"]) {
          const p = v.createTextNode("");
          p["s-nr"] = d, d.parentNode.insertBefore(d["s-ol"] = p, d);
        }
      }
      for (const f of m) {
        const d = f.$nodeToRelocate$, p = f.$slotRefNode$;
        if (p) {
          const b = p.parentNode;
          let g = p.nextSibling;
          {
            let T = (s = d["s-ol"]) === null || s === void 0 ? void 0 : s.previousSibling;
            for (; T; ) {
              let S = (o = T["s-nr"]) !== null && o !== void 0 ? o : null;
              if (S && S["s-sn"] === d["s-sn"] && b === S.parentNode && (S = S.nextSibling, !S || !S["s-nr"])) {
                g = S;
                break;
              }
              T = T.previousSibling;
            }
          }
          (!g && b !== d.parentNode || d.nextSibling !== g) && d !== g && (!d["s-hn"] && d["s-ol"] && (d["s-hn"] = d["s-ol"].parentNode.nodeName), b.insertBefore(d, g), d.nodeType === 1 && (d.hidden = (i = d["s-ih"]) !== null && i !== void 0 ? i : !1));
        } else
          d.nodeType === 1 && (n && (d["s-ih"] = (l = d.hidden) !== null && l !== void 0 ? l : !1), d.hidden = !0);
      }
    }
    B && ft(c.$elm$), h.$flags$ &= -2, m.length = 0;
  }
  if (x.experimentalScopedSlotChanges && u.$flags$ & 2)
    for (const f of c.$elm$.childNodes)
      f["s-hn"] !== w && !f["s-sh"] && (n && f["s-ih"] == null && (f["s-ih"] = (a = f.hidden) !== null && a !== void 0 ? a : !1), f.hidden = !0);
  D = void 0;
}, Mt = (t, e) => {
}, ht = (t, e) => (t.$flags$ |= 16, Mt(t, t.$ancestorComponent$), ce(() => zt(t, e))), zt = (t, e) => {
  const n = t.$hostElement$, s = L("scheduleUpdate", t.$cmpMeta$.$tagName$), o = n;
  let i;
  return e ? i = O(o, "componentWillLoad") : i = O(o, "componentWillUpdate"), i = V(i, () => O(o, "componentWillRender")), s(), V(i, () => Nt(t, o, e));
}, V = (t, e) => Wt(t) ? t.then(e) : e(), Wt = (t) => t instanceof Promise || t && t.then && typeof t.then == "function", Nt = async (t, e, n) => {
  const s = t.$hostElement$, o = L("update", t.$cmpMeta$.$tagName$);
  s["s-rc"], n && Ft(t);
  const i = L("render", t.$cmpMeta$.$tagName$);
  qt(t, e, s, n), i(), o(), It(t);
}, qt = (t, e, n, s) => {
  try {
    I = e, e = e.render && e.render(), t.$flags$ &= -17, t.$flags$ |= 2, (x.hasRenderFn || x.reflect) && (x.vdomRender || x.reflect) && (x.hydrateServerSide || Dt(t, e, s));
  } catch (r) {
    C(r, t.$hostElement$);
  }
  return I = null, null;
}, It = (t) => {
  const e = t.$cmpMeta$.$tagName$, n = t.$hostElement$, s = L("postUpdate", e), o = n;
  t.$ancestorComponent$, O(o, "componentDidRender"), t.$flags$ & 64 ? (O(o, "componentDidUpdate"), s()) : (t.$flags$ |= 64, O(o, "componentDidLoad"), s());
}, O = (t, e, n) => {
  if (t && t[e])
    try {
      return t[e](n);
    } catch (s) {
      C(s);
    }
}, Qt = (t, e) => A(t).$instanceValues$.get(e), Xt = (t, e, n, s) => {
  const o = A(t), i = t, l = o.$instanceValues$.get(e), a = o.$flags$, r = i;
  n = Ct(n, s.$members$[e][0]);
  const u = Number.isNaN(l) && Number.isNaN(n);
  if (n !== l && !u) {
    o.$instanceValues$.set(e, n);
    {
      if (s.$watchers$ && a & 128) {
        const c = s.$watchers$[e];
        c && c.map((f) => {
          try {
            r[f](n, l, e);
          } catch (d) {
            C(d, i);
          }
        });
      }
      if ((a & 18) === 2) {
        if (r.componentShouldUpdate && r.componentShouldUpdate(n, l, e) === !1)
          return;
        ht(o, !1);
      }
    }
  }
}, Yt = (t, e, n) => {
  var s;
  const o = t.prototype;
  if (e.$members$) {
    t.watchers && (e.$watchers$ = t.watchers);
    const i = Object.entries(e.$members$);
    i.map(([l, [a]]) => {
      (a & 31 || a & 32) && Object.defineProperty(o, l, {
        get() {
          return Qt(this, l);
        },
        set(r) {
          Xt(this, l, r, e);
        },
        configurable: !0,
        enumerable: !0
      });
    });
    {
      const l = /* @__PURE__ */ new Map();
      o.attributeChangedCallback = function(a, r, u) {
        h.jmp(() => {
          var $;
          const c = l.get(a);
          if (this.hasOwnProperty(c))
            u = this[c], delete this[c];
          else {
            if (o.hasOwnProperty(c) && typeof this[c] == "number" && this[c] == u)
              return;
            if (c == null) {
              const f = A(this), d = f == null ? void 0 : f.$flags$;
              if (d && !(d & 8) && d & 128 && u !== r) {
                const b = this, g = ($ = e.$watchers$) === null || $ === void 0 ? void 0 : $[a];
                g == null || g.forEach((T) => {
                  b[T] != null && b[T].call(b, u, r, a);
                });
              }
              return;
            }
          }
          this[c] = u === null && typeof this[c] == "boolean" ? !1 : u;
        });
      }, t.observedAttributes = Array.from(/* @__PURE__ */ new Set([
        ...Object.keys((s = e.$watchers$) !== null && s !== void 0 ? s : {}),
        ...i.filter(
          ([a, r]) => r[0] & 15
          /* MEMBER_FLAGS.HasAttribute */
        ).map(([a, r]) => {
          var u;
          const $ = r[1] || a;
          return l.set($, a), r[0] & 512 && ((u = e.$attrsToReflect$) === null || u === void 0 || u.push([a, $])), $;
        })
      ]));
    }
  }
  return t;
}, Gt = async (t, e, n, s) => {
  let o;
  if (!(e.$flags$ & 32) && (e.$flags$ |= 32, o = t.constructor, customElements.whenDefined(n.$tagName$).then(() => e.$flags$ |= 128), o.style)) {
    let l = o.style;
    typeof l != "string" && (l = l[e.$modeName$ = At(t)]);
    const a = rt(n, e.$modeName$);
    if (!U.has(a)) {
      const r = L("registerStyles", n.$tagName$);
      Rt(a, l, !!(n.$flags$ & 1)), r();
    }
  }
  e.$ancestorComponent$, ht(e, !0);
}, tt = (t) => {
}, Kt = (t) => {
  if (!(h.$flags$ & 1)) {
    const e = A(t), n = e.$cmpMeta$, s = L("connectedCallback", n.$tagName$);
    e.$flags$ & 1 ? (bt(t, e, n.$listeners$), e != null && e.$lazyInstance$ ? tt(e.$lazyInstance$) : e != null && e.$onReadyPromise$ && e.$onReadyPromise$.then(() => tt(e.$lazyInstance$))) : (e.$flags$ |= 1, // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
    n.$flags$ & 12 && Jt(t), n.$members$ && Object.entries(n.$members$).map(([o, [i]]) => {
      if (i & 31 && t.hasOwnProperty(o)) {
        const l = t[o];
        delete t[o], t[o] = l;
      }
    }), Gt(t, e, n)), s();
  }
}, Jt = (t) => {
  const e = t["s-cr"] = v.createComment("");
  e["s-cn"] = !0, t.insertBefore(e, t.firstChild);
}, Zt = async (t) => {
  if (!(h.$flags$ & 1)) {
    const e = A(t);
    e.$rmListeners$ && (e.$rmListeners$.map((n) => n()), e.$rmListeners$ = void 0);
  }
}, gt = (t, e) => {
  const n = {
    $flags$: e[0],
    $tagName$: e[1]
  };
  n.$members$ = e[2], n.$listeners$ = e[3], n.$watchers$ = t.$watchers$, n.$attrsToReflect$ = [], !st && n.$flags$ & 1 && (n.$flags$ |= 8);
  const s = t.prototype.connectedCallback, o = t.prototype.disconnectedCallback;
  return Object.assign(t.prototype, {
    __registerHost() {
      se(this, n);
    },
    connectedCallback() {
      Kt(this), s && s.call(this);
    },
    disconnectedCallback() {
      Zt(this), o && o.call(this);
    },
    __attachShadow() {
      st ? this.attachShadow({
        mode: "open",
        delegatesFocus: !!(n.$flags$ & 16)
      }) : this.shadowRoot = this;
    }
  }), t.is = n.$tagName$, Yt(t, n);
}, bt = (t, e, n, s) => {
  n && n.map(([o, i, l]) => {
    const a = te(t, o), r = Vt(e, l), u = ee(o);
    h.ael(a, i, r, u), (e.$rmListeners$ = e.$rmListeners$ || []).push(() => h.rel(a, i, r, u));
  });
}, Vt = (t, e) => (n) => {
  try {
    x.lazyLoad || t.$hostElement$[e](n);
  } catch (s) {
    C(s);
  }
}, te = (t, e) => e & 4 ? v : e & 8 ? P : e & 16 ? v.body : t, ee = (t) => oe ? {
  passive: (t & 1) !== 0,
  capture: (t & 2) !== 0
} : (t & 2) !== 0, yt = /* @__PURE__ */ new WeakMap(), A = (t) => yt.get(t), se = (t, e) => {
  const n = {
    $flags$: 0,
    $hostElement$: t,
    $cmpMeta$: e,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  return bt(t, n, e.$listeners$), yt.set(t, n);
}, et = (t, e) => e in t, C = (t, e) => (0, console.error)(t, e), U = /* @__PURE__ */ new Map(), ne = [], P = typeof window < "u" ? window : {}, v = P.document || { head: {} }, vt = P.HTMLElement || class {
}, h = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (t) => t(),
  raf: (t) => requestAnimationFrame(t),
  ael: (t, e, n, s) => t.addEventListener(e, n, s),
  rel: (t, e, n, s) => t.removeEventListener(e, n, s),
  ce: (t, e) => new CustomEvent(t, e)
}, st = (
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  !0
), oe = /* @__PURE__ */ (() => {
  let t = !1;
  try {
    v.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        t = !0;
      }
    }));
  } catch {
  }
  return t;
})(), le = (t) => Promise.resolve(t), re = /* @__PURE__ */ (() => {
  try {
    return new CSSStyleSheet(), typeof new CSSStyleSheet().replaceSync == "function";
  } catch {
  }
  return !1;
})(), nt = [], mt = [], ie = (t, e) => (n) => {
  t.push(n), M || (M = !0, e && h.$flags$ & 4 ? ae(z) : h.raf(z));
}, ot = (t) => {
  for (let e = 0; e < t.length; e++)
    try {
      t[e](performance.now());
    } catch (n) {
      C(n);
    }
  t.length = 0;
}, z = () => {
  ot(nt), ot(mt), (M = nt.length > 0) && h.raf(z);
}, ae = (t) => le().then(t), ce = /* @__PURE__ */ ie(mt, !0), de = ".wave{display:flex;align-items:center;justify-content:center}.dot{width:4px;height:4px;background-color:var(--dot-color, white);border-radius:50%;margin:0 2px;animation:wave 1.5s infinite ease-in-out}.dot:nth-child(2){animation-delay:0.2s}.dot:nth-child(3){animation-delay:0.4s}@keyframes wave{0%,60%,100%{transform:translateY(0)}30%{transform:translateY(-4px)}}", $e = de, fe = gt(class extends vt {
  constructor() {
    super(), this.__registerHost(), this.__attachShadow(), this.width = "15", this.height = "15";
  }
  render() {
    return k("div", { key: "cedd3c86fe3766ab22b921d44d5fe9dabbb6e117", class: "wave" }, k("div", { key: "f1bb2fd41da0ac750f67d974859a9daa32bd6ea1", class: "dot" }), k("div", { key: "a6a07592c610b729b38aa2f827a88df3474169e5", class: "dot" }), k("div", { key: "49c403775d68c22bbaaf522e0ef9a4712873ab3b", class: "dot" }));
  }
  static get style() {
    return $e;
  }
}, [1, "loading-icon", {
  width: [1],
  height: [1]
}]);
function ue() {
  if (typeof customElements > "u")
    return;
  ["loading-icon"].forEach((e) => {
    switch (e) {
      case "loading-icon":
        customElements.get(e) || customElements.define(e, fe);
        break;
    }
  });
}
const pe = "button.sc-button-component{display:flex;align-items:center;justify-content:center;gap:0.75rem;height:48px;border:none;border-radius:var(--nylas-border-radius-2x);font-size:16px;line-height:24px;padding:0 1rem;cursor:pointer;font-family:var(--nylas-font-family);font-weight:600;width:100%}@media screen and (max-width: 768px){button.sc-button-component{width:100%}}button.button-primary.sc-button-component{background:var(--nylas-primary);color:var(--nylas-base-0);height:48px;border:none;border-radius:var(--nylas-border-radius-2x);font-size:16px;line-height:24px;padding:0 1rem;cursor:pointer}button.button-primary.sc-button-component:hover{background:var(--nylas-base-600)}button.button-primary.sc-button-component:active{background:var(--nylas-base-800)}button.button-primary.sc-button-component:disabled{background:var(--nylas-base-300);cursor:not-allowed}button.button-basic.sc-button-component{border:1px solid var(--nylas-base-300);color:var(--nylas-base-700);background:transparent}button.button-basic.sc-button-component:hover{background:transparent;border-color:var(--nylas-primary)}button.button-basic.sc-button-component:active{background:transparent;border-color:var(--nylas-base-600);border-width:2px}button.button-basic.sc-button-component:disabled{background:transparent;border-color:var(--nylas-base-300);color:var(--nylas-base-300);cursor:not-allowed}button.button-destructive.sc-button-component{border:1px solid var(--nylas-base-300);color:var(--nylas-error);background:transparent}button.button-destructive.sc-button-component:hover{background:transparent;border-color:var(--nylas-error)}button.button-destructive.sc-button-component:active{background:transparent;border-color:var(--nylas-error-pressed);border-width:2px;color:var(--nylas-error-pressed)}button.button-destructive.sc-button-component:disabled{background:transparent;border-color:var(--nylas-base-300);color:var(--nylas-base-300);cursor:not-allowed}button.button-invisible.sc-button-component{background:transparent;color:var(--nylas-base-800);border:none}button.button-invisible.sc-button-component:hover{background:var(--nylas-base-50);color:var(--nylas-primary)}button.button-invisible.sc-button-component:active{background:var(--nylas-base-50);color:var(--nylas-base-850)}button.button-invisible.sc-button-component:disabled{background:transparent;color:var(--nylas-base-300);cursor:not-allowed}", he = pe, kt = gt(class extends vt {
  constructor() {
    super(), this.__registerHost(), this.variant = "primary", this.disabled = !1, this.type = "button", this.tooltip = "", this.isLoading = !1, this.clickHandler = void 0, this.mouseOverHandler = void 0, this.mouseOutHandler = void 0, this.focusHandler = void 0, this.blurHandler = void 0;
  }
  render() {
    const e = `button-${this.variant}` + (this.disabled ? " disabled" : "");
    return k("button", { key: "c2ea933b85e63b6305793712f65cf335e7361866", class: e, disabled: this.disabled, type: "type", title: this.tooltip, onClick: this.clickHandler, onMouseOver: this.mouseOverHandler, onMouseOut: this.mouseOutHandler, onFocus: this.focusHandler, onBlur: this.blurHandler }, !!this.isLoading && k("loading-icon", { slot: "icon" }), k("slot", { key: "faa43f2d964f51c5fd83e09cebc97b6eeb1fe5ab" }));
  }
  static get style() {
    return he;
  }
}, [6, "button-component", {
  variant: [1],
  disabled: [4],
  type: [1],
  tooltip: [1],
  isLoading: [4, "is-loading"],
  clickHandler: [16],
  mouseOverHandler: [16],
  mouseOutHandler: [16],
  focusHandler: [16],
  blurHandler: [16]
}]);
function ge() {
  if (typeof customElements > "u")
    return;
  ["button-component", "loading-icon"].forEach((e) => {
    switch (e) {
      case "button-component":
        customElements.get(e) || customElements.define(e, kt);
        break;
      case "loading-icon":
        customElements.get(e) || ue();
        break;
    }
  });
}
const ve = kt, me = ge;
export {
  ve as ButtonComponent,
  me as defineCustomElement
};
