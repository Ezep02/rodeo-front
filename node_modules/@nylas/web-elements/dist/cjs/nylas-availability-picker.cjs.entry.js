'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-c14ea8f5.js');
const registerComponent = require('./register-component-27e765e0.js');
const utils = require('./utils-66843f0b.js');
const constants = require('./constants-911e8b92.js');

const nylasAvailabilityPickerCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-availability-picker{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200)}.nylas-availability-picker .header{padding:1rem}.nylas-availability-picker .header h3{margin:0;font-size:16px;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-availability-picker .header p{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left;display:flex;align-items:center;gap:4px}.nylas-availability-picker .content{padding:1rem;color:var(--nylas-base-900);font-size:16px;font-family:var(--nylas-font-family);border-top:1px solid var(--nylas-base-200)}@media screen and (max-width: 504px){.nylas-availability-picker .content{font-size:15px}}.nylas-availability-picker .content .select-timezone{display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--nylas-base-200);padding-bottom:1rem;gap:1rem}.nylas-availability-picker .content .select-timezone h4{display:flex;gap:0.5rem;align-items:center;margin:0;font-size:16px;font-weight:500;line-height:20px}@media screen and (max-width: 504px){.nylas-availability-picker .content .select-timezone h4{font-size:15px}}.nylas-availability-picker .content .availability{display:flex;flex-direction:column;gap:1rem;padding:0 0.5rem;margin:1rem 0}@media screen and (max-width: 504px){.nylas-availability-picker .content .availability{gap:0.5rem;padding:0}}.nylas-availability-picker .content .availability .availability-day{display:grid;grid-template-columns:minmax(auto, 65px) 1fr minmax(auto, 40px);gap:1rem;align-items:baseline}@media screen and (max-width: 768px){.nylas-availability-picker .content .availability .availability-day{grid-template-columns:78px 1fr auto}}@media screen and (max-width: 504px){.nylas-availability-picker .content .availability .availability-day{display:inline-grid;gap:8px;grid-template-columns:60px 1fr auto}}.nylas-availability-picker .content .availability .availability-day .day{display:flex;gap:0.5rem;align-items:center}@media screen and (max-width: 504px){.nylas-availability-picker .content .availability .availability-day .day{gap:0.25rem}}.nylas-availability-picker .content .availability .availability-day .day input[type=checkbox]{transform:scale(1.3)}.nylas-availability-picker .content .availability .availability-day .time-ranges span.unavailable{height:48px;display:flex;align-items:center;justify-content:center}.nylas-availability-picker .content .availability .availability-day .time-ranges .time-range{display:flex;gap:1.5rem;justify-content:space-between;align-items:baseline}@media screen and (max-width: 504px){.nylas-availability-picker .content .availability .availability-day .time-ranges .time-range{justify-content:unset;gap:0.5rem}}.nylas-availability-picker .content .availability .availability-day .time-ranges .time-range .pickers{display:flex;gap:1rem}@media screen and (max-width: 504px){.nylas-availability-picker .content .availability .availability-day .time-ranges .time-range .pickers{gap:0.5rem}}.nylas-availability-picker .content .availability .availability-day .time-ranges .time-range .pickers span{margin-top:0.75rem}.nylas-availability-picker .content .availability .availability-day .time-ranges .time-range:not(:last-of-type){margin-bottom:1rem}.nylas-availability-picker .content .availability .availability-day .time-ranges p.error{color:var(--nylas-error)}.nylas-availability-picker .content .availability .availability-day button{border:none;background:transparent;height:40px;cursor:pointer;color:var(--nylas-base-800)}.nylas-availability-picker .content .availability .availability-day button:hover,.nylas-availability-picker .content .availability .availability-day button:active{color:var(--nylas-primary)}select-dropdown{width:auto}select-dropdown::part(sd_dropdown-button){justify-content:initial}";

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasAvailabilityPicker = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.valueChanged = index.createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.name = 'availability';
        this.selectedConfiguration = undefined;
        this.openHours = undefined;
        this.defaultTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        this.hideHeader = false;
        this.selectedLanguage = undefined;
        this.schedule = {
            SUN: [],
            MON: [{ start: '09:00am', end: '05:00pm' }],
            TUE: [{ start: '09:00am', end: '05:00pm' }],
            WED: [{ start: '09:00am', end: '05:00pm' }],
            THU: [{ start: '09:00am', end: '05:00pm' }],
            FRI: [{ start: '09:00am', end: '05:00pm' }],
            SAT: [],
        };
        this.timezone = '';
        this.overlapDays = {};
    }
    elementNameChangedHandler(newValue) {
        utils.debug('nylas-calendar-picker', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    configChangedHandler(newConfig) {
        const defaultOpenHours = newConfig?.availability?.availability_rules?.default_open_hours ?? constants.DEFAULT_OPEN_HOURS;
        const defaultOpenHoursTimezone = newConfig?.event_booking?.timezone ?? this.defaultTimezone;
        this.timezone = this.name === 'availability' ? defaultOpenHoursTimezone : this.defaultTimezone;
        if (this.openHours) {
            this.openHoursToSchedule(this.openHours);
        }
        else if (defaultOpenHours) {
            this.openHoursToSchedule(defaultOpenHours);
        }
    }
    scheduleChanged(newValue, oldValue) {
        if (newValue !== oldValue) {
            let overlapDays = {};
            Object.keys(newValue).forEach(key => {
                const dayTimeRanges = newValue[key];
                if (dayTimeRanges.length > 0) {
                    const overlaps = this.getOverlaps(dayTimeRanges);
                    if (overlaps.length > 0) {
                        overlapDays[key] = overlaps;
                    }
                }
            });
            this.overlapDays = overlapDays;
            if (typeof this.internals.setFormValue !== 'function') {
                return;
            }
            if (Object.keys(overlapDays).length > 0) {
                const element = this.host.shadowRoot?.getElementById(Object.keys(overlapDays)[0]);
                if (element) {
                    utils.debug('nylas-availability-picker', 'The time ranges are overlapping. Overlap: ', overlapDays);
                    this.internals.setValidity({ customError: true }, 'Overlapping time ranges found', element);
                }
            }
            else {
                this.internals.setValidity({ customError: false });
                this.internals.setFormValue(JSON.stringify({
                    openHours: this.scheduleToOpenHours(this.schedule),
                    timezone: this.timezone,
                }));
            }
            this.valueChanged.emit({
                value: JSON.stringify({
                    openHours: this.scheduleToOpenHours(newValue),
                    timezone: this.timezone,
                }),
                name: this.name,
            });
        }
    }
    selectedLanguageChangedHandler(newVal, oldVal) {
        if (newVal === oldVal)
            return;
        utils.instance.changeLanguage(newVal);
    }
    nylasFormDropdownChangedHandler(event) {
        const { name, value } = event.detail;
        if (name === 'timezone') {
            this.timezone = value;
            if (typeof this.internals.setFormValue !== 'function') {
                return;
            }
            const updateValue = {
                openHours: this.scheduleToOpenHours(this.schedule),
                timezone: this.timezone,
            };
            this.internals.setFormValue(JSON.stringify(updateValue));
            this.valueChanged.emit({
                value: JSON.stringify(updateValue),
                name: this.name,
            });
        }
    }
    connectedCallback() {
        utils.debug('nylas-availability-picker', 'connectedCallback');
    }
    disconnectedCallback() {
        utils.debug('nylas-availability-picker', 'disconnectedCallback');
    }
    componentWillLoad() {
        utils.debug('nylas-availability-picker', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        utils.debug('nylas-availability-picker', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.configChangedHandler(this.selectedConfiguration);
        }
        else {
            this.timezone = this.defaultTimezone;
        }
        if (typeof this.internals.setFormValue !== 'function') {
            return;
        }
        const updateValue = {
            openHours: this.scheduleToOpenHours(this.schedule),
            timezone: this.timezone,
        };
        this.internals.setFormValue(JSON.stringify(updateValue));
        this.valueChanged.emit({
            value: JSON.stringify(updateValue),
            name: this.name,
        });
    }
    getOverlaps(timeRanges) {
        let timeRangesInMinutes = timeRanges.map((range, index) => ({
            start: utils.timeToMinutes(range.start),
            end: utils.timeToMinutes(range.end),
            originalIndex: index,
        }));
        timeRangesInMinutes.sort((a, b) => a.start - b.start);
        let overlaps = [];
        for (let i = 1; i < timeRangesInMinutes.length; i++) {
            if (timeRangesInMinutes[i].start < timeRangesInMinutes[i - 1].end) {
                if (!overlaps.includes(timeRangesInMinutes[i].originalIndex)) {
                    overlaps.push(timeRangesInMinutes[i].originalIndex);
                }
                if (!overlaps.includes(timeRangesInMinutes[i - 1].originalIndex)) {
                    overlaps.push(timeRangesInMinutes[i - 1].originalIndex);
                }
            }
        }
        return overlaps.sort((a, b) => a - b);
    }
    addTimeRange(day) {
        const currentTimeRanges = this.schedule[day];
        const dayStart = 0;
        const dayEnd = 1425;
        if (currentTimeRanges.length === 0) {
            this.schedule[day] = [{ start: '09:00am', end: '05:00pm' }];
        }
        else {
            const timeRangesInMinutes = currentTimeRanges
                .map(range => ({
                start: utils.timeToMinutes(range.start),
                end: utils.timeToMinutes(range.end),
            }))
                .sort((a, b) => a.start - b.start);
            const lastRangeEnd = timeRangesInMinutes[timeRangesInMinutes.length - 1].end;
            if (lastRangeEnd + 60 <= dayEnd) {
                this.schedule[day].push({
                    start: utils.convertTo12HourFormat(utils.minutesToTime(lastRangeEnd)),
                    end: utils.convertTo12HourFormat(utils.minutesToTime(lastRangeEnd + 60)),
                });
            }
            else {
                let gapFound = false;
                if (timeRangesInMinutes[0].start > dayStart + 60) {
                    this.schedule[day].push({
                        start: utils.convertTo12HourFormat(utils.minutesToTime(dayStart)),
                        end: utils.convertTo12HourFormat(utils.minutesToTime(dayStart + 60)),
                    });
                    gapFound = true;
                }
                if (!gapFound) {
                    for (let i = 0; i < timeRangesInMinutes.length - 1; i++) {
                        const currentEnd = timeRangesInMinutes[i].end;
                        const nextStart = timeRangesInMinutes[i + 1].start;
                        if (nextStart - currentEnd >= 60) {
                            this.schedule[day].push({
                                start: utils.convertTo12HourFormat(utils.minutesToTime(currentEnd)),
                                end: utils.convertTo12HourFormat(utils.minutesToTime(currentEnd + 60)),
                            });
                            break;
                        }
                    }
                }
            }
        }
        this.schedule[day].sort((a, b) => utils.timeToMinutes(a.start) - utils.timeToMinutes(b.start));
        this.schedule = { ...this.schedule };
    }
    removeTimeRange(day, index) {
        this.schedule[day].splice(index, 1);
        this.schedule = { ...this.schedule };
    }
    setTime(event) {
        const { key, value } = event.detail;
        const [dayIndex, timeType] = key.split('_');
        const [day, index] = dayIndex.split(':');
        if (timeType === 'start') {
            this.schedule[day][index].start = value;
        }
        else if (timeType === 'end') {
            this.schedule[day][index].end = value;
        }
        this.internals.setValidity({ customError: false });
        this.schedule = { ...this.schedule };
    }
    setFormError(event) {
        const { key } = event.detail;
        const [_, timeType] = key.split('_');
        const element = this.host.shadowRoot?.getElementById(key);
        if (element) {
            this.internals.setValidity({ customError: true }, `Invalid ${timeType} time`, element);
        }
    }
    openHoursToSchedule(openHours) {
        const newSchedule = {
            SUN: [],
            MON: [],
            TUE: [],
            WED: [],
            THU: [],
            FRI: [],
            SAT: [],
        };
        openHours.forEach(openHour => {
            openHour.days.forEach(day => {
                const dayKey = this.getDayKey(day);
                const start12hr = utils.convertTo12HourFormat(openHour.start);
                const end12hr = utils.convertTo12HourFormat(openHour.end);
                const timeRange = { start: start12hr, end: end12hr };
                let timeRangeExists = false;
                if (newSchedule[dayKey]) {
                    timeRangeExists = newSchedule[dayKey].some(range => range.start === timeRange.start && range.end === timeRange.end);
                }
                if (!timeRangeExists) {
                    if (newSchedule[dayKey]) {
                        newSchedule[dayKey].push(timeRange);
                    }
                    else {
                        newSchedule[dayKey] = [timeRange];
                    }
                }
            });
        });
        this.schedule = newSchedule;
    }
    getDayKey(dayIndex) {
        const days = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
        return days[dayIndex];
    }
    scheduleToOpenHours(schedule) {
        const dayKeys = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
        let openHoursMap = new Map();
        dayKeys.forEach((dayKey, index) => {
            if (schedule[dayKey]) {
                schedule[dayKey].forEach(timeRange => {
                    const start24hr = utils.convertTo24HourFormat(timeRange.start);
                    const end24hr = utils.convertTo24HourFormat(timeRange.end);
                    const key = `${start24hr}-${end24hr}`;
                    if (!openHoursMap.has(key)) {
                        openHoursMap.set(key, { days: [index], start: start24hr, end: end24hr });
                    }
                    else {
                        let entry = openHoursMap.get(key);
                        if (entry) {
                            entry.days.push(index);
                            openHoursMap.set(key, entry);
                        }
                    }
                });
            }
        });
        let selectedOpenHours = [];
        openHoursMap.forEach((value, _key) => {
            selectedOpenHours.push({
                days: value.days,
                start: value.start,
                end: value.end,
                timezone: this.timezone,
            });
        });
        return selectedOpenHours;
    }
    render() {
        const timezoneOptions = Object.keys(constants.TIMEZONE_MAP).map(key => ({
            label: constants.TIMEZONE_MAP[key],
            value: key,
        }));
        const selectedTimezoneOption = timezoneOptions.find(i => i.value === this.timezone);
        return (index.h(index.Host, { key: '7f5643bbe1297934343819e75a79ddc058e01f5b' }, index.h("div", { key: '53d182ac0115d273cc3cc15e81a52a488b8d9e52', class: "nylas-availability-picker", part: "nap" }, !this.hideHeader && (index.h("div", { class: "header", part: "nap__header" }, index.h("h3", null, utils.instance.t('nylasAvailabilityPicker.headerTitle')), index.h("p", null, utils.instance.t('nylasAvailabilityPicker.headerSubTitle'), index.h("tooltip-component", null, index.h("info-icon", { slot: "tooltip-icon" }), index.h("span", { slot: "tooltip-content" }, utils.instance.t('nylasAvailabilityPicker.tooltip.desc')))))), index.h("div", { key: '2818430114319c8993ade1da8be4c8e04754283d', class: "content" }, index.h("div", { key: '459c8d97a9ab00f2ffb1fe38121f2652b6b06b02', class: "select-timezone", part: "nap__select-timezone" }, index.h("h4", { key: '5d13b9bf3f44da8097d24b33b37c155500ba9a3c', class: "sub-header" }, utils.instance.t('nylasAvailabilityPicker.selectTimezone')), selectedTimezoneOption?.label && (index.h("select-dropdown", { name: "timezone", exportparts: "sd_dropdown: nap__timezone-container, sd_dropdown-button: nap__timezone-button, sd_dropdown-content: nap__timezone-dropdown-content", options: timezoneOptions, defaultSelectedOption: selectedTimezoneOption }, index.h("span", { slot: "select-icon" }, index.h("globe-icon", { width: "20", height: "20" }))))), index.h("div", { key: '055c9ad67845135ba63be4a2f3aa6b3e5f4d2469', class: "availability", part: "nap__availability" }, Object.keys(this.schedule).map(key => {
            const day = key;
            const timeRanges = this.schedule[key];
            return (index.h("div", { class: "availability-day" }, index.h("div", { class: "day", part: "nap__day" }, index.h("input", { type: "checkbox", name: day, id: day, checked: timeRanges.length > 0, onClick: () => {
                    if (timeRanges.length > 0) {
                        this.schedule[day] = [];
                    }
                    else {
                        this.schedule[day] = [{ start: '09:00am', end: '05:00pm' }];
                    }
                    this.schedule = { ...this.schedule };
                } }), index.h("label", { htmlFor: day, "aria-label": "Select day" }, utils.instance.t(`nylasAvailabilityPicker.days.${day}`))), index.h("div", { class: "time-ranges", part: "nap__time-ranges" }, timeRanges.length ? null : index.h("span", { class: "unavailable" }, utils.instance.t('nylasAvailabilityPicker.unavailable')), timeRanges.length > 0 &&
                timeRanges.map((timeRange, timeRangeIndex) => {
                    const startKey = `${key}:${timeRangeIndex}_start`;
                    const endKey = `${key}:${timeRangeIndex}_end`;
                    return (index.h("div", { class: "time-range", part: "nap__time-range" }, index.h("div", { class: "pickers" }, index.h("nylas-time-window-picker", { id: startKey, hasError: this.overlapDays[day]?.includes(timeRangeIndex), time: timeRange.start, name: startKey, key: startKey, exportparts: "time-picker: nap__time-picker-container, time-input: nap__time-picker-input, times: nap__time-picker-times" }), index.h("span", null, " - "), index.h("nylas-time-window-picker", { id: endKey, hasError: this.overlapDays[day]?.includes(timeRangeIndex), time: timeRange.end, name: endKey, key: endKey, minimumStartTime: timeRange.start, exportparts: "time-picker: nap__time-picker-container, time-input: nap__time-picker-input, times: nap__time-picker-times" })), index.h("button", { onClick: () => this.removeTimeRange(day, timeRangeIndex) }, index.h("close-icon", null))));
                }), index.h("p", { class: "error" }, this.overlapDays[day] ? 'Overlapping time ranges' : '')), index.h("div", null, timeRanges.length > 0 ? (index.h("button", { onClick: () => this.addTimeRange(day), part: "nap__add-time-range" }, index.h("add-circle-icon", null))) : null)));
        }))))));
    }
    static get formAssociated() { return true; }
    get host() { return index.getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["configChangedHandler"],
        "schedule": ["scheduleChanged"],
        "selectedLanguage": ["selectedLanguageChangedHandler"]
    }; }
};
__decorate([
    registerComponent.RegisterComponent({
        name: 'nylas-availability-picker',
        stateToProps: new Map([
            ['schedulerConfig.selectedConfiguration', 'selectedConfiguration'],
            ['schedulerConfig.selectedLanguage', 'selectedLanguage'],
        ]),
        fireRegisterEvent: true,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NylasAvailabilityPicker.prototype, "render", null);
NylasAvailabilityPicker.style = nylasAvailabilityPickerCss;

exports.nylas_availability_picker = NylasAvailabilityPicker;

//# sourceMappingURL=nylas-availability-picker.cjs.entry.js.map