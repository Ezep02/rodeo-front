import { RouterInterface } from "../../routers/router-interface";
import { NylasAuthStoreType } from "../../stores/auth-store";
import { NylasSchedulerConfigStoreType } from "../../stores/scheduler-config-store";
import { NylasSchedulerStoreType } from "../../stores/scheduler-store";
import type { NylasAuthType } from '@nylas/core';
import { NylasConnectorInterface } from '../connector-interface';
import { NylasAuthConnector } from '../shared/api/auth';
import { NylaSchedulerAPIConnector } from '../shared/api/scheduler';
export declare class NylasConnector implements NylasConnectorInterface {
    router: RouterInterface;
    nylasAuth: NylasAuthType;
    nylasAuthStore: NylasAuthStoreType;
    nylasSchedulerStore: NylasSchedulerStoreType;
    nylasSchedulerConfigStore: NylasSchedulerConfigStoreType;
    schedulerAPIURL: string;
    private _authConnector;
    private _schedulerAPIConnector;
    constructor(router: RouterInterface, nylasAuth: NylasAuthType, nylasAuthStore: NylasAuthStoreType, nylasSchedulerStore: NylasSchedulerStoreType, nylasSchedulerConfigStore: NylasSchedulerConfigStoreType, schedulerAPIURL?: string);
    init(): void;
    get authStore(): import("@stencil/store").ObservableMap<import("@/stores/auth-store").NylasAuthStoreState>;
    get schedulerStore(): import("@stencil/store").ObservableMap<import("@/stores/scheduler-store").NylasSchedulerStoreState>;
    get schedulerConfigStore(): import("@/stores/scheduler-config-store").CreateNylasSchedulerConfigStoreReturnType;
    get auth(): NylasAuthConnector;
    get scheduler(): NylaSchedulerAPIConnector;
    getAuth(): {
        config: import("@nylas/core").AuthConfig;
        getHostedAuthRedirectURL(scopes?: string[] | undefined, email?: string | undefined, provider?: string | undefined): Promise<string>;
        nylasAPIRequest: {
            <T>(path: string, method?: string | undefined, body?: any, parseJSON?: boolean | undefined, domain?: string | undefined, request?: RequestInit | undefined): Promise<T>;
            <T_1>(path: string, method: string, body: any, parseJSON: false, domain?: string | undefined, request?: RequestInit | undefined): Promise<ReadableStream<Uint8Array> | null>;
            <T_2>(path: string, method: string, body: any, parseJSON: true, domain?: string | undefined, request?: RequestInit | undefined): Promise<T_2>;
            <T_3>(path: string, method: string, body: any, parseJSON: boolean, domain?: string | undefined, request?: RequestInit | undefined): Promise<ReadableStream<Uint8Array> | T_3 | null>;
        };
        exchangeAuthCodeForTokenInfo(code: string): Promise<import("@nylas/core").TokenExchangeResponse | null>;
        nylasDownloadFileRequest(path: string, method?: string | undefined, body?: any): Promise<Blob>;
        logout(): Promise<void>;
        isAuthenticated(): Promise<boolean>;
        getTokenInfo(): Promise<import("@nylas/core/dist/auth").TokenInfo | null>;
        isAccessTokenValid(): Promise<boolean>;
        refreshAccessToken(): Promise<import("@nylas/core").TokenExchangeResponse | null>;
        hasScopeByType(service: "email" | undefined, types: string | string[]): Promise<boolean>;
        hasScope(scope: string | string[]): Promise<boolean>;
    };
    resetStores(): void;
    logout(): Promise<void>;
}
export type PublicMethods<T> = {
    [K in keyof T]: T[K] extends Function ? (string extends K ? never : K) : never;
}[keyof T];
export type NylasConnectorPublicMethods = PublicMethods<NylasConnector>;
