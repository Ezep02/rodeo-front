{"file":"nylas-provider.entry.js","mappings":"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","names":["NylasAuth"],"sources":["src/connector/shared/api/auth.ts","src/connector/nylas-connector/index.ts","src/routers/hash-router.ts","src/stores/auth-store.ts","src/components/nylas-provider/nylas-provider.css?tag=nylas-provider&encapsulation=shadow","src/components/nylas-provider/nylas-provider.tsx"],"sourcesContent":["import { debug } from '@/utils/utils';\nimport { NylasAuthStoreType, NylasAuthType } from '../../..';\nimport { TokenInfo } from '@nylas/core/lib/auth';\nexport class NylasAuthConnector {\n  private nylasAuth: NylasAuthType;\n  private nylasAuthStore: NylasAuthStoreType;\n\n  constructor(nylasAuth: NylasAuthType, nylasAuthStore: NylasAuthStoreType) {\n    this.nylasAuth = nylasAuth;\n    this.nylasAuthStore = nylasAuthStore;\n  }\n\n  /**\n   * Validates the current session and updates the store with the token info\n   * if the user is authenticated.\n   * If the user is not authenticated, the store is reset.\n   * @returns {Promise<void>}\n   */\n  public async validateSession(): Promise<void> {\n    const isAuthenticated = await this.isAccessTokenValid();\n    if (!isAuthenticated) {\n      // Reset the store if the access token is not valid\n      this.logout();\n    } else {\n      // If the user is authenticated, update the store with the token info\n      let tokenInfo = await this.nylasAuth.getTokenInfo();\n      if (tokenInfo) {\n        // If token is expired or about to expire (in 5 minutes), refresh it\n        const expireTimeCheck = 5 * 60 * 1000; // 5 minutes\n        const currentTimeInSeconds = Math.floor(Date.now() / 1000);\n\n        if (tokenInfo.expires_in && tokenInfo.expires_in - currentTimeInSeconds < expireTimeCheck) {\n          debug('[NylasAuthConnectorMixin] Refreshing access token');\n          tokenInfo = await this.nylasAuth.refreshAccessToken();\n          if (!tokenInfo) {\n            debug('[NylasAuthConnectorMixin] Token is expired and could not be refreshed. Logging out.');\n            this.logout();\n            return;\n          }\n        }\n\n        this.nylasAuthStore.state.tokenInfo = tokenInfo;\n      }\n    }\n    this.nylasAuthStore.state.isAuthenticated = isAuthenticated;\n  }\n\n  /**\n   * Returns true if the user is authenticated.\n   * @returns {Promise<boolean>}\n   */\n  public async isAuthenticated(): Promise<boolean> {\n    return this.nylasAuth.isAuthenticated();\n  }\n\n  /**\n   * Returns the token info if the user is authenticated.\n   * @returns {Promise<TokenInfo>}\n   */\n  public async getTokenInfo(): Promise<TokenInfo | null> {\n    return this.nylasAuth.getTokenInfo();\n  }\n\n  /**\n   * Returns true if the access token is valid.\n   * @returns {Promise<boolean>}\n   */\n  public async isAccessTokenValid(): Promise<boolean> {\n    return this.nylasAuth.isAccessTokenValid();\n  }\n\n  /**\n   * Removes the token info from the store and logs the user out.\n   * @returns {Promise<void>}\n   */\n  public async logout(): Promise<void> {\n    await this.nylasAuth.logout();\n  }\n\n  /**\n   * Returns the URL to redirect the user to for authentication.\n   * @param scopes An array of scopes to request from the user.\n   * @param email The email address of the user to authenticate.\n   * @param provider The provider to use for authentication.\n   * @returns {Promise<string>}\n   */\n  public async getHostedAuthRedirectURL(scopes?: string[], email?: string, provider?: string): Promise<string> {\n    return this.nylasAuth.getHostedAuthRedirectURL(scopes, email, provider);\n  }\n\n  /**\n   * Exchanges the auth code for a token info and updates the store.\n   * @param currentUrl The current URL of the page.\n   * @returns {Promise<TokenInfo | null>}\n   */\n  public async manageHostedAuthCodeExchange(currentUrl: string): Promise<TokenInfo | null> {\n    const url = new URL(currentUrl);\n    const code = url.searchParams.get('code');\n\n    if (code) {\n      const tokenInfo = await this.nylasAuth.exchangeAuthCodeForTokenInfo(code);\n      if (tokenInfo) {\n        this.nylasAuthStore.state.tokenInfo = tokenInfo;\n        this.nylasAuthStore.state.isAuthenticated = true;\n        return tokenInfo;\n      }\n    }\n\n    return null;\n  }\n}\n","import { RouterInterface } from '@/routers/router-interface';\nimport { NylasAuthStoreType } from '@/stores/auth-store';\nimport { NylasSchedulerConfigStoreType } from '@/stores/scheduler-config-store';\nimport { NylasSchedulerStoreType } from '@/stores/scheduler-store';\nimport { debug } from '@/utils/utils';\nimport type { NylasAuthType } from '@nylas/core';\nimport { NylasConnectorInterface } from '../connector-interface';\nimport { NylasAuthConnector } from '../shared/api/auth';\nimport { NylaSchedulerAPIConnector } from '../shared/api/scheduler';\n/**\n * Base class for the Nylas connector.\n */\nexport class NylasConnector implements NylasConnectorInterface {\n  public router: RouterInterface;\n  public nylasAuth: NylasAuthType;\n  public nylasAuthStore: NylasAuthStoreType;\n  public nylasSchedulerStore: NylasSchedulerStoreType;\n  public nylasSchedulerConfigStore: NylasSchedulerConfigStoreType;\n  public schedulerAPIURL: string;\n\n  private _authConnector: NylasAuthConnector | undefined;\n  private _schedulerAPIConnector: NylaSchedulerAPIConnector | undefined;\n\n  constructor(\n    router: RouterInterface,\n    nylasAuth: NylasAuthType,\n    nylasAuthStore: NylasAuthStoreType,\n    nylasSchedulerStore: NylasSchedulerStoreType,\n    nylasSchedulerConfigStore: NylasSchedulerConfigStoreType,\n    schedulerAPIURL: string = 'https://api.us.nylas.com',\n  ) {\n    this.router = router;\n    this.schedulerAPIURL = schedulerAPIURL;\n    this.nylasAuth = nylasAuth;\n    this.nylasAuthStore = nylasAuthStore;\n    this.nylasSchedulerStore = nylasSchedulerStore;\n    this.nylasSchedulerConfigStore = nylasSchedulerConfigStore;\n  }\n\n  public init() {\n    debug('NylasConnector init');\n  }\n\n  public get authStore() {\n    return this.nylasAuthStore;\n  }\n\n  public get schedulerStore() {\n    return this.nylasSchedulerStore;\n  }\n\n  public get schedulerConfigStore() {\n    return this.nylasSchedulerConfigStore;\n  }\n\n  public get auth() {\n    if (this._authConnector) {\n      return this._authConnector;\n    }\n    this._authConnector = new NylasAuthConnector(this.nylasAuth, this.nylasAuthStore);\n    return this._authConnector;\n  }\n\n  public get scheduler() {\n    if (this._schedulerAPIConnector) {\n      return this._schedulerAPIConnector;\n    }\n    this._schedulerAPIConnector = new NylaSchedulerAPIConnector({\n      schedulerAPIURL: this.schedulerAPIURL,\n      schedulerStore: this.schedulerStore,\n    });\n    return this._schedulerAPIConnector;\n  }\n\n  public getAuth() {\n    return this.nylasAuth;\n  }\n\n  public resetStores() {\n    this.nylasAuthStore.reset();\n  }\n\n  public async logout() {\n    await this.nylasAuth.logout();\n    this.resetStores();\n  }\n}\n\nexport type PublicMethods<T> = {\n  [K in keyof T]: T[K] extends Function ? (string extends K ? never : K) : never;\n}[keyof T];\n\nexport type NylasConnectorPublicMethods = PublicMethods<NylasConnector>;\n","import { debug } from '@/utils/utils';\nimport { RouteListener, RouteParams, RoutePath, RouterInterface } from './router-interface';\n\nexport class PolyFillHashChangeEvent extends Event {\n  oldURL?: string;\n  newURL?: string;\n\n  constructor(type: string, eventInitDict: HashChangeEventInit) {\n    super(type, eventInitDict);\n    this.oldURL = eventInitDict.oldURL;\n    this.newURL = eventInitDict.newURL;\n  }\n}\n\nexport class HashRouter implements RouterInterface {\n  private routeChangeListeners: [route: RoutePath, RouteListener<any>][] = [];\n\n  constructor() {\n    debug('HashRouter constructor');\n  }\n\n  // Destroy the router\n  public destroy(): void {\n    debug('HashRouter destroy');\n    window.removeEventListener('hashchange', this.onRouteChange.bind(this));\n  }\n\n  // Initialize the router\n  public init(): void {\n    debug('HashRouter init');\n    window.addEventListener('hashchange', this.onRouteChange.bind(this));\n\n    // Trigger the initial route change\n    if (typeof HashChangeEvent !== 'undefined') {\n      const event: HashChangeEvent = new HashChangeEvent('hashchange', { oldURL: '', newURL: window.location.href });\n      this.onRouteChange(event);\n    } else {\n      const event: Event = new PolyFillHashChangeEvent('hashchange', { oldURL: '', newURL: window.location.href });\n      this.onRouteChange(event as HashChangeEvent);\n    }\n  }\n\n  public addRouteChangeListener<Path extends RoutePath>(route: Path, listener: RouteListener<Path>): void {\n    debug('HashRouter addRouteChangeListener');\n    this.routeChangeListeners.push([route, listener]);\n  }\n\n  public navigate(route: string, shallow: boolean): void {\n    debug('HashRouter navigate');\n\n    // If we're navigating shallow, don't add a new history entry\n    if (shallow) {\n      return window.history.pushState(null, '', `#${route}`);\n    }\n\n    window.location.hash = route;\n  }\n\n  public setRoute(route: string): void {\n    debug('HashRouter setRoute');\n    window.location.hash = route;\n  }\n\n  // Matches a route and executes the callback\n  public matchRoute(route: string, path: string): boolean {\n    const routeParts = route.split('/');\n    const pathParts = path.split('/');\n\n    // If the route is `/` an the hash is empty, match the route\n    debug(`HashRouter matchRoute route=${route} path=${path}`, { routeParts, pathParts });\n    if (routeParts[1] === '' && pathParts[0] === '') {\n      return true;\n    }\n\n    if (routeParts.length !== pathParts.length) {\n      return false;\n    }\n\n    for (let i = 0; i < routeParts.length; i++) {\n      const routePart = routeParts[i];\n      const pathPart = pathParts[i];\n      if (routePart.startsWith(':')) {\n        continue;\n      }\n      if (routePart !== pathPart) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Parse the route and return the route params\n  public getRouteParams<Path extends RoutePath>(route: Path): RouteParams<Path> {\n    debug('HashRouter getRouteParams');\n    const routeParams: RouteParams<Path> = {} as RouteParams<Path>;\n    const routeParts = route.split('/');\n    const routeConfigParts = window.location.hash.split('/');\n    routeParts.forEach((routePart, index) => {\n      if (routePart.startsWith(':')) {\n        const key = routePart.substring(1) as keyof RouteParams<Path>;\n        routeParams[key] = routeConfigParts[index] as RouteParams<Path>[keyof RouteParams<Path>]; // Cast the value to string\n      }\n    });\n    return routeParams;\n  }\n\n  public getRouteWithParams(route: string, routeParams: Record<string, any>): string {\n    debug('HashRouter getRouteWithParams');\n    let routeWithParams = route;\n    Object.keys(routeParams).forEach(key => {\n      routeWithParams = routeWithParams.replace(`:${key}`, routeParams[key]);\n    });\n    return routeWithParams;\n  }\n\n  public getRoute(): string {\n    debug('HashRouter getRoute');\n    return window.location.hash;\n  }\n\n  public onRouteChange(event: HashChangeEvent): void {\n    this.routeChangeListeners.forEach(async ([route, listener]) => {\n      const path = event.newURL.indexOf('#') === -1 ? '' : event.newURL.substring(event.newURL.indexOf('#') + 1);\n      debug(`HashRouter onRouteChange route=${route} path=${path}`, { event });\n      if (!this.matchRoute(route, path)) {\n        debug(`HashRouter onRouteChange route=${route} path=${path} does not match`);\n        return;\n      }\n      const routeParams = this.getRouteParams(route) as RouteParams<RoutePath>;\n      await listener(route, path, routeParams);\n    });\n  }\n\n  public getBasePath(): string {\n    debug('HashRouter getBasePath');\n    return '';\n  }\n}\n","import { TokenInfo } from '@nylas/core/dist/auth';\nimport { createStore } from '@stencil/store';\nimport { DataState } from '@/common/types';\n\nexport interface NylasAuthStoreState {\n  isAuthenticated: boolean;\n  tokenInfo: TokenInfo | null;\n  state: DataState;\n}\n\nexport type NylasAuthStoreType = ReturnType<typeof CreateNylasAuthStore>;\n\nexport function CreateNylasAuthStore(defaultState: Partial<NylasAuthStoreState> = {}) {\n  const defaultNylasStoreState: NylasAuthStoreState = {\n    isAuthenticated: false,\n    tokenInfo: null,\n    state: 'ready',\n    ...defaultState,\n  };\n  const store = createStore<NylasAuthStoreState>(defaultNylasStoreState);\n\n  /**\n   * Reset the Nylas store to its default state.\n   * There is something wrong with the stencil/store reset method,\n   * so we have to do it via this hack.\n   */\n  store.reset = () => {\n    for (const key in defaultNylasStoreState) {\n      const value = defaultNylasStoreState[key as keyof typeof defaultNylasStoreState];\n      store.set(key as any, value);\n    }\n  };\n\n  return store;\n}\n",":host {\n  display: contents;\n}\n","import { NylasBaseProvider } from '@/common/abstract-provider';\nimport { RegisteredComponent } from '@/common/register-component';\nimport { NylasConnector } from '@/connector/nylas-connector';\nimport { HashRouter } from '@/routers/hash-router';\nimport { CreateNylasAuthStore, NylasAuthStoreType } from '@/stores/auth-store';\nimport { CreateNylasSchedulerStore, NylasSchedulerStoreType } from '@/stores/scheduler-store';\nimport type { AuthConfig, NylasAuthType } from '@nylas/core';\nimport { NylasAuth } from '@nylas/core';\nimport { Component, Element, Event, EventEmitter, Host, Listen, Method, Prop, h } from '@stencil/core';\nimport type { EventOverride } from '@/common/component-types';\nimport { debug } from '@/utils/utils';\nimport { CreateNylasSchedulerConfigStore, NylasSchedulerConfigStoreType } from '@/stores/scheduler-config-store';\n\n/**\n * The Nylas Provider component.\n * This component is used to manage the Nylas Provider.\n * It is used to manage the Nylas Auth instance, the Nylas Connector instance,\n * and the Nylas Store instance.\n */\n@Component({\n  tag: 'nylas-provider',\n  styleUrl: 'nylas-provider.css',\n  shadow: true,\n})\nexport class NylasProvider {\n  /**\n   * Stores to be used by the provider.\n   */\n  private stores?: {\n    auth: NylasAuthStoreType;\n    scheduler: NylasSchedulerStoreType;\n    schedulerConfig: NylasSchedulerConfigStoreType;\n  };\n\n  /**\n   * This is a base provide that defines the common methods and properties\n   * that all providers should have.\n   *\n   * Because stencil does not support abstract classes, we have to use a\n   * property to store the base provider instance.\n   */\n  private baseProvider?: NylasBaseProvider<Exclude<typeof this.stores, undefined>>;\n\n  /**\n   * The Nylas Auth instance.\n   * Used to manage all things authentication with Nylas.\n   */\n  private nylasAuth?: NylasAuthType;\n\n  /**\n   * The Nylas Mailbox Connector instance.\n   * The branins of the provider. It manages data fetching and state synchronization.\n   */\n  private nylasConnector?: NylasConnector;\n\n  /**\n   * The host element.\n   * Used to manage the host element of the provider.\n   */\n  @Element() private host!: HTMLNylasProviderElement;\n\n  /**\n   * The Nylas Auth configuration.\n   * Used to manage all things authentication with Nylas.\n   */\n  @Prop({ attribute: 'auth-config' }) readonly authConfig?: AuthConfig;\n\n  /**\n   * This provides a way to override the default event handlers.\n   */\n  @Prop() eventOverrides: EventOverride<Exclude<typeof this.nylasConnector, undefined>> = {};\n\n  /**\n   * Automatically register components that have the `@RegisterComponent` decorator.\n   * If this is set to false, you will need to manually register components using the\n   * `registerComponent` method.\n   * @default true\n   */\n  @Prop() automaticComponentRegistration: boolean = true;\n\n  /**\n   * This event is fired when the provider is initialized.\n   * It can be used to set the initial state of the provider,\n   * or to prevent the provider from firing some default behavior.\n   */\n  @Event({ cancelable: true }) init!: EventEmitter<HTMLNylasProviderElement>;\n\n  /**\n   * This event is fired when the the NyalsAuth isAuthenticated state changes\n   * to true.\n   */\n  @Event({ cancelable: true }) loggedIn!: EventEmitter<HTMLNylasProviderElement>;\n\n  /**\n   * This event is fired when the the NyalsAuth isAuthenticated state changes\n   * to true.\n   */\n  @Event({ cancelable: true }) loggedOut!: EventEmitter<HTMLNylasProviderElement>;\n\n  connectedCallback() {\n    debug('[nylas-provider] connectedCallback');\n  }\n\n  async componentWillLoad() {\n    debug('[nylas-provider] componentWillLoad');\n\n    this.stores = {\n      auth: CreateNylasAuthStore(),\n      scheduler: CreateNylasSchedulerStore(),\n      schedulerConfig: CreateNylasSchedulerConfigStore(),\n    };\n    this.baseProvider = new NylasBaseProvider(this.host, this.stores, this.automaticComponentRegistration, this.eventOverrides);\n\n    const router = new HashRouter();\n\n    /**\n     * Create the NylasAuth instance.\n     * This is used to manage all things authentication with Nylas.\n     */\n    this.nylasAuth = NylasAuth({\n      apiUri: 'https://api.us.nylas.com',\n      elementsApiUri: 'https://elements.us.nylas.com',\n      storageType: 'indexeddb',\n      clientId: 'YOUR_CLIENT_ID',\n      defaultScopes: [],\n      redirectURI: '/',\n      ...this.authConfig,\n    });\n\n    const nylasAuthStore = this.baseProvider?.getStore('auth');\n    if (!nylasAuthStore) {\n      throw new Error('The auth store is not set');\n    }\n\n    const nylasSchedulerStore = this.baseProvider?.getStore('scheduler');\n    if (!nylasSchedulerStore) {\n      throw new Error('The scheduler store is not set');\n    }\n\n    const nylasSchedulerConfigStore = this.baseProvider?.getStore('schedulerConfig');\n    if (!nylasSchedulerConfigStore) {\n      throw new Error('The scheduler config store is not set');\n    }\n\n    this.nylasConnector = new NylasConnector(router, this.nylasAuth, nylasAuthStore, nylasSchedulerStore, nylasSchedulerConfigStore);\n\n    const initEvent = this.init.emit(this.host);\n    if (!initEvent.defaultPrevented) {\n      /**\n       * By default, on init, we will validate the session.\n       * This will check if the user is logged in and if the session is still valid.\n       * If the session is not valid, the user will be logged out.\n       */\n      await this.nylasConnector?.auth.validateSession();\n    }\n\n    /**\n     * Listen for changes in the NylasAuth isAuthenticated state.\n     * This is used to fire the loggedIn and loggedOut events.\n     */\n    this.handleAuthChange(nylasAuthStore.state.isAuthenticated);\n\n    this.baseProvider?.componentWillLoad(this.nylasConnector);\n  }\n\n  componentDidLoad() {\n    const nylasAuthStore = this.baseProvider?.getStore('auth');\n    nylasAuthStore?.onChange('isAuthenticated', this.handleAuthChange);\n\n    this.baseProvider?.componentDidLoad();\n  }\n\n  componentDisconnected() {\n    this.baseProvider?.componentDisconnected();\n  }\n\n  /**\n   * This is a custom event handler that is used to register a component with the provider.\n   * It is used by components that have the `@RegisterComponent` decorator.\n   * @param event A custom event that contains the component to register\n   * @returns Promise<void>\n   */\n  @Listen('registerComponent')\n  async registerComponentHandler(event: CustomEvent<RegisteredComponent<any, any>>): Promise<void> {\n    this.baseProvider?.registerComponent(event.detail);\n  }\n\n  /**\n   * This is a custom event handler that is used to unregister a component with the provider.\n   * It is used by components that have the `@RegisterComponent` decorator.\n   * @param event A custom event that contains the component to unregister\n   * @returns Promise<void>\n   */\n  @Listen('unregisterComponent')\n  async unregisterComponentHandler(event: CustomEvent<RegisteredComponent<any, any>>): Promise<void> {\n    this.baseProvider?.unregisterComponent(event.detail);\n  }\n\n  /**\n   * This method is used to handle changes in the NylasAuth isAuthenticated state\n   * @param isAuthenticated isAuthenticated state\n   * @returns void\n   */\n  private handleAuthChange = async (isAuthenticated: boolean) => {\n    if (isAuthenticated) {\n      this.loggedIn.emit(this.host);\n    } else {\n      this.loggedOut.emit(this.host);\n    }\n  };\n\n  /**\n   * This method is used to retrieve the NylasAuth instance\n   * @returns The NylasAuth instance\n   */\n  @Method()\n  async getNylasAuth(): Promise<NylasAuthType | undefined> {\n    return this.nylasAuth;\n  }\n\n  /**\n   * This method is used to retrieve the NylasConnector instance\n   * @returns The NylasConnector instance\n   */\n  @Method()\n  async getNylasConnector() {\n    return this.nylasConnector;\n  }\n\n  /**\n   * This method is used to retrieve the authStore instance\n   * @returns The authStore instance\n   */\n  @Method()\n  async getAuthStore(): Promise<NylasAuthStoreType | undefined> {\n    return this.baseProvider?.getStore('auth');\n  }\n\n  /**\n   * This method is used to retrieve the NylasScheduler instance\n   * @returns The NylasScheduler instance\n   */\n  @Method()\n  async getNylasSchedulerStore(): Promise<NylasSchedulerStoreType | undefined> {\n    return this.baseProvider?.getStore('scheduler');\n  }\n\n  /**\n   * This method is used to retrieve the NylasSchedulerConfig instance\n   * @returns The NylasSchedulerConfig instance\n   */\n  @Method()\n  async getNylasSchedulerConfigStore(): Promise<NylasSchedulerConfigStoreType | undefined> {\n    return this.baseProvider?.getStore('schedulerConfig');\n  }\n\n  render() {\n    return (\n      <Host>\n        <slot></slot>\n      </Host>\n    );\n  }\n}\n"],"version":3}