import { r as registerInstance, a as createEvent, h, i as Host, e as getElement } from './index-b5cb18eb.js';
import { N as NylasBaseProvider, e as es } from './index.es-b93db048.js';
import { a as debug } from './utils-14cfef23.js';
import { N as NylaSchedulerAPIConnector, C as CreateNylasSchedulerStore } from './scheduler-store-38a2b97c.js';
import { c as createStore } from './index-a605bc0f.js';
import { C as CreateNylasSchedulerConfigStore } from './scheduler-config-store-389cb1df.js';

class NylasAuthConnector {
    constructor(nylasAuth, nylasAuthStore) {
        this.nylasAuth = nylasAuth;
        this.nylasAuthStore = nylasAuthStore;
    }
    async validateSession() {
        const isAuthenticated = await this.isAccessTokenValid();
        if (!isAuthenticated) {
            this.logout();
        }
        else {
            let tokenInfo = await this.nylasAuth.getTokenInfo();
            if (tokenInfo) {
                const expireTimeCheck = 5 * 60 * 1000;
                const currentTimeInSeconds = Math.floor(Date.now() / 1000);
                if (tokenInfo.expires_in && tokenInfo.expires_in - currentTimeInSeconds < expireTimeCheck) {
                    debug('[NylasAuthConnectorMixin] Refreshing access token');
                    tokenInfo = await this.nylasAuth.refreshAccessToken();
                    if (!tokenInfo) {
                        debug('[NylasAuthConnectorMixin] Token is expired and could not be refreshed. Logging out.');
                        this.logout();
                        return;
                    }
                }
                this.nylasAuthStore.state.tokenInfo = tokenInfo;
            }
        }
        this.nylasAuthStore.state.isAuthenticated = isAuthenticated;
    }
    async isAuthenticated() {
        return this.nylasAuth.isAuthenticated();
    }
    async getTokenInfo() {
        return this.nylasAuth.getTokenInfo();
    }
    async isAccessTokenValid() {
        return this.nylasAuth.isAccessTokenValid();
    }
    async logout() {
        await this.nylasAuth.logout();
    }
    async getHostedAuthRedirectURL(scopes, email, provider) {
        return this.nylasAuth.getHostedAuthRedirectURL(scopes, email, provider);
    }
    async manageHostedAuthCodeExchange(currentUrl) {
        const url = new URL(currentUrl);
        const code = url.searchParams.get('code');
        if (code) {
            const tokenInfo = await this.nylasAuth.exchangeAuthCodeForTokenInfo(code);
            if (tokenInfo) {
                this.nylasAuthStore.state.tokenInfo = tokenInfo;
                this.nylasAuthStore.state.isAuthenticated = true;
                return tokenInfo;
            }
        }
        return null;
    }
}

class NylasConnector {
    constructor(router, nylasAuth, nylasAuthStore, nylasSchedulerStore, nylasSchedulerConfigStore, schedulerAPIURL = 'https://api.us.nylas.com') {
        this.router = router;
        this.schedulerAPIURL = schedulerAPIURL;
        this.nylasAuth = nylasAuth;
        this.nylasAuthStore = nylasAuthStore;
        this.nylasSchedulerStore = nylasSchedulerStore;
        this.nylasSchedulerConfigStore = nylasSchedulerConfigStore;
    }
    init() {
        debug('NylasConnector init');
    }
    get authStore() {
        return this.nylasAuthStore;
    }
    get schedulerStore() {
        return this.nylasSchedulerStore;
    }
    get schedulerConfigStore() {
        return this.nylasSchedulerConfigStore;
    }
    get auth() {
        if (this._authConnector) {
            return this._authConnector;
        }
        this._authConnector = new NylasAuthConnector(this.nylasAuth, this.nylasAuthStore);
        return this._authConnector;
    }
    get scheduler() {
        if (this._schedulerAPIConnector) {
            return this._schedulerAPIConnector;
        }
        this._schedulerAPIConnector = new NylaSchedulerAPIConnector({
            schedulerAPIURL: this.schedulerAPIURL,
            schedulerStore: this.schedulerStore,
        });
        return this._schedulerAPIConnector;
    }
    getAuth() {
        return this.nylasAuth;
    }
    resetStores() {
        this.nylasAuthStore.reset();
    }
    async logout() {
        await this.nylasAuth.logout();
        this.resetStores();
    }
}

class PolyFillHashChangeEvent extends Event {
    constructor(type, eventInitDict) {
        super(type, eventInitDict);
        this.oldURL = eventInitDict.oldURL;
        this.newURL = eventInitDict.newURL;
    }
}
class HashRouter {
    constructor() {
        this.routeChangeListeners = [];
        debug('HashRouter constructor');
    }
    destroy() {
        debug('HashRouter destroy');
        window.removeEventListener('hashchange', this.onRouteChange.bind(this));
    }
    init() {
        debug('HashRouter init');
        window.addEventListener('hashchange', this.onRouteChange.bind(this));
        if (typeof HashChangeEvent !== 'undefined') {
            const event = new HashChangeEvent('hashchange', { oldURL: '', newURL: window.location.href });
            this.onRouteChange(event);
        }
        else {
            const event = new PolyFillHashChangeEvent('hashchange', { oldURL: '', newURL: window.location.href });
            this.onRouteChange(event);
        }
    }
    addRouteChangeListener(route, listener) {
        debug('HashRouter addRouteChangeListener');
        this.routeChangeListeners.push([route, listener]);
    }
    navigate(route, shallow) {
        debug('HashRouter navigate');
        if (shallow) {
            return window.history.pushState(null, '', `#${route}`);
        }
        window.location.hash = route;
    }
    setRoute(route) {
        debug('HashRouter setRoute');
        window.location.hash = route;
    }
    matchRoute(route, path) {
        const routeParts = route.split('/');
        const pathParts = path.split('/');
        debug(`HashRouter matchRoute route=${route} path=${path}`, { routeParts, pathParts });
        if (routeParts[1] === '' && pathParts[0] === '') {
            return true;
        }
        if (routeParts.length !== pathParts.length) {
            return false;
        }
        for (let i = 0; i < routeParts.length; i++) {
            const routePart = routeParts[i];
            const pathPart = pathParts[i];
            if (routePart.startsWith(':')) {
                continue;
            }
            if (routePart !== pathPart) {
                return false;
            }
        }
        return true;
    }
    getRouteParams(route) {
        debug('HashRouter getRouteParams');
        const routeParams = {};
        const routeParts = route.split('/');
        const routeConfigParts = window.location.hash.split('/');
        routeParts.forEach((routePart, index) => {
            if (routePart.startsWith(':')) {
                const key = routePart.substring(1);
                routeParams[key] = routeConfigParts[index];
            }
        });
        return routeParams;
    }
    getRouteWithParams(route, routeParams) {
        debug('HashRouter getRouteWithParams');
        let routeWithParams = route;
        Object.keys(routeParams).forEach(key => {
            routeWithParams = routeWithParams.replace(`:${key}`, routeParams[key]);
        });
        return routeWithParams;
    }
    getRoute() {
        debug('HashRouter getRoute');
        return window.location.hash;
    }
    onRouteChange(event) {
        this.routeChangeListeners.forEach(async ([route, listener]) => {
            const path = event.newURL.indexOf('#') === -1 ? '' : event.newURL.substring(event.newURL.indexOf('#') + 1);
            debug(`HashRouter onRouteChange route=${route} path=${path}`, { event });
            if (!this.matchRoute(route, path)) {
                debug(`HashRouter onRouteChange route=${route} path=${path} does not match`);
                return;
            }
            const routeParams = this.getRouteParams(route);
            await listener(route, path, routeParams);
        });
    }
    getBasePath() {
        debug('HashRouter getBasePath');
        return '';
    }
}

function CreateNylasAuthStore(defaultState = {}) {
    const defaultNylasStoreState = {
        isAuthenticated: false,
        tokenInfo: null,
        state: 'ready',
        ...defaultState,
    };
    const store = createStore(defaultNylasStoreState);
    store.reset = () => {
        for (const key in defaultNylasStoreState) {
            const value = defaultNylasStoreState[key];
            store.set(key, value);
        }
    };
    return store;
}

const nylasProviderCss = ":host{display:contents}";

const NylasProvider = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.init = createEvent(this, "init", 7);
        this.loggedIn = createEvent(this, "loggedIn", 7);
        this.loggedOut = createEvent(this, "loggedOut", 7);
        this.handleAuthChange = async (isAuthenticated) => {
            if (isAuthenticated) {
                this.loggedIn.emit(this.host);
            }
            else {
                this.loggedOut.emit(this.host);
            }
        };
        this.authConfig = undefined;
        this.eventOverrides = {};
        this.automaticComponentRegistration = true;
    }
    connectedCallback() {
        debug('[nylas-provider] connectedCallback');
    }
    async componentWillLoad() {
        debug('[nylas-provider] componentWillLoad');
        this.stores = {
            auth: CreateNylasAuthStore(),
            scheduler: CreateNylasSchedulerStore(),
            schedulerConfig: CreateNylasSchedulerConfigStore(),
        };
        this.baseProvider = new NylasBaseProvider(this.host, this.stores, this.automaticComponentRegistration, this.eventOverrides);
        const router = new HashRouter();
        this.nylasAuth = es({
            apiUri: 'https://api.us.nylas.com',
            elementsApiUri: 'https://elements.us.nylas.com',
            storageType: 'indexeddb',
            clientId: 'YOUR_CLIENT_ID',
            defaultScopes: [],
            redirectURI: '/',
            ...this.authConfig,
        });
        const nylasAuthStore = this.baseProvider?.getStore('auth');
        if (!nylasAuthStore) {
            throw new Error('The auth store is not set');
        }
        const nylasSchedulerStore = this.baseProvider?.getStore('scheduler');
        if (!nylasSchedulerStore) {
            throw new Error('The scheduler store is not set');
        }
        const nylasSchedulerConfigStore = this.baseProvider?.getStore('schedulerConfig');
        if (!nylasSchedulerConfigStore) {
            throw new Error('The scheduler config store is not set');
        }
        this.nylasConnector = new NylasConnector(router, this.nylasAuth, nylasAuthStore, nylasSchedulerStore, nylasSchedulerConfigStore);
        const initEvent = this.init.emit(this.host);
        if (!initEvent.defaultPrevented) {
            await this.nylasConnector?.auth.validateSession();
        }
        this.handleAuthChange(nylasAuthStore.state.isAuthenticated);
        this.baseProvider?.componentWillLoad(this.nylasConnector);
    }
    componentDidLoad() {
        const nylasAuthStore = this.baseProvider?.getStore('auth');
        nylasAuthStore?.onChange('isAuthenticated', this.handleAuthChange);
        this.baseProvider?.componentDidLoad();
    }
    componentDisconnected() {
        this.baseProvider?.componentDisconnected();
    }
    async registerComponentHandler(event) {
        this.baseProvider?.registerComponent(event.detail);
    }
    async unregisterComponentHandler(event) {
        this.baseProvider?.unregisterComponent(event.detail);
    }
    async getNylasAuth() {
        return this.nylasAuth;
    }
    async getNylasConnector() {
        return this.nylasConnector;
    }
    async getAuthStore() {
        return this.baseProvider?.getStore('auth');
    }
    async getNylasSchedulerStore() {
        return this.baseProvider?.getStore('scheduler');
    }
    async getNylasSchedulerConfigStore() {
        return this.baseProvider?.getStore('schedulerConfig');
    }
    render() {
        return (h(Host, { key: '24d8f54d35e72ef3906567058947859b05e4ef4d' }, h("slot", { key: '421dbd31175cfb81fbce8e88f484521f0a9458ec' })));
    }
    get host() { return getElement(this); }
};
NylasProvider.style = nylasProviderCss;

export { NylasProvider as nylas_provider };

//# sourceMappingURL=nylas-provider.entry.js.map