{"version":3,"names":["NylasAuthConnector","constructor","nylasAuth","nylasAuthStore","this","validateSession","isAuthenticated","isAccessTokenValid","logout","tokenInfo","getTokenInfo","expireTimeCheck","currentTimeInSeconds","Math","floor","Date","now","expires_in","debug","refreshAccessToken","state","getHostedAuthRedirectURL","scopes","email","provider","manageHostedAuthCodeExchange","currentUrl","url","URL","code","searchParams","get","exchangeAuthCodeForTokenInfo","NylasConnector","router","nylasSchedulerStore","nylasSchedulerConfigStore","schedulerAPIURL","init","authStore","schedulerStore","schedulerConfigStore","auth","_authConnector","scheduler","_schedulerAPIConnector","NylaSchedulerAPIConnector","getAuth","resetStores","reset","PolyFillHashChangeEvent","Event","type","eventInitDict","super","oldURL","newURL","HashRouter","routeChangeListeners","destroy","window","removeEventListener","onRouteChange","bind","addEventListener","HashChangeEvent","event","location","href","addRouteChangeListener","route","listener","push","navigate","shallow","history","pushState","hash","setRoute","matchRoute","path","routeParts","split","pathParts","length","i","routePart","pathPart","startsWith","getRouteParams","routeParams","routeConfigParts","forEach","index","key","substring","getRouteWithParams","routeWithParams","Object","keys","replace","getRoute","async","indexOf","getBasePath","CreateNylasAuthStore","defaultState","defaultNylasStoreState","store","createStore","value","set","nylasProviderCss","NylasProviderStyle0","NylasProvider","handleAuthChange","loggedIn","emit","host","loggedOut","connectedCallback","componentWillLoad","stores","CreateNylasSchedulerStore","schedulerConfig","CreateNylasSchedulerConfigStore","baseProvider","NylasBaseProvider","automaticComponentRegistration","eventOverrides","NylasAuth","apiUri","elementsApiUri","storageType","clientId","defaultScopes","redirectURI","authConfig","getStore","Error","nylasConnector","initEvent","defaultPrevented","componentDidLoad","onChange","componentDisconnected","registerComponentHandler","registerComponent","detail","unregisterComponentHandler","unregisterComponent","getNylasAuth","getNylasConnector","getAuthStore","getNylasSchedulerStore","getNylasSchedulerConfigStore","render","h","Host"],"sources":["src/connector/shared/api/auth.ts","src/connector/nylas-connector/index.ts","src/routers/hash-router.ts","src/stores/auth-store.ts","src/components/nylas-provider/nylas-provider.css?tag=nylas-provider&encapsulation=shadow","src/components/nylas-provider/nylas-provider.tsx"],"sourcesContent":["import { debug } from '@/utils/utils';\nimport { NylasAuthStoreType, NylasAuthType } from '../../..';\nimport { TokenInfo } from '@nylas/core/lib/auth';\nexport class NylasAuthConnector {\n  private nylasAuth: NylasAuthType;\n  private nylasAuthStore: NylasAuthStoreType;\n\n  constructor(nylasAuth: NylasAuthType, nylasAuthStore: NylasAuthStoreType) {\n    this.nylasAuth = nylasAuth;\n    this.nylasAuthStore = nylasAuthStore;\n  }\n\n  /**\n   * Validates the current session and updates the store with the token info\n   * if the user is authenticated.\n   * If the user is not authenticated, the store is reset.\n   * @returns {Promise<void>}\n   */\n  public async validateSession(): Promise<void> {\n    const isAuthenticated = await this.isAccessTokenValid();\n    if (!isAuthenticated) {\n      // Reset the store if the access token is not valid\n      this.logout();\n    } else {\n      // If the user is authenticated, update the store with the token info\n      let tokenInfo = await this.nylasAuth.getTokenInfo();\n      if (tokenInfo) {\n        // If token is expired or about to expire (in 5 minutes), refresh it\n        const expireTimeCheck = 5 * 60 * 1000; // 5 minutes\n        const currentTimeInSeconds = Math.floor(Date.now() / 1000);\n\n        if (tokenInfo.expires_in && tokenInfo.expires_in - currentTimeInSeconds < expireTimeCheck) {\n          debug('[NylasAuthConnectorMixin] Refreshing access token');\n          tokenInfo = await this.nylasAuth.refreshAccessToken();\n          if (!tokenInfo) {\n            debug('[NylasAuthConnectorMixin] Token is expired and could not be refreshed. Logging out.');\n            this.logout();\n            return;\n          }\n        }\n\n        this.nylasAuthStore.state.tokenInfo = tokenInfo;\n      }\n    }\n    this.nylasAuthStore.state.isAuthenticated = isAuthenticated;\n  }\n\n  /**\n   * Returns true if the user is authenticated.\n   * @returns {Promise<boolean>}\n   */\n  public async isAuthenticated(): Promise<boolean> {\n    return this.nylasAuth.isAuthenticated();\n  }\n\n  /**\n   * Returns the token info if the user is authenticated.\n   * @returns {Promise<TokenInfo>}\n   */\n  public async getTokenInfo(): Promise<TokenInfo | null> {\n    return this.nylasAuth.getTokenInfo();\n  }\n\n  /**\n   * Returns true if the access token is valid.\n   * @returns {Promise<boolean>}\n   */\n  public async isAccessTokenValid(): Promise<boolean> {\n    return this.nylasAuth.isAccessTokenValid();\n  }\n\n  /**\n   * Removes the token info from the store and logs the user out.\n   * @returns {Promise<void>}\n   */\n  public async logout(): Promise<void> {\n    await this.nylasAuth.logout();\n  }\n\n  /**\n   * Returns the URL to redirect the user to for authentication.\n   * @param scopes An array of scopes to request from the user.\n   * @param email The email address of the user to authenticate.\n   * @param provider The provider to use for authentication.\n   * @returns {Promise<string>}\n   */\n  public async getHostedAuthRedirectURL(scopes?: string[], email?: string, provider?: string): Promise<string> {\n    return this.nylasAuth.getHostedAuthRedirectURL(scopes, email, provider);\n  }\n\n  /**\n   * Exchanges the auth code for a token info and updates the store.\n   * @param currentUrl The current URL of the page.\n   * @returns {Promise<TokenInfo | null>}\n   */\n  public async manageHostedAuthCodeExchange(currentUrl: string): Promise<TokenInfo | null> {\n    const url = new URL(currentUrl);\n    const code = url.searchParams.get('code');\n\n    if (code) {\n      const tokenInfo = await this.nylasAuth.exchangeAuthCodeForTokenInfo(code);\n      if (tokenInfo) {\n        this.nylasAuthStore.state.tokenInfo = tokenInfo;\n        this.nylasAuthStore.state.isAuthenticated = true;\n        return tokenInfo;\n      }\n    }\n\n    return null;\n  }\n}\n","import { RouterInterface } from '@/routers/router-interface';\nimport { NylasAuthStoreType } from '@/stores/auth-store';\nimport { NylasSchedulerConfigStoreType } from '@/stores/scheduler-config-store';\nimport { NylasSchedulerStoreType } from '@/stores/scheduler-store';\nimport { debug } from '@/utils/utils';\nimport type { NylasAuthType } from '@nylas/core';\nimport { NylasConnectorInterface } from '../connector-interface';\nimport { NylasAuthConnector } from '../shared/api/auth';\nimport { NylaSchedulerAPIConnector } from '../shared/api/scheduler';\n/**\n * Base class for the Nylas connector.\n */\nexport class NylasConnector implements NylasConnectorInterface {\n  public router: RouterInterface;\n  public nylasAuth: NylasAuthType;\n  public nylasAuthStore: NylasAuthStoreType;\n  public nylasSchedulerStore: NylasSchedulerStoreType;\n  public nylasSchedulerConfigStore: NylasSchedulerConfigStoreType;\n  public schedulerAPIURL: string;\n\n  private _authConnector: NylasAuthConnector | undefined;\n  private _schedulerAPIConnector: NylaSchedulerAPIConnector | undefined;\n\n  constructor(\n    router: RouterInterface,\n    nylasAuth: NylasAuthType,\n    nylasAuthStore: NylasAuthStoreType,\n    nylasSchedulerStore: NylasSchedulerStoreType,\n    nylasSchedulerConfigStore: NylasSchedulerConfigStoreType,\n    schedulerAPIURL: string = 'https://api.us.nylas.com',\n  ) {\n    this.router = router;\n    this.schedulerAPIURL = schedulerAPIURL;\n    this.nylasAuth = nylasAuth;\n    this.nylasAuthStore = nylasAuthStore;\n    this.nylasSchedulerStore = nylasSchedulerStore;\n    this.nylasSchedulerConfigStore = nylasSchedulerConfigStore;\n  }\n\n  public init() {\n    debug('NylasConnector init');\n  }\n\n  public get authStore() {\n    return this.nylasAuthStore;\n  }\n\n  public get schedulerStore() {\n    return this.nylasSchedulerStore;\n  }\n\n  public get schedulerConfigStore() {\n    return this.nylasSchedulerConfigStore;\n  }\n\n  public get auth() {\n    if (this._authConnector) {\n      return this._authConnector;\n    }\n    this._authConnector = new NylasAuthConnector(this.nylasAuth, this.nylasAuthStore);\n    return this._authConnector;\n  }\n\n  public get scheduler() {\n    if (this._schedulerAPIConnector) {\n      return this._schedulerAPIConnector;\n    }\n    this._schedulerAPIConnector = new NylaSchedulerAPIConnector({\n      schedulerAPIURL: this.schedulerAPIURL,\n      schedulerStore: this.schedulerStore,\n    });\n    return this._schedulerAPIConnector;\n  }\n\n  public getAuth() {\n    return this.nylasAuth;\n  }\n\n  public resetStores() {\n    this.nylasAuthStore.reset();\n  }\n\n  public async logout() {\n    await this.nylasAuth.logout();\n    this.resetStores();\n  }\n}\n\nexport type PublicMethods<T> = {\n  [K in keyof T]: T[K] extends Function ? (string extends K ? never : K) : never;\n}[keyof T];\n\nexport type NylasConnectorPublicMethods = PublicMethods<NylasConnector>;\n","import { debug } from '@/utils/utils';\nimport { RouteListener, RouteParams, RoutePath, RouterInterface } from './router-interface';\n\nexport class PolyFillHashChangeEvent extends Event {\n  oldURL?: string;\n  newURL?: string;\n\n  constructor(type: string, eventInitDict: HashChangeEventInit) {\n    super(type, eventInitDict);\n    this.oldURL = eventInitDict.oldURL;\n    this.newURL = eventInitDict.newURL;\n  }\n}\n\nexport class HashRouter implements RouterInterface {\n  private routeChangeListeners: [route: RoutePath, RouteListener<any>][] = [];\n\n  constructor() {\n    debug('HashRouter constructor');\n  }\n\n  // Destroy the router\n  public destroy(): void {\n    debug('HashRouter destroy');\n    window.removeEventListener('hashchange', this.onRouteChange.bind(this));\n  }\n\n  // Initialize the router\n  public init(): void {\n    debug('HashRouter init');\n    window.addEventListener('hashchange', this.onRouteChange.bind(this));\n\n    // Trigger the initial route change\n    if (typeof HashChangeEvent !== 'undefined') {\n      const event: HashChangeEvent = new HashChangeEvent('hashchange', { oldURL: '', newURL: window.location.href });\n      this.onRouteChange(event);\n    } else {\n      const event: Event = new PolyFillHashChangeEvent('hashchange', { oldURL: '', newURL: window.location.href });\n      this.onRouteChange(event as HashChangeEvent);\n    }\n  }\n\n  public addRouteChangeListener<Path extends RoutePath>(route: Path, listener: RouteListener<Path>): void {\n    debug('HashRouter addRouteChangeListener');\n    this.routeChangeListeners.push([route, listener]);\n  }\n\n  public navigate(route: string, shallow: boolean): void {\n    debug('HashRouter navigate');\n\n    // If we're navigating shallow, don't add a new history entry\n    if (shallow) {\n      return window.history.pushState(null, '', `#${route}`);\n    }\n\n    window.location.hash = route;\n  }\n\n  public setRoute(route: string): void {\n    debug('HashRouter setRoute');\n    window.location.hash = route;\n  }\n\n  // Matches a route and executes the callback\n  public matchRoute(route: string, path: string): boolean {\n    const routeParts = route.split('/');\n    const pathParts = path.split('/');\n\n    // If the route is `/` an the hash is empty, match the route\n    debug(`HashRouter matchRoute route=${route} path=${path}`, { routeParts, pathParts });\n    if (routeParts[1] === '' && pathParts[0] === '') {\n      return true;\n    }\n\n    if (routeParts.length !== pathParts.length) {\n      return false;\n    }\n\n    for (let i = 0; i < routeParts.length; i++) {\n      const routePart = routeParts[i];\n      const pathPart = pathParts[i];\n      if (routePart.startsWith(':')) {\n        continue;\n      }\n      if (routePart !== pathPart) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Parse the route and return the route params\n  public getRouteParams<Path extends RoutePath>(route: Path): RouteParams<Path> {\n    debug('HashRouter getRouteParams');\n    const routeParams: RouteParams<Path> = {} as RouteParams<Path>;\n    const routeParts = route.split('/');\n    const routeConfigParts = window.location.hash.split('/');\n    routeParts.forEach((routePart, index) => {\n      if (routePart.startsWith(':')) {\n        const key = routePart.substring(1) as keyof RouteParams<Path>;\n        routeParams[key] = routeConfigParts[index] as RouteParams<Path>[keyof RouteParams<Path>]; // Cast the value to string\n      }\n    });\n    return routeParams;\n  }\n\n  public getRouteWithParams(route: string, routeParams: Record<string, any>): string {\n    debug('HashRouter getRouteWithParams');\n    let routeWithParams = route;\n    Object.keys(routeParams).forEach(key => {\n      routeWithParams = routeWithParams.replace(`:${key}`, routeParams[key]);\n    });\n    return routeWithParams;\n  }\n\n  public getRoute(): string {\n    debug('HashRouter getRoute');\n    return window.location.hash;\n  }\n\n  public onRouteChange(event: HashChangeEvent): void {\n    this.routeChangeListeners.forEach(async ([route, listener]) => {\n      const path = event.newURL.indexOf('#') === -1 ? '' : event.newURL.substring(event.newURL.indexOf('#') + 1);\n      debug(`HashRouter onRouteChange route=${route} path=${path}`, { event });\n      if (!this.matchRoute(route, path)) {\n        debug(`HashRouter onRouteChange route=${route} path=${path} does not match`);\n        return;\n      }\n      const routeParams = this.getRouteParams(route) as RouteParams<RoutePath>;\n      await listener(route, path, routeParams);\n    });\n  }\n\n  public getBasePath(): string {\n    debug('HashRouter getBasePath');\n    return '';\n  }\n}\n","import { TokenInfo } from '@nylas/core/dist/auth';\nimport { createStore } from '@stencil/store';\nimport { DataState } from '@/common/types';\n\nexport interface NylasAuthStoreState {\n  isAuthenticated: boolean;\n  tokenInfo: TokenInfo | null;\n  state: DataState;\n}\n\nexport type NylasAuthStoreType = ReturnType<typeof CreateNylasAuthStore>;\n\nexport function CreateNylasAuthStore(defaultState: Partial<NylasAuthStoreState> = {}) {\n  const defaultNylasStoreState: NylasAuthStoreState = {\n    isAuthenticated: false,\n    tokenInfo: null,\n    state: 'ready',\n    ...defaultState,\n  };\n  const store = createStore<NylasAuthStoreState>(defaultNylasStoreState);\n\n  /**\n   * Reset the Nylas store to its default state.\n   * There is something wrong with the stencil/store reset method,\n   * so we have to do it via this hack.\n   */\n  store.reset = () => {\n    for (const key in defaultNylasStoreState) {\n      const value = defaultNylasStoreState[key as keyof typeof defaultNylasStoreState];\n      store.set(key as any, value);\n    }\n  };\n\n  return store;\n}\n",":host {\n  display: contents;\n}\n","import { NylasBaseProvider } from '@/common/abstract-provider';\nimport { RegisteredComponent } from '@/common/register-component';\nimport { NylasConnector } from '@/connector/nylas-connector';\nimport { HashRouter } from '@/routers/hash-router';\nimport { CreateNylasAuthStore, NylasAuthStoreType } from '@/stores/auth-store';\nimport { CreateNylasSchedulerStore, NylasSchedulerStoreType } from '@/stores/scheduler-store';\nimport type { AuthConfig, NylasAuthType } from '@nylas/core';\nimport { NylasAuth } from '@nylas/core';\nimport { Component, Element, Event, EventEmitter, Host, Listen, Method, Prop, h } from '@stencil/core';\nimport type { EventOverride } from '@/common/component-types';\nimport { debug } from '@/utils/utils';\nimport { CreateNylasSchedulerConfigStore, NylasSchedulerConfigStoreType } from '@/stores/scheduler-config-store';\n\n/**\n * The Nylas Provider component.\n * This component is used to manage the Nylas Provider.\n * It is used to manage the Nylas Auth instance, the Nylas Connector instance,\n * and the Nylas Store instance.\n */\n@Component({\n  tag: 'nylas-provider',\n  styleUrl: 'nylas-provider.css',\n  shadow: true,\n})\nexport class NylasProvider {\n  /**\n   * Stores to be used by the provider.\n   */\n  private stores?: {\n    auth: NylasAuthStoreType;\n    scheduler: NylasSchedulerStoreType;\n    schedulerConfig: NylasSchedulerConfigStoreType;\n  };\n\n  /**\n   * This is a base provide that defines the common methods and properties\n   * that all providers should have.\n   *\n   * Because stencil does not support abstract classes, we have to use a\n   * property to store the base provider instance.\n   */\n  private baseProvider?: NylasBaseProvider<Exclude<typeof this.stores, undefined>>;\n\n  /**\n   * The Nylas Auth instance.\n   * Used to manage all things authentication with Nylas.\n   */\n  private nylasAuth?: NylasAuthType;\n\n  /**\n   * The Nylas Mailbox Connector instance.\n   * The branins of the provider. It manages data fetching and state synchronization.\n   */\n  private nylasConnector?: NylasConnector;\n\n  /**\n   * The host element.\n   * Used to manage the host element of the provider.\n   */\n  @Element() private host!: HTMLNylasProviderElement;\n\n  /**\n   * The Nylas Auth configuration.\n   * Used to manage all things authentication with Nylas.\n   */\n  @Prop({ attribute: 'auth-config' }) readonly authConfig?: AuthConfig;\n\n  /**\n   * This provides a way to override the default event handlers.\n   */\n  @Prop() eventOverrides: EventOverride<Exclude<typeof this.nylasConnector, undefined>> = {};\n\n  /**\n   * Automatically register components that have the `@RegisterComponent` decorator.\n   * If this is set to false, you will need to manually register components using the\n   * `registerComponent` method.\n   * @default true\n   */\n  @Prop() automaticComponentRegistration: boolean = true;\n\n  /**\n   * This event is fired when the provider is initialized.\n   * It can be used to set the initial state of the provider,\n   * or to prevent the provider from firing some default behavior.\n   */\n  @Event({ cancelable: true }) init!: EventEmitter<HTMLNylasProviderElement>;\n\n  /**\n   * This event is fired when the the NyalsAuth isAuthenticated state changes\n   * to true.\n   */\n  @Event({ cancelable: true }) loggedIn!: EventEmitter<HTMLNylasProviderElement>;\n\n  /**\n   * This event is fired when the the NyalsAuth isAuthenticated state changes\n   * to true.\n   */\n  @Event({ cancelable: true }) loggedOut!: EventEmitter<HTMLNylasProviderElement>;\n\n  connectedCallback() {\n    debug('[nylas-provider] connectedCallback');\n  }\n\n  async componentWillLoad() {\n    debug('[nylas-provider] componentWillLoad');\n\n    this.stores = {\n      auth: CreateNylasAuthStore(),\n      scheduler: CreateNylasSchedulerStore(),\n      schedulerConfig: CreateNylasSchedulerConfigStore(),\n    };\n    this.baseProvider = new NylasBaseProvider(this.host, this.stores, this.automaticComponentRegistration, this.eventOverrides);\n\n    const router = new HashRouter();\n\n    /**\n     * Create the NylasAuth instance.\n     * This is used to manage all things authentication with Nylas.\n     */\n    this.nylasAuth = NylasAuth({\n      apiUri: 'https://api.us.nylas.com',\n      elementsApiUri: 'https://elements.us.nylas.com',\n      storageType: 'indexeddb',\n      clientId: 'YOUR_CLIENT_ID',\n      defaultScopes: [],\n      redirectURI: '/',\n      ...this.authConfig,\n    });\n\n    const nylasAuthStore = this.baseProvider?.getStore('auth');\n    if (!nylasAuthStore) {\n      throw new Error('The auth store is not set');\n    }\n\n    const nylasSchedulerStore = this.baseProvider?.getStore('scheduler');\n    if (!nylasSchedulerStore) {\n      throw new Error('The scheduler store is not set');\n    }\n\n    const nylasSchedulerConfigStore = this.baseProvider?.getStore('schedulerConfig');\n    if (!nylasSchedulerConfigStore) {\n      throw new Error('The scheduler config store is not set');\n    }\n\n    this.nylasConnector = new NylasConnector(router, this.nylasAuth, nylasAuthStore, nylasSchedulerStore, nylasSchedulerConfigStore);\n\n    const initEvent = this.init.emit(this.host);\n    if (!initEvent.defaultPrevented) {\n      /**\n       * By default, on init, we will validate the session.\n       * This will check if the user is logged in and if the session is still valid.\n       * If the session is not valid, the user will be logged out.\n       */\n      await this.nylasConnector?.auth.validateSession();\n    }\n\n    /**\n     * Listen for changes in the NylasAuth isAuthenticated state.\n     * This is used to fire the loggedIn and loggedOut events.\n     */\n    this.handleAuthChange(nylasAuthStore.state.isAuthenticated);\n\n    this.baseProvider?.componentWillLoad(this.nylasConnector);\n  }\n\n  componentDidLoad() {\n    const nylasAuthStore = this.baseProvider?.getStore('auth');\n    nylasAuthStore?.onChange('isAuthenticated', this.handleAuthChange);\n\n    this.baseProvider?.componentDidLoad();\n  }\n\n  componentDisconnected() {\n    this.baseProvider?.componentDisconnected();\n  }\n\n  /**\n   * This is a custom event handler that is used to register a component with the provider.\n   * It is used by components that have the `@RegisterComponent` decorator.\n   * @param event A custom event that contains the component to register\n   * @returns Promise<void>\n   */\n  @Listen('registerComponent')\n  async registerComponentHandler(event: CustomEvent<RegisteredComponent<any, any>>): Promise<void> {\n    this.baseProvider?.registerComponent(event.detail);\n  }\n\n  /**\n   * This is a custom event handler that is used to unregister a component with the provider.\n   * It is used by components that have the `@RegisterComponent` decorator.\n   * @param event A custom event that contains the component to unregister\n   * @returns Promise<void>\n   */\n  @Listen('unregisterComponent')\n  async unregisterComponentHandler(event: CustomEvent<RegisteredComponent<any, any>>): Promise<void> {\n    this.baseProvider?.unregisterComponent(event.detail);\n  }\n\n  /**\n   * This method is used to handle changes in the NylasAuth isAuthenticated state\n   * @param isAuthenticated isAuthenticated state\n   * @returns void\n   */\n  private handleAuthChange = async (isAuthenticated: boolean) => {\n    if (isAuthenticated) {\n      this.loggedIn.emit(this.host);\n    } else {\n      this.loggedOut.emit(this.host);\n    }\n  };\n\n  /**\n   * This method is used to retrieve the NylasAuth instance\n   * @returns The NylasAuth instance\n   */\n  @Method()\n  async getNylasAuth(): Promise<NylasAuthType | undefined> {\n    return this.nylasAuth;\n  }\n\n  /**\n   * This method is used to retrieve the NylasConnector instance\n   * @returns The NylasConnector instance\n   */\n  @Method()\n  async getNylasConnector() {\n    return this.nylasConnector;\n  }\n\n  /**\n   * This method is used to retrieve the authStore instance\n   * @returns The authStore instance\n   */\n  @Method()\n  async getAuthStore(): Promise<NylasAuthStoreType | undefined> {\n    return this.baseProvider?.getStore('auth');\n  }\n\n  /**\n   * This method is used to retrieve the NylasScheduler instance\n   * @returns The NylasScheduler instance\n   */\n  @Method()\n  async getNylasSchedulerStore(): Promise<NylasSchedulerStoreType | undefined> {\n    return this.baseProvider?.getStore('scheduler');\n  }\n\n  /**\n   * This method is used to retrieve the NylasSchedulerConfig instance\n   * @returns The NylasSchedulerConfig instance\n   */\n  @Method()\n  async getNylasSchedulerConfigStore(): Promise<NylasSchedulerConfigStoreType | undefined> {\n    return this.baseProvider?.getStore('schedulerConfig');\n  }\n\n  render() {\n    return (\n      <Host>\n        <slot></slot>\n      </Host>\n    );\n  }\n}\n"],"mappings":"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"}