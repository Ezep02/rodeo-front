{"version":3,"names":["ErrorCategory","ComponentErrorType","APIErrorType","Errors","constructor","this","component","_title","category","Component","title","endtime_not_in_future","message","no_booking_info","no_timeslot_selected","no_timezone_selected","no_booking_id","no_salt","invalid_start_time","invalid_end_time","invalid_timezone","api","Api","invalid_session","general_error","internal_error","invalid_request_error","timeslot_not_available","provider_error","not_found_error","NylaSchedulerAPIConnector","schedulerAPIURL","schedulerStore","sessionId","configId","slug","clientId","errors","getHeaders","Authorization","makeAPIRequest","path","method","body","headers","schedulerURL","URL","version","pathname","response","fetch","decodeURIComponent","toString","Origin","window","location","origin","data","json","error","type","getErrorMessage","errorMessage","setConfigId","selectDate","date","set","selectTime","time","selectTimezone","timezone","selectLanguage","language","i18next","changeLanguage","toggleAdditionalData","value","refetchAvailability","setParticipantName","name","bookingInfo","state","primaryParticipant","setParticipantEmail","email","today","Date","startTime","getFullYear","getMonth","getTime","startTimeWithOffset","Math","floor","endTime","result","getAvailability","resetStoreStateAndFetchAvailability","firstAvailableDate","get","find","timeslot","start_time","_selectedDate","setReschedule","bookingID","eventInfo","getUISettings","finally","setCancel","setReject","resetCancel","goBack","resetConfirm","undefined","bookTimeslot","selectedTimeslot","selectedTimezone","selectedLanguage","t","order","participantToBookWith","length","emails","i","includes","addFields","Object","entries","additionalFields","forEach","key","entry","primaryGuest","guests","additional_fields","configIdParam","url","JSON","stringify","participants","additional_guests","guest","end_time","email_language","getTwoLetterLanguageCode","errorType","bookingId","split","getStartTimeWithMinBookingNotice","scheduler","min_booking_notice","getEndTimeForAvailableDaysInFuture","availableDaysInFuture","available_days_in_future","endTimeForAvailableDaysInFuture","addDaysToCurrentDate","endTimeWithOffset","min","params","URLSearchParams","now","nowTime","startOfMonth","endOfMonth","startTimeWithMinBooking","append","encodeURIComponent","rescheduleBookingId","queryString","availability","time_slots","map","availabilityTimeslotsFiltered","filter","cancelBooking","reason","action","cancellation_reason","booking_id","rescheduleBooking","apiErrors","componentErrors","time_zone","event","updateBooking","payload","status","salt","errorTitle","CreateNylasSchedulerStore","defaultState","defaultNylasStoreState","selectedDate","navigator","Intl","DateTimeFormat","resolvedOptions","timeZone","showBookingForm","availabilityOrderEmails","selectableDates","eventDuration","cancelledEventInfo","isLoading","nylasBranding","debug","store","createStore","onChange","durationMinutes","reset"],"sources":["src/connector/nylas-scheduler-connector/errors/index.ts","src/connector/shared/api/scheduler.ts","src/stores/scheduler-store.ts"],"sourcesContent":["export enum ErrorCategory {\n  Component = 'component',\n  Api = 'api',\n  Auth = 'auth',\n}\n\nexport interface ErrorDetails {\n  title: string;\n  message: string;\n  category: ErrorCategory;\n}\n\nexport enum ComponentErrorType {\n  endtime_not_in_future = 'endtime_not_in_future',\n  no_booking_info = 'no_booking_info',\n  no_timeslot_selected = 'no_timeslot_selected',\n  no_timezone_selected = 'no_timezone_selected',\n  no_booking_id = 'no_booking_id',\n  no_salt = 'no_salt',\n  invalid_start_time = 'invalid_start_time',\n  invalid_end_time = 'invalid_end_time',\n  invalid_timezone = 'invalid_timezone',\n}\n\nexport enum APIErrorType {\n  invalid_session = 'invalid_session',\n  general_error = 'general_error',\n  internal_error = 'internal_error',\n  invalid_request_error = 'invalid_request_error',\n  timeslot_not_available = 'timeslot_not_available',\n  provider_error = 'provider_error',\n  not_found_error = 'not_found_error',\n}\n\nexport class Errors {\n  component = (_title: string): Record<ComponentErrorType, (message?: string) => ErrorDetails> => {\n    const category = ErrorCategory.Component;\n    const title = `${_title} Error`;\n    return {\n      endtime_not_in_future: (message: string = '\"endtime\" can not be in the future') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      no_booking_info: (message: string = 'No booking info provided') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      no_timeslot_selected: (message: string = 'No timeslot selected') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      no_timezone_selected: (message: string = 'No timezone selected') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      no_booking_id: (message: string = 'No booking id provided') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      no_salt: (message: string = 'No salt provided') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      invalid_start_time: (message: string = 'Invalid start time') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      invalid_end_time: (message: string = 'Invalid end time') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      invalid_timezone: (message: string = 'Invalid timezone') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n    };\n  };\n\n  api = (_title: string): Record<APIErrorType, (message: string) => ErrorDetails> => {\n    const category = ErrorCategory.Api;\n    const title = `${_title} Error`;\n\n    return {\n      invalid_session: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      general_error: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      internal_error: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      invalid_request_error: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      timeslot_not_available: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      provider_error: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      not_found_error: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n    };\n  };\n}\n","import { AvailabilityResponse, NylasSchedulerBookingDataWithFlatFields, NylasEvent, UISettingsResponse } from '@/common/types';\nimport { NylasSchedulerStoreType } from '../../../components';\nimport type { NylasErrorResponse, NylasResponse, NylasSchedulerBookingData, NylasSchedulerResponse, Timeslot } from '@nylas/core';\nimport { APIErrorType, Errors } from '@/connector/nylas-scheduler-connector/errors';\nimport { addDaysToCurrentDate } from '@/utils/utils';\nimport i18next from '@/utils/i18n';\n\ntype NylasSchedulerAPIConnectorOptions = {\n  schedulerAPIURL: string;\n  schedulerStore: NylasSchedulerStoreType;\n  sessionId?: string;\n  configId?: string;\n  slug?: string;\n  clientId?: string;\n};\n\n/**\n * NylaSchedulerConnector\n * This class is used to make API requests to the scheduler.\n */\nexport class NylaSchedulerAPIConnector {\n  private schedulerStore: NylasSchedulerStoreType;\n  private schedulerAPIURL: string;\n  private sessionId: string | undefined;\n  private configId: string | undefined;\n  private slug: string | undefined;\n  private clientId: string | undefined;\n  private errors = new Errors();\n\n  constructor({ schedulerAPIURL, schedulerStore, sessionId, configId, slug, clientId }: NylasSchedulerAPIConnectorOptions) {\n    this.schedulerStore = schedulerStore;\n    this.schedulerAPIURL = schedulerAPIURL;\n    this.sessionId = sessionId;\n    this.configId = configId;\n    this.slug = slug;\n    this.clientId = clientId;\n  }\n\n  private getHeaders() {\n    return this.sessionId\n      ? {\n          Authorization: `Bearer ${this.sessionId}`,\n        }\n      : {};\n  }\n\n  /**\n   * Makes an API request to the scheduler.\n   * @param path The path to the API endpoint.\n   * @param method The HTTP method.\n   * @param body The request body (if any).\n   * @returns {Promise<T>}\n   */\n  public async makeAPIRequest<T>(path: string, method: string, body: string | undefined, headers = {}): Promise<NylasResponse<T>> {\n    try {\n      const schedulerURL = new URL(this.schedulerAPIURL);\n      const version = process.env.PACKAGE_VERSION || 'latest';\n      schedulerURL.pathname = path;\n      const response = await fetch(decodeURIComponent(schedulerURL.toString()), {\n        method,\n        headers: {\n          'Content-Type': 'application/json',\n          'Origin': window.location.origin,\n          'X-Source': 'nylas-scheduling',\n          'X-Nylas-Web-Elements-Version': version,\n          ...headers,\n        },\n        body,\n      });\n      // The server returns a json object for errors: eg.\n      // {\n      //     \"request_id\": \"<request_id>\",\n      //     \"error\": {\n      //         \"type\": \"not_found_error\",\n      //         \"message\": \"Session not found\"\n      //     }\n      // }\n      const data = await response.json();\n      return data as NylasResponse<T>;\n    } catch (error: any) {\n      // NOTE: current server implementation doesn't return a JSON object for errors on some endpoints\n      // handle this case by returning the error response as a string to be handled downstream\n      return {\n        error: {\n          message: error.message,\n          title: 'API request failed',\n          type: 'api',\n        },\n      } as NylasErrorResponse;\n    }\n  }\n\n  private getErrorMessage(error: NylasErrorResponse['error']) {\n    let errorMessage = error?.message || error?.title || 'Something went wrong';\n    if (error?.type === 'provider_error') {\n      errorMessage = error?.provider_error?.error?.message || error?.provider_error?.error?.title || 'Something went wrong';\n    }\n    return errorMessage;\n  }\n\n  public setConfigId(configId: string) {\n    this.configId = configId;\n  }\n\n  /**\n   * Selects a date in the scheduler.\n   */\n  public selectDate(date: Date) {\n    this.schedulerStore.set('selectedDate', date);\n    this.schedulerStore.set('selectedTimeslot', null);\n  }\n\n  /**\n   * Selects a time in the scheduler.\n   */\n  public selectTime(time: Timeslot) {\n    this.schedulerStore.set('selectedTimeslot', time);\n  }\n\n  /**\n   * Sets the timezone in the scheduler.\n   */\n  public selectTimezone(timezone: string) {\n    this.schedulerStore.set('selectedTimezone', timezone);\n  }\n\n  /**\n   * Sets the language in the scheduler.\n   */\n  public selectLanguage(language: string) {\n    this.schedulerStore.set('selectedLanguage', language);\n    i18next.changeLanguage(language);\n  }\n\n  /**\n   * Toggles showBookingForm\n   * @param value boolean\n   */\n  public async toggleAdditionalData(value: boolean) {\n    if (!value) {\n      // Refetch availability\n      await this.refetchAvailability();\n    }\n    this.schedulerStore.set('showBookingForm', value);\n  }\n\n  /**\n   * Set/update the name of the participant booking the event.\n   */\n  public setParticipantName(name: string) {\n    const { bookingInfo } = this.schedulerStore.state;\n    this.schedulerStore.set('bookingInfo', {\n      ...bookingInfo,\n      primaryParticipant: {\n        ...(bookingInfo?.primaryParticipant as NylasSchedulerBookingData['primaryParticipant']),\n        name,\n      },\n    });\n  }\n\n  /**\n   * Set/update the email of the participant booking the event.\n   */\n  public setParticipantEmail(email: string) {\n    const { bookingInfo } = this.schedulerStore.state;\n    this.schedulerStore.set('bookingInfo', {\n      ...bookingInfo,\n      primaryParticipant: {\n        ...(bookingInfo?.primaryParticipant as NylasSchedulerBookingData['primaryParticipant']),\n        email,\n      },\n    });\n  }\n\n  private async refetchAvailability() {\n    const today = new Date();\n    // Refetch availability\n    const startTime = new Date(today.getFullYear(), today.getMonth(), 1).getTime() / 1000;\n    const startTimeWithOffset = startTime < today.getTime() / 1000 ? Math.floor(today.getTime() / 1000) : startTime;\n    const endTime = new Date(today.getFullYear(), today.getMonth() + 1, 1).getTime() / 1000;\n    const result = await this.getAvailability(startTimeWithOffset, endTime);\n    return result;\n  }\n\n  private async resetStoreStateAndFetchAvailability() {\n    const today = new Date();\n    // Refetch availability\n    const result = await this.refetchAvailability();\n    // Set selected date to first available date\n    const firstAvailableDate = this.schedulerStore.get('availability').find((timeslot: any) => new Date(timeslot.start_time) > new Date());\n    let _selectedDate = today;\n    if (firstAvailableDate) {\n      _selectedDate = firstAvailableDate.start_time;\n    }\n    this.schedulerStore.set('selectedDate', _selectedDate);\n    // Reset store state\n    this.schedulerStore.set('eventInfo', null);\n    this.schedulerStore.set('showBookingForm', false);\n    this.schedulerStore.set('selectedTimeslot', null);\n\n    return result;\n  }\n\n  /**\n   * Set reschedule booking id\n   */\n  public async setReschedule(bookingID: string) {\n    this.schedulerStore.set('isLoading', true);\n    const eventInfo = this.schedulerStore.state.eventInfo;\n    if (eventInfo) {\n      this.schedulerStore.set('reschedulingEventInfo', eventInfo);\n    }\n    this.schedulerStore.set('rescheduleBookingId', bookingID);\n    await this.getUISettings();\n    // Set reschedule booking id\n    const result = await this.resetStoreStateAndFetchAvailability().finally(() => {\n      this.schedulerStore.set('isLoading', false);\n    });\n\n    return result;\n  }\n\n  /**\n   * Set cancel booking id\n   */\n  public async setCancel(bookingID: string) {\n    this.schedulerStore.set('cancelBookingId', bookingID);\n  }\n\n  /**\n   * Set reject booking id\n   */\n  public async setReject(bookingID: string) {\n    this.schedulerStore.set('rejectBookingId', bookingID);\n  }\n\n  public async resetCancel() {\n    const result = await this.resetStoreStateAndFetchAvailability();\n    this.schedulerStore.set('cancelBookingId', '');\n    this.schedulerStore.set('rejectBookingId', '');\n    this.schedulerStore.set('cancelledEventInfo', null);\n    return result;\n  }\n\n  public async goBack() {\n    this.schedulerStore.set('cancelBookingId', '');\n    return;\n  }\n\n  public async resetConfirm() {\n    const result = await this.resetStoreStateAndFetchAvailability();\n    this.schedulerStore.set('organizerConfirmationBookingId', '');\n    this.schedulerStore.set('confirmedEventInfo', undefined);\n    return result;\n  }\n\n  /**\n   * Book the selected timeslot.\n   * @param data The booking info.\n   * @returns {Promise<NylasResponse<NylasEvent>>}\n   */\n  public async bookTimeslot(data?: NylasSchedulerBookingDataWithFlatFields & { timeslot?: Timeslot }): Promise<NylasSchedulerResponse<NylasEvent>> {\n    this.schedulerStore.set('isLoading', true);\n    const { selectedTimeslot, selectedTimezone, bookingInfo, selectedLanguage } = this.schedulerStore.state;\n    if (!data && !bookingInfo) {\n      return { error: this.errors.component(i18next.t('createBookingErrorTitle')).no_booking_info() };\n    }\n\n    const timeslot = data?.timeslot || selectedTimeslot;\n    if (!timeslot) {\n      return { error: this.errors.component(i18next.t('createBookingErrorTitle')).no_timeslot_selected() };\n    }\n\n    const timezone = data && data?.timezone ? data?.timezone : selectedTimezone;\n    const language = selectedLanguage || 'en-US';\n\n    if (!timezone) {\n      return { error: this.errors.component(i18next.t('createBookingErrorTitle')).no_timezone_selected() };\n    }\n    const order = this.schedulerStore.get('availabilityOrderEmails');\n    let participantToBookWith = '';\n    if (order.length > 0) {\n      // Get the emails in the timeslot\n      const emails = timeslot?.emails || [];\n      for (let i = 0; i < order.length; i++) {\n        if (emails.includes(order[i])) {\n          participantToBookWith = order[i];\n          break;\n        }\n      }\n    }\n    const addFields = {};\n    Object.entries(bookingInfo?.additionalFields || {}).forEach(([key, entry]) => {\n      addFields[key] = (entry as { value: string; type?: string }).value;\n    });\n    const primaryGuest = data ? data?.primaryParticipant : bookingInfo?.primaryParticipant;\n    const guests = data ? data?.guests || [] : bookingInfo?.guests || [];\n    const additional_fields = data ? data?.additionalFields : addFields;\n\n    const headers = this.getHeaders();\n    const configIdParam =\n      !this.sessionId && this.configId\n        ? `?configuration_id=${this.configId}`\n        : !this.sessionId && this.slug && this.clientId\n          ? `?slug=${this.slug}&client_id=${this.clientId}`\n          : '';\n    const url = `/v3/scheduling/bookings${configIdParam}`;\n\n    const response = await this.makeAPIRequest<NylasEvent>(\n      decodeURIComponent(url),\n      'POST',\n      JSON.stringify({\n        participants: participantToBookWith ? [{ email: participantToBookWith }] : undefined,\n        additional_fields,\n        additional_guests: guests,\n        guest: { ...primaryGuest },\n        start_time: timeslot.start_time.getTime() / 1000,\n        end_time: timeslot.end_time.getTime() / 1000,\n        timezone: timezone,\n        email_language: this.getTwoLetterLanguageCode(language),\n      }),\n      headers,\n    );\n\n    if ('error' in response) {\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in this.errors.api('Create Booking')) {\n        const errorMessage = this.getErrorMessage(error);\n        error = this.errors.api('Create Booking')[errorType as APIErrorType](errorMessage);\n      }\n      return { error };\n    }\n\n    if ('data' in response) {\n      this.schedulerStore.set('eventInfo', response?.data);\n    }\n\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n\n  /**\n   * Get UI settings for the scheduler.\n   */\n  public async getUISettings(): Promise<NylasSchedulerResponse<UISettingsResponse>> {\n    this.schedulerStore.set('isLoading', true);\n    const bookingId = this.schedulerStore.get('rescheduleBookingId');\n    const headers = this.getHeaders();\n    let configIdParam =\n      !this.sessionId && this.configId\n        ? `?configuration_id=${this.configId}`\n        : !this.sessionId && this.slug && this.clientId\n          ? `?slug=${this.slug}&client_id=${this.clientId}`\n          : '';\n    if (bookingId && !!configIdParam) {\n      configIdParam += `&booking_id=${bookingId}`;\n    } else if (bookingId) {\n      configIdParam += `?booking_id=${bookingId}`;\n    }\n\n    const url = `/v3/scheduling/ui-settings${configIdParam}`;\n\n    const response = await this.makeAPIRequest<UISettingsResponse>(url, 'GET', undefined, headers);\n    if ('error' in response) {\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in this.errors.api(i18next.t('getUISettingErrorTitle'))) {\n        error = this.errors.api(i18next.t('getUISettingErrorTitle'))[errorType as APIErrorType](error?.message || error?.title || 'Something went wrong');\n      }\n      return { error };\n    }\n    if ('data' in response) {\n      this.schedulerStore.set('configSettings', response.data);\n    }\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n\n  private getTwoLetterLanguageCode(language: string) {\n    return language.split('-')[0];\n  }\n\n  private getStartTimeWithMinBookingNotice(startTime: number) {\n    const scheduler = this.schedulerStore.get('configSettings')?.scheduler;\n    const min_booking_notice = scheduler?.min_booking_notice;\n    if (!min_booking_notice) {\n      return startTime;\n    }\n    const today = new Date().getTime();\n\n    if (startTime < (today + min_booking_notice * 60 * 1000) / 1000) {\n      return Math.floor((today + min_booking_notice * 60 * 1000) / 1000);\n    } else {\n      return startTime;\n    }\n  }\n\n  private getEndTimeForAvailableDaysInFuture(endTime: number) {\n    const today = new Date();\n    const availableDaysInFuture = this.schedulerStore.get('configSettings')?.scheduler?.available_days_in_future;\n    const endTimeForAvailableDaysInFuture = Math.floor(addDaysToCurrentDate(today, availableDaysInFuture).getTime() / 1000);\n    const endTimeWithOffset = Math.min(endTimeForAvailableDaysInFuture, endTime);\n    return endTimeWithOffset;\n  }\n\n  /**\n   * Gets the availability for a page.\n   * @param startTime The start time.\n   * @param endTime The end time.\n   * @returns {Promise<AvailabilityResponse>}\n   */\n  public async getAvailability(startTime: number = 0, endTime: number = 0): Promise<NylasSchedulerResponse<AvailabilityResponse>> {\n    this.schedulerStore.set('isLoading', true);\n    const params = new URLSearchParams();\n    const now = new Date();\n    const nowTime = now.getTime();\n\n    if (endTime && endTime < nowTime / 1000) {\n      this.schedulerStore.set('isLoading', false);\n      const error = this.errors.component(i18next.t('getAvailabilityErrorTitle')).endtime_not_in_future();\n      return { error };\n    }\n\n    // Calculate the start of the current month if startTime is not provided\n    if (!startTime) {\n      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n      startTime = Math.floor(startOfMonth.getTime() / 1000); // Convert to UNIX timestamp in seconds\n    }\n\n    // Calculate the end of the current month if endTime is not provided\n    if (!endTime) {\n      const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0); // Setting day to 0 gets the last day of the previous month, so in this case, the last day of the current month\n      endTime = Math.floor(endOfMonth.getTime() / 1000); // Convert to UNIX timestamp in seconds\n    }\n\n    endTime = this.getEndTimeForAvailableDaysInFuture(endTime);\n    const startTimeWithMinBooking = this.getStartTimeWithMinBookingNotice(startTime);\n    startTime = startTimeWithMinBooking;\n    endTime = startTimeWithMinBooking > endTime ? startTimeWithMinBooking + 1 : endTime;\n\n    params.append('start_time', encodeURIComponent(startTime.toString()));\n    params.append('end_time', encodeURIComponent(endTime.toString()));\n    if (this.configId && !this.sessionId) {\n      params.append('configuration_id', encodeURIComponent(this.configId));\n    } else if (this.slug && this.clientId && !this.sessionId) {\n      params.append('slug', encodeURIComponent(this.slug));\n      params.append('client_id', encodeURIComponent(this.clientId));\n    }\n\n    const rescheduleBookingId = this.schedulerStore.get('rescheduleBookingId');\n    if (rescheduleBookingId) {\n      params.append('booking_id', encodeURIComponent(rescheduleBookingId));\n    }\n    const queryString = params.toString();\n    const url = `/v3/scheduling/availability${queryString ? `?${queryString}` : ''}`;\n    const headers = this.getHeaders();\n    const response = await this.makeAPIRequest<AvailabilityResponse>(decodeURIComponent(url), 'GET', undefined, headers);\n\n    if ('error' in response) {\n      this.schedulerStore.set('availability', []);\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in this.errors.api(i18next.t('getAvailabilityErrorTitle'))) {\n        const errorMessage = this.getErrorMessage(error);\n        error = this.errors.api(i18next.t('getAvailabilityErrorTitle'))[errorType as APIErrorType](errorMessage);\n      }\n      return { error };\n    }\n\n    if ('data' in response) {\n      const availability =\n        response.data?.time_slots?.map(timeslot => {\n          return {\n            ...timeslot,\n            start_time: new Date(timeslot.start_time * 1000),\n            end_time: new Date(timeslot.end_time * 1000),\n          };\n        }) || [];\n\n      // Filter out timeslots that are in the past\n      const availabilityTimeslotsFiltered = availability.filter(timeslot => timeslot.start_time.getTime() > nowTime);\n      this.schedulerStore.set('availability', availabilityTimeslotsFiltered);\n      const order = response.data?.order || [];\n      this.schedulerStore.set('availabilityOrderEmails', order);\n    }\n\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n\n  /**\n   * Cancels a booking.\n   * @param bookingId The booking ID.\n   */\n  public async cancelBooking(bookingId: string, reason: string): Promise<NylasSchedulerResponse<Partial<NylasEvent>>> {\n    this.schedulerStore.set('isLoading', true);\n    if (!bookingId) {\n      return { error: this.errors.component(i18next.t('cancelBookingErrorTitle')).no_booking_id() };\n    }\n    const configIdParam =\n      !this.sessionId && this.configId\n        ? `?configuration_id=${this.configId}`\n        : !this.sessionId && this.slug && this.clientId\n          ? `?slug=${this.slug}&client_id=${this.clientId}`\n          : '';\n    const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;\n    const headers = this.getHeaders();\n    const response = await this.makeAPIRequest<Partial<NylasEvent>>(\n      decodeURIComponent(url),\n      'DELETE',\n      JSON.stringify({\n        action: 'cancel',\n        cancellation_reason: reason,\n      }),\n      headers,\n    );\n\n    if ('error' in response) {\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in this.errors.api(i18next.t('cancelBookingErrorTitle'))) {\n        const errorMessage = this.getErrorMessage(error);\n        error = this.errors.api(i18next.t('cancelBookingErrorTitle'))[errorType as APIErrorType](errorMessage);\n      }\n      return { error };\n    }\n\n    this.schedulerStore.set('cancelledEventInfo', {\n      booking_id: bookingId,\n    });\n    this.schedulerStore.set('rescheduleBookingId', '');\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n\n  /**\n   * Reschedules a booking.\n   * @param bookingId The booking ID.\n   * @param data The booking info.\n   * @returns {Promise<NylasResponse<NylasEvent>>}\n   */\n  public async rescheduleBooking(bookingId: string, data: NylasSchedulerBookingDataWithFlatFields): Promise<NylasSchedulerResponse<NylasEvent>> {\n    this.schedulerStore.set('isLoading', true);\n    if (!bookingId) {\n      return { error: this.errors.component(i18next.t('rescheduleBookingErrorTitle')).no_booking_id() };\n    }\n    const apiErrors = this.errors.api(i18next.t('rescheduleBookingErrorTitle'));\n    const componentErrors = this.errors.component(i18next.t('rescheduleBookingErrorTitle'));\n    const { bookingInfo, selectedTimeslot, selectedTimezone, selectedLanguage } = this.schedulerStore.state;\n    // Validate data\n    const { startTime, endTime, timezone } = data;\n    const start_time = startTime || selectedTimeslot?.start_time;\n\n    if (!start_time) {\n      return { error: componentErrors.invalid_start_time('Please pass \"startTime\" in data or set \"selectedTimeslot\" in the defaultSchedulerState.') };\n    }\n    const end_time = endTime || selectedTimeslot?.end_time;\n    if (!end_time) {\n      return { error: componentErrors.invalid_end_time('Please pass \"endTime\" in data or set \"selectedTimeslot\" in the defaultSchedulerState.') };\n    }\n\n    const order = this.schedulerStore.get('availabilityOrderEmails');\n    let participantToBookWith = '';\n    if (order.length > 0) {\n      // Get the emails in the timeslot\n      const emails = selectedTimeslot?.emails || [];\n      for (let i = 0; i < order.length; i++) {\n        if (emails.includes(order[i])) {\n          participantToBookWith = order[i];\n          break;\n        }\n      }\n    }\n\n    const time_zone = timezone || selectedTimezone;\n    if (!time_zone) {\n      return { error: componentErrors.invalid_timezone('Please pass \"timezone\" in data or set \"selectedTimezone\" in the defaultSchedulerState.') };\n    }\n    const addFields = {};\n    Object.entries(bookingInfo?.additionalFields || {}).forEach(([key, entry]) => {\n      addFields[key] = (entry as { value: string; type?: string }).value;\n    });\n    const primaryGuest = data ? data?.primaryParticipant : bookingInfo?.primaryParticipant;\n    const guests = data ? data?.guests || [] : bookingInfo?.guests || [];\n    const additional_fields = data ? data?.additionalFields : addFields;\n\n    const configIdParam =\n      !this.sessionId && this.configId\n        ? `?configuration_id=${this.configId}`\n        : !this.sessionId && this.slug && this.clientId\n          ? `?slug=${this.slug}&client_id=${this.clientId}`\n          : '';\n    const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;\n    const headers = this.getHeaders();\n    const response = await this.makeAPIRequest<NylasEvent>(\n      decodeURIComponent(url),\n      'PATCH',\n      JSON.stringify({\n        start_time: start_time.getTime() / 1000,\n        end_time: end_time.getTime() / 1000,\n        timezone: time_zone,\n        additional_fields,\n        guest: { ...primaryGuest },\n        additional_guests: guests,\n        participants: participantToBookWith ? [{ email: participantToBookWith }] : undefined,\n        email_language: this.getTwoLetterLanguageCode(selectedLanguage),\n      }),\n      headers,\n    );\n\n    if ('error' in response) {\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in apiErrors) {\n        const errorMessage = this.getErrorMessage(error);\n        error = apiErrors[errorType as APIErrorType](errorMessage);\n      }\n      return { error };\n    }\n\n    const eventInfo = this.schedulerStore.get('reschedulingEventInfo');\n    if ('data' in response) {\n      this.schedulerStore.set('eventInfo', response?.data);\n    } else if (eventInfo) {\n      this.schedulerStore.set('eventInfo', eventInfo);\n    } else {\n      // We should technically never reach this point\n      const event = {\n        booking_id: bookingId,\n      } as NylasEvent;\n      this.schedulerStore.set('eventInfo', event);\n    }\n\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n\n  /**\n   * Updates the booking.\n   * @param bookingId The booking ID.\n   */\n  public async updateBooking(payload: { bookingId: string; status: 'confirmed' | 'cancelled'; reason?: string }): Promise<NylasSchedulerResponse<NylasEvent>> {\n    this.schedulerStore.set('isLoading', true);\n    const { bookingId, status, reason } = payload;\n    const salt = this.schedulerStore.get('organizerConfirmationSalt');\n    const errorTitle = status === 'confirmed' ? i18next.t('confirmBookingErrorTitle') : i18next.t('rejectBookingErrorTitle');\n\n    if (!bookingId) {\n      return { error: this.errors.component(errorTitle).no_booking_id() };\n    }\n    if (!salt) {\n      return { error: this.errors.component(errorTitle).no_salt() };\n    }\n\n    const configIdParam =\n      !this.sessionId && this.configId\n        ? `?configuration_id=${this.configId}`\n        : !this.sessionId && this.slug && this.clientId\n          ? `?slug=${this.slug}&client_id=${this.clientId}`\n          : '';\n    const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;\n    const headers = this.getHeaders();\n    const response = await this.makeAPIRequest<NylasEvent>(\n      decodeURIComponent(url),\n      'PUT',\n      JSON.stringify({\n        status: status,\n        cancellation_reason: reason,\n        salt,\n      }),\n      headers,\n    );\n\n    if ('error' in response) {\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in this.errors.api(errorTitle)) {\n        const errorMessage = this.getErrorMessage(error);\n        error = this.errors.api(errorTitle)[errorType as APIErrorType](errorMessage);\n      }\n      return { error };\n    }\n\n    if ('data' in response && status === 'confirmed') {\n      this.schedulerStore.set('confirmedEventInfo', response?.data);\n    } else if ('request_id' in response && status === 'cancelled') {\n      this.schedulerStore.set('cancelledEventInfo', {\n        booking_id: bookingId,\n      });\n    }\n\n    this.schedulerStore.set('organizerConfirmationBookingId', '');\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n}\n","import { DataState, NylasEvent } from '@/common/types';\nimport { debug } from '@/utils/utils';\nimport { AdditionalFields, Appearance, NylasSchedulerBookingData, ThemeConfig, Timeslot } from '@nylas/core';\nimport { createStore } from '@stencil/store';\n\nexport type AvailabilityTimeslot = {\n  emails: string[];\n  start_time: Date;\n  end_time: Date;\n};\n\nexport type LoadingState = {\n  api: 'availability' | 'createBooking' | 'cancelBooking' | 'rescheduleBooking';\n};\n\nexport type ConfigSettings = {\n  configuration_id: string;\n  booking?: {\n    additional_fields: Record<string, string>;\n    additional_guests: {\n      email: string;\n      name: string;\n    }[];\n    booking_ref: string;\n    booking_ref_salt: string;\n    guest: {\n      email: string;\n      name: string;\n    };\n    timezone: string;\n    email_language: string;\n    event_data: {\n      location: string;\n      when: {\n        start_time: Date;\n        end_time: Date;\n        end_timezone: string;\n        start_timezone: string;\n        object: string;\n      };\n    };\n    event_organizer: {\n      name: string;\n      email: string;\n      is_organizer: boolean;\n    };\n  };\n  scheduler: {\n    available_days_in_future: number;\n    min_cancellation_notice: number;\n    min_booking_notice: number;\n    rescheduling_url?: string;\n    cancellation_url?: string;\n    cancellation_policy?: string;\n    hide_additional_guests?: boolean;\n    hide_cancellation_options?: boolean;\n    hide_rescheduling_options?: boolean;\n    additional_fields?: Record<string, AdditionalFields>;\n    confirmation_redirect_url?: string;\n    organizer_confirmation_url?: string;\n  };\n  organizer: {\n    name: string;\n    email: string;\n  };\n  slug: string;\n  appearance: Appearance;\n  booking_type: string;\n  name: string;\n};\n\nexport interface NylasSchedulerStoreState {\n  selectedDate: Date | null;\n  selectedLanguage: string;\n  selectedTimezone: string;\n  selectedTimeslot: Timeslot | null;\n  availabilityOrderEmails: string[];\n  showBookingForm: boolean;\n  selectableDates: Date[] | null;\n  eventDuration: number;\n  availability: AvailabilityTimeslot[];\n  state: DataState;\n  eventInfo: NylasEvent | null;\n  cancelledEventInfo: Partial<NylasEvent> | null;\n  reschedulingEventInfo?: NylasEvent;\n  confirmedEventInfo?: NylasEvent;\n  bookingInfo?: NylasSchedulerBookingData;\n  rescheduleBookingId?: string;\n  cancelBookingId?: string;\n  isLoading: boolean;\n  nylasBranding?: boolean;\n  configSettings?: ConfigSettings;\n  organizerConfirmationBookingId?: string;\n  rejectBookingId?: string;\n  organizerConfirmationSalt?: string;\n  themeConfig?: ThemeConfig;\n}\n\nexport type NylasSchedulerStoreType = ReturnType<typeof CreateNylasSchedulerStore>;\n\nexport function CreateNylasSchedulerStore(defaultState: Partial<NylasSchedulerStoreState> = {}) {\n  const defaultNylasStoreState: NylasSchedulerStoreState = {\n    selectedDate: null,\n    selectedLanguage: navigator.language,\n    selectedTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n    selectedTimeslot: null,\n    showBookingForm: false,\n    availabilityOrderEmails: [],\n    selectableDates: null,\n    availability: [],\n    eventDuration: 0,\n    state: 'ready',\n    eventInfo: null,\n    cancelledEventInfo: null,\n    isLoading: false,\n    nylasBranding: true,\n    ...defaultState,\n  };\n  debug(`[defaultNylasStoreState]: `, defaultNylasStoreState);\n  const store = createStore<NylasSchedulerStoreState>(defaultNylasStoreState);\n\n  store.onChange('availability', availability => {\n    debug(`[availability]: `, availability);\n    const selectableDates = availability.map(timeslot => timeslot.start_time);\n    debug(`[selectableDates]: `, selectableDates);\n    store.set('selectableDates', selectableDates);\n    const timeslot = availability[0];\n    if (!timeslot) return;\n    const durationMinutes = Math.floor((timeslot.end_time.getTime() - timeslot.start_time.getTime()) / 60000);\n    debug(`[durationMinutes]: `, durationMinutes);\n    store.set('eventDuration', durationMinutes);\n  });\n\n  /**\n   * Reset the Nylas store to its default state.\n   * There is something wrong with the stencil/store reset method,\n   * so we have to do it via this hack.\n   */\n  store.reset = () => {\n    for (const key in defaultNylasStoreState) {\n      const value = defaultNylasStoreState[key as keyof typeof defaultNylasStoreState];\n      store.set(key as any, value);\n    }\n  };\n\n  return store;\n}\n"],"mappings":"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"}