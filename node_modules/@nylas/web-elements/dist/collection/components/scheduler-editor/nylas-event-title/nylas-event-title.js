var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
import { RegisterComponent } from "../../../common/register-component";
import { debug, getBrowser, isNonPrintableKey, sanitize } from "../../../utils/utils";
import { Host, h } from "@stencil/core";
import { EVENT_TITLE_TOKENS as eventTitleTokens } from "../../../common/constants";
import i18next from "../../../utils/i18n";
export class NylasEventTitle {
    constructor() {
        this.selectedConfiguration = undefined;
        this.eventTitle = this.selectedConfiguration?.event_booking?.title;
        this.name = 'title';
        this.selectedLanguage = undefined;
        this.showTokens = false;
        this.availableTokens = eventTitleTokens.map(token => ({
            label: token.token,
            value: token.value,
            labelHTML: token,
        }));
        this.filteredTokens = this.availableTokens;
        this.ariaActivedescendant = '';
        this.currentWord = { $value: '', fullText: '', index: -1, focusOffset: -1 };
        this.validationError = '';
        this.configEventTitle = '';
        this.additionalFieldTokens = [];
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-event-title', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    ariaActivedescendantChangedHandler(newValue) {
        debug('nylas-event-title', 'ariaActivedescendantChangedHandler', newValue);
        if (newValue !== '') {
            const activeOption = this.host.shadowRoot?.getElementById(newValue);
            activeOption?.classList.add('active');
        }
        else {
            const options = this.host.shadowRoot?.querySelectorAll('.token-options li.active');
            options?.forEach(option => option.classList.remove('active'));
        }
    }
    configChangedHandler(newVal) {
        const title = newVal?.event_booking?.title;
        const additionalFields = newVal?.scheduler?.additional_fields || {};
        const newKeys = Object.keys(additionalFields) || [];
        const newTokens = newKeys.map(key => {
            return {
                token: `\$${key}`,
                value: `\${${key}}`,
                description: additionalFields[key].label || '',
            };
        });
        this.additionalFieldTokens = [...newTokens];
        this.availableTokens = [...eventTitleTokens, ...newTokens].map(token => ({
            label: token.token,
            value: token.value,
            labelHTML: token,
        }));
        this.filteredTokens = [...this.availableTokens];
        this.configEventTitle = title;
        if (title) {
            this.updateEventTitleFromProp(title);
        }
    }
    selectedLanguageChangedHandler(newVal, oldVal) {
        if (newVal === oldVal)
            return;
        i18next.changeLanguage(newVal);
    }
    connectedCallback() {
        debug('nylas-event-title', 'connectedCallback');
    }
    componentWillLoad() {
        debug('nylas-event-title', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-event-title', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.eventTitle = this.selectedConfiguration?.event_booking?.title;
        }
        this.updateEventTitleFromProp(this.eventTitle || '');
    }
    disconnectedCallback() {
        debug('nylas-event-title', 'disconnectedCallback');
    }
    formSubmittedHandler(event) {
        debug('nylas-event-title', 'formSubmittedHandler', event);
        if (!this.internals?.validity?.valid) {
            this.validationError = 'Event title is required';
        }
        else {
            this.validationError = '';
        }
    }
    valueChangedHandler(event) {
        const { name, value } = event.detail;
        const additionalFields = value || {};
        if (name === 'additional-fields') {
            const newKeys = Object.keys(additionalFields) || [];
            const newTokens = newKeys.map(key => {
                return {
                    token: `\$${key}`,
                    value: `\${${key}}`,
                    description: additionalFields[key].label || '',
                };
            });
            this.additionalFieldTokens = [...newTokens];
            this.availableTokens = [...eventTitleTokens, ...newTokens].map(token => ({
                label: token.token,
                value: token.value,
                labelHTML: token,
            }));
            this.filteredTokens = [...this.availableTokens];
        }
    }
    updateEventTitleFromProp(newValue) {
        debug('nylas-event-title', 'eventTitleChangedHandler', newValue);
        const title = newValue || this.configEventTitle;
        if (this.titleRef) {
            this.titleRef.innerHTML = this.highlightTokens(title);
            if (typeof this.internals.setValidity === 'function') {
                if (!title || title === '') {
                    this.titleRef.focus();
                    this.internals?.setValidity({ customError: true }, `Event title is required`, this.titleRef);
                }
                else {
                    this.internals?.setValidity({ customError: false });
                }
            }
        }
    }
    highlightTokens(title) {
        let outputHtml = title;
        [...eventTitleTokens, ...this.additionalFieldTokens].forEach(tokenObj => {
            const token = tokenObj.value;
            const regex = new RegExp(`(\\${token})(?!\\w)`, 'g');
            outputHtml = outputHtml?.replace(regex, '<span class="highlighted-tag">$1</span>') || '';
        });
        return outputHtml;
    }
    getCurrentSelectionForBrowser() {
        const getSelectionTextData = (nodeValue, offset, node, allSelected) => {
            const text = nodeValue.replace(/[\u200B-\u200D\uFEFF]/g, '');
            const dollarIndex = text.lastIndexOf('$');
            const lastWord = text.substring(dollarIndex).split(' ')[0];
            return {
                focusOffset: offset,
                dollarIndex,
                lastWord,
                currentText: text,
                node,
                allSelected,
            };
        };
        const isAllSelected = (selection) => selection.anchorOffset === 0 && selection.focusOffset === selection.focusNode?.nodeValue?.length;
        const currentBrowser = getBrowser();
        switch (currentBrowser) {
            case 'Chrome':
                const shadowRootSelection = this.host.shadowRoot?.getSelection();
                const focusNode = shadowRootSelection?.focusNode;
                const focusNodeValue = focusNode?.nodeValue || '';
                const allSelected = shadowRootSelection && isAllSelected(shadowRootSelection);
                return getSelectionTextData(focusNodeValue, shadowRootSelection?.focusOffset || -1, focusNode, allSelected);
            case 'Firefox':
                const selection = document.getSelection();
                const anchorNodeValue = selection?.anchorNode?.nodeValue || '';
                const allSelectedFirefox = selection && isAllSelected(selection);
                return getSelectionTextData(anchorNodeValue, selection?.focusOffset || -1, selection?.anchorNode, allSelectedFirefox);
            case 'Safari':
                const windowSelection = window.getSelection();
                const anchorNode = windowSelection?.getComposedRanges(this.host.shadowRoot)[0];
                const currentText = anchorNode?.startContainer?.nodeValue || '';
                const allSelectedSafari = windowSelection && isAllSelected(windowSelection);
                return getSelectionTextData(currentText, anchorNode?.endOffset || -1, anchorNode?.startContainer, allSelectedSafari);
            default:
                console.warn('Browser not supported');
                return null;
        }
    }
    handleChange(event) {
        let textContent = event.target.textContent || '';
        textContent = sanitize(textContent);
        const currentSelection = this.getCurrentSelectionForBrowser();
        if (!currentSelection) {
            this.updateEventTitle(textContent);
            this.resetDropdown();
            return;
        }
        const { focusOffset, dollarIndex, lastWord, currentText } = currentSelection;
        if (dollarIndex === -1 || focusOffset < dollarIndex) {
            this.updateEventTitle(textContent);
            this.resetDropdown();
            return;
        }
        if (lastWord.startsWith('$')) {
            this.showTokens = true;
            this.currentWord = {
                $value: lastWord,
                fullText: currentText,
                index: dollarIndex,
                focusOffset,
            };
            this.populateSuggestionsDropdown(lastWord);
        }
        else {
            this.resetDropdown();
        }
        this.updateEventTitle(textContent);
    }
    handleInputKeyDown(event) {
        const selection = this.getCurrentSelectionForBrowser();
        if (selection?.allSelected && !isNonPrintableKey(event)) {
            this.titleRef.innerHTML = '';
        }
        if (event.key === 'Enter') {
            event.preventDefault();
            const activeOption = this.host.shadowRoot?.getElementById(this.ariaActivedescendant);
            if (activeOption) {
                activeOption.click();
                this.ariaActivedescendant = '';
            }
        }
        else if (event.key === 'ArrowDown') {
            event.preventDefault();
            const activeOption = this.host.shadowRoot?.getElementById(this.ariaActivedescendant);
            if (activeOption) {
                const nextOption = activeOption.nextElementSibling;
                if (nextOption) {
                    this.ariaActivedescendant = nextOption.id;
                }
                else {
                    this.ariaActivedescendant = this.filteredTokens[0].label;
                }
            }
            else {
                this.ariaActivedescendant = this.filteredTokens[0].label;
            }
        }
        else if (event.key === 'ArrowUp') {
            event.preventDefault();
            const activeOption = this.host.shadowRoot?.getElementById(this.ariaActivedescendant);
            if (activeOption) {
                const prevOption = activeOption.previousElementSibling;
                if (prevOption) {
                    this.ariaActivedescendant = prevOption.id;
                }
                else {
                    this.ariaActivedescendant = this.filteredTokens[this.filteredTokens.length - 1].label;
                }
            }
            else {
                this.ariaActivedescendant = this.filteredTokens[this.filteredTokens.length - 1].label;
            }
        }
        else if (event.key === 'Escape') {
            event.preventDefault();
            this.resetDropdown();
        }
        else if (event.key === 'Backspace' || event.key === 'Delete') {
            const parentNode = selection?.node?.parentNode;
            if (selection?.currentText.startsWith('${') && parentNode && parentNode.nodeName === 'SPAN') {
                event.preventDefault();
                parentNode.removeChild(selection.node);
                parentNode.remove();
                this.resetDropdown();
                this.updateEventTitle(this.titleRef?.textContent || '');
            }
            if (this.titleRef.textContent === '' || selection?.allSelected) {
                this.titleRef.innerHTML = '';
                this.updateEventTitle('');
            }
        }
    }
    selectOption(e, option) {
        e.preventDefault();
        const word = this.currentWord.fullText;
        const dollarWord = this.currentWord.$value;
        let currentNode = this.titleRef.firstChild;
        let textNode = null;
        while (currentNode) {
            if (currentNode.nodeType === 3) {
                const currentNodeText = currentNode.textContent?.replace(/[\u200B-\u200D\uFEFF]/g, '') || '';
                const wordText = word.replace(/[\u200B-\u200D\uFEFF]/g, '');
                if (currentNodeText.includes(wordText)) {
                    textNode = currentNode;
                    break;
                }
            }
            currentNode = currentNode.nextSibling;
        }
        if (!textNode) {
            return;
        }
        const text = textNode.textContent || '';
        const index = text.indexOf(dollarWord);
        const textBefore = text.substring(0, index);
        const textAfter = text.substring(index + dollarWord.length);
        const newTextNode = document.createTextNode(textBefore);
        const newRange = document.createRange();
        const tagSpan = document.createElement('span');
        tagSpan.classList.add('highlighted-tag');
        tagSpan.textContent = `${option.value}`;
        const newTextNodeAfter = document.createTextNode(textAfter);
        if (textAfter !== '') {
            textNode.replaceWith(newTextNode, tagSpan, newTextNodeAfter);
            newRange.setStart(newTextNodeAfter, 1);
        }
        else {
            const afterNode = document.createTextNode('\u200B');
            textNode.replaceWith(newTextNode, tagSpan, afterNode);
            newRange.setStart(afterNode, 1);
        }
        this.resetDropdown();
        this.titleRef.focus();
        const sel = window.getSelection();
        newRange.collapse(true);
        sel?.removeAllRanges();
        sel?.addRange(newRange);
        this.updateEventTitle(this.titleRef.textContent || '');
    }
    populateSuggestionsDropdown(query = '') {
        this.filteredTokens = this.availableTokens.filter(obj => {
            return obj.label.startsWith(query.toString()) || obj.value.startsWith(query.toString());
        });
        if (this.filteredTokens.length > 0) {
            this.ariaActivedescendant = this.filteredTokens[0].label;
        }
    }
    get isInternalsAvailable() {
        return typeof this.internals !== 'undefined' && typeof this.internals.setValidity === 'function' && typeof this.internals.setFormValue === 'function';
    }
    updateEventTitle(text) {
        const value = text.replace(/ +/g, ' ');
        if (value === '' || /^[\s]*$/.test(value)) {
            this.validationError = 'Event title is required';
            this.isInternalsAvailable && this.internals?.setValidity({ customError: true }, `Event title is required`, this.titleRef);
        }
        else {
            this.validationError = '';
            this.isInternalsAvailable && this.internals?.setValidity({ customError: false });
        }
        this.isInternalsAvailable && this.internals?.setFormValue(value, this.name);
        this.valueChanged.emit({ value: value, name: this.name });
    }
    resetDropdown() {
        this.showTokens = false;
        this.ariaActivedescendant = '';
    }
    getLabelHTML(token) {
        return (h("div", { class: "token-label" }, h("span", { class: "token" }, token.token), h("span", { class: "description" }, token.description)));
    }
    render() {
        return (h(Host, { key: '939a9d39a09fc21d9ddc3a9439531e67eb3c3ca4' }, h("div", { key: '64b4c5803d47507ce973901a2b72bd6e282d69ec', class: "nylas-event-title", part: "net" }, h("label", { key: '1e767bdcb14c5856116c292f1528ae48426fa629', htmlFor: "title" }, i18next.t('nylasEventTitle.headerTitle'), h("span", { key: 'f067d784f17ce438f6691470ae78014028fe0ae9', class: "required" }, "*")), h("div", { key: '043eaabcf1c15d4935717e00b04d62d087f75a87', class: {
                title: true,
                error: this.validationError !== '',
            }, part: "net__title", ref: el => (this.titleRef = el), contentEditable: "true", onInput: e => this.handleChange(e), onKeyDown: event => this.handleInputKeyDown(event) }), this.showTokens && this.filteredTokens?.length > 0 && (h("div", { class: "token-options", part: "net__dropdown-content" }, h("ul", { tabindex: "-1", role: "listbox", "aria-label": this.name, "aria-activedescendant": this.ariaActivedescendant }, this.filteredTokens.map(option => (h("li", { tabindex: "0", key: option.label, id: option.label, class: { active: this.ariaActivedescendant === option.label }, onClick: e => this.selectOption(e, option), role: "option" }, this.getLabelHTML(option.labelHTML))))))), h("span", { key: '90cb59742f5f9feb4f1a95ecc11fdb0f6626c1b4', class: "help-text" }, i18next.t('nylasEventTitle.helpText', { context: 'start', field: i18next.t('nylasEventTitle.title') }), " ", h("code", { key: '4ccb07d90b5366e29b7ec041d9ea96e2dbe2f17f' }, "$"), ' ', i18next.t('nylasEventTitle.helpText', { context: 'end' }), h("span", { key: '762784688425f7c75c00d02650602d55a4c39a7f', class: "label-icon" }, h("tooltip-component", { key: '6c896cb600dfb33eea7d3d34d02dbf4957daaccb' }, h("info-icon", { key: '8510b9ff47f14773f3c156b01d9ee692a2e23b9d', slot: "tooltip-icon" }), h("span", { key: '55dc64d424f76c3e53380957d2a2194161509c05', slot: "tooltip-content" }, i18next.t('nylasEventTitle.tooltip.desc'), " ", h("code", { key: '02cacd5eca30da22d0ea5a74991238d3a0b68524' }, '${invitee}'))))), this.validationError != '' && h("span", { class: "error-message" }, this.validationError))));
    }
    static get is() { return "nylas-event-title"; }
    static get encapsulation() { return "shadow"; }
    static get formAssociated() { return true; }
    static get originalStyleUrls() {
        return {
            "$": ["nylas-event-title.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["nylas-event-title.css"]
        };
    }
    static get properties() {
        return {
            "selectedConfiguration": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "Configuration",
                    "resolved": "Configuration | undefined",
                    "references": {
                        "Configuration": {
                            "location": "import",
                            "path": "@nylas/core",
                            "id": "../nylas-js-core/dist/index.d.ts::Configuration"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [{
                            "name": "standalone",
                            "text": "The selected config"
                        }],
                    "text": ""
                }
            },
            "eventTitle": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [{
                            "name": "standalone",
                            "text": "The title of the event from the cofiguration."
                        }],
                    "text": ""
                },
                "attribute": "event-title",
                "reflect": false,
                "defaultValue": "this.selectedConfiguration?.event_booking?.title"
            },
            "name": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "standalone",
                            "text": "The name attribute of this component."
                        }],
                    "text": ""
                },
                "attribute": "name",
                "reflect": false,
                "defaultValue": "'title'"
            },
            "selectedLanguage": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "LANGUAGE_CODE",
                    "resolved": "LANGUAGE_CODE.de | LANGUAGE_CODE.en | LANGUAGE_CODE.es | LANGUAGE_CODE.fr | LANGUAGE_CODE.ja | LANGUAGE_CODE.nl | LANGUAGE_CODE.sv | LANGUAGE_CODE.zh | undefined",
                    "references": {
                        "LANGUAGE_CODE": {
                            "location": "import",
                            "path": "@/common/constants",
                            "id": "src/common/constants.ts::LANGUAGE_CODE"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The selected language."
                },
                "attribute": "selected-language",
                "reflect": false
            }
        };
    }
    static get states() {
        return {
            "showTokens": {},
            "availableTokens": {},
            "filteredTokens": {},
            "ariaActivedescendant": {},
            "currentWord": {},
            "validationError": {},
            "configEventTitle": {},
            "additionalFieldTokens": {}
        };
    }
    static get events() {
        return [{
                "method": "valueChanged",
                "name": "valueChanged",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "This event is fired when the value of the event title changes."
                },
                "complexType": {
                    "original": "{\n    value: string;\n    name: string;\n  }",
                    "resolved": "{ value: string; name: string; }",
                    "references": {}
                }
            }];
    }
    static get elementRef() { return "host"; }
    static get watchers() {
        return [{
                "propName": "name",
                "methodName": "elementNameChangedHandler"
            }, {
                "propName": "ariaActivedescendant",
                "methodName": "ariaActivedescendantChangedHandler"
            }, {
                "propName": "selectedConfiguration",
                "methodName": "configChangedHandler"
            }, {
                "propName": "selectedLanguage",
                "methodName": "selectedLanguageChangedHandler"
            }];
    }
    static get listeners() {
        return [{
                "name": "formSubmitted",
                "method": "formSubmittedHandler",
                "target": "window",
                "capture": false,
                "passive": false
            }, {
                "name": "valueChanged",
                "method": "valueChangedHandler",
                "target": "document",
                "capture": false,
                "passive": false
            }];
    }
    static get attachInternalsMemberName() { return "internals"; }
}
__decorate([
    RegisterComponent({
        name: 'nylas-event-title',
        stateToProps: new Map([
            ['schedulerConfig.selectedConfiguration', 'selectedConfiguration'],
            ['schedulerConfig.selectedLanguage', 'selectedLanguage'],
        ]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NylasEventTitle.prototype, "render", null);
//# sourceMappingURL=nylas-event-title.js.map
