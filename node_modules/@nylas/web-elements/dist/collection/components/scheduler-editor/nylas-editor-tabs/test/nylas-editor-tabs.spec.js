import { newSpecPage } from "@stencil/core/testing";
import { NylasEditorTabs } from "../nylas-editor-tabs";
import { h } from "@stencil/core";
import { selectedConfiguration } from "../../../../utils/test-utils";
import ExpressFlow from "../../nylas-scheduler-editor/ExpressFlow";
import { NylasBookingCalendarPicker } from "../../nylas-booking-calendar-picker/nylas-booking-calendar-picker";
import { SelectDropdown } from "../../../design-system/select-dropdown/select-dropdown";
import { ButtonComponent } from "../../../design-system/button-component/button-component";
describe('nylas-scheduler-editor', () => {
    let nylasEditorTabs;
    let page;
    beforeEach(async () => {
        page = await newSpecPage({
            autoApplyChanges: true,
            components: [NylasEditorTabs],
            template: () => {
                return (h("nylas-editor-tabs", { mode: "composable" }, h(ExpressFlow, { currentUser: {
                        id: '123',
                        email: 'johndoe@example.com',
                        name: 'John Doe',
                    }, calendars: [
                        {
                            id: '123',
                            name: 'John Doe',
                            email: 'johndoe@example.com',
                        },
                    ], selectedConfiguration: JSON.parse(JSON.stringify(selectedConfiguration)) })));
            },
        });
        nylasEditorTabs = page.rootInstance;
        const formMock = {
            checkValidity: jest.fn().mockReturnValue(true),
            acceptCharset: '',
            action: '',
            autocomplete: '',
            elements: {},
            encoding: '',
            enctype: '',
            length: 0,
            method: '',
            name: '',
            noValidate: false,
            target: '',
            reset: jest.fn(),
            submit: jest.fn(),
        };
        nylasEditorTabs.formRef = formMock;
        nylasEditorTabs.updateFormState = jest.fn().mockReturnValue(JSON.parse(JSON.stringify(selectedConfiguration)));
        nylasEditorTabs.action = 'create';
    });
    it('renders', async () => {
        expect(page.root).toMatchSnapshot();
    });
    it('submit form', async () => {
        const checkErrorSpy = jest.spyOn(nylasEditorTabs, 'checkForOrganizerConfirmationError');
        const event = new Event('submit');
        await nylasEditorTabs.formSubmissionHandler(event);
        expect(checkErrorSpy).toHaveBeenCalled();
        expect(checkErrorSpy).toHaveReturnedWith(false);
    });
});
describe('nylas-scheduler-editor edit', () => {
    const radio_field = {
        type: 'radio_button',
        required: false,
        order: 1,
        options: ['yes', ''],
        label: 'Radio Button Label',
    };
    const dropdown = {
        type: 'dropdown',
        required: false,
        order: 1,
        options: ['yes', ''],
        label: 'Dropdown Label',
    };
    const formState = {
        title: 'no org confirm',
        description: '',
        duration: '30',
        availability: {
            openHours: [
                {
                    days: [1, 2, 3, 4, 5],
                    start: '09:00',
                    end: '17:00',
                    timezone: 'America/Toronto',
                },
            ],
            timezone: 'America/Toronto',
        },
        additionalFields: {},
        conferencing: {},
        calendarIds: ['primary'],
        participants: [
            {
                email: 'user@nylas.com',
                is_organizer: true,
                name: '',
                availability: {
                    calendar_ids: ['primary'],
                },
                booking: {
                    calendar_id: 'user@nylas.com',
                },
                timezone: 'America/Toronto',
            },
        ],
        bookingCalendar: 'user@nylas.com',
        location: '',
        bookingType: 'booking',
        buffer: {
            before: 0,
            after: 0,
        },
        cancellationPolicy: '',
        availableDaysInFuture: 30,
        minCancellationNotice: 0,
        minBookingNotice: 60,
        timeslotInterval: {
            interval: 30,
        },
        additionalGuestsHidden: false,
        hideCancellationOptions: false,
        hideReschedulingOptions: false,
        participantBookingCalendars: {
            email: 'user@nylas.com',
            is_organizer: true,
            name: '',
            availability: {
                calendar_ids: ['primary'],
            },
            booking: {
                calendar_id: 'user@nylas.com',
            },
            timezone: 'America/Toronto',
        },
        participantCalendars: {
            'user@nylas.com': ['primary'],
        },
        emailTemplate: {
            logo: '',
            booking_confirmed: {},
        },
        redirectUrl: '',
        slug: 'dyewgafhjahjerfghjaerf',
        appearance: null,
        availabilityMethod: 'collective',
    };
    let nylasEditorTabs;
    let page;
    beforeEach(async () => {
        page = await newSpecPage({
            autoApplyChanges: true,
            components: [NylasEditorTabs],
            template: () => {
                return h("nylas-editor-tabs", { mode: "app", selectedConfiguration: JSON.parse(JSON.stringify(selectedConfiguration)) });
            },
        });
        nylasEditorTabs = page.rootInstance;
        const formMock = {
            checkValidity: jest.fn().mockReturnValue(true),
            acceptCharset: '',
            action: '',
            autocomplete: '',
            elements: {},
            encoding: '',
            enctype: '',
            length: 0,
            method: '',
            name: '',
            noValidate: false,
            target: '',
            reset: jest.fn(),
            submit: jest.fn(),
        };
        nylasEditorTabs.formRef = formMock;
        nylasEditorTabs.action = 'edit';
    });
    it('should give form error if radio option is not filled', async () => {
        const checkErrorSpy = jest.spyOn(nylasEditorTabs, 'checkForBookingFormErrors');
        const setErrorSpy = jest.spyOn(nylasEditorTabs, 'setError');
        const event = new Event('submit');
        nylasEditorTabs.updateFormState = jest.fn().mockReturnValue({
            ...JSON.parse(JSON.stringify(formState)),
            additionalFields: {
                radio_field: { ...radio_field, options: ['yes', ''] },
            },
        });
        await nylasEditorTabs.setActiveTab(new Event('click'), 'bookingForm');
        await nylasEditorTabs.formSubmissionHandler(event);
        expect(checkErrorSpy).toHaveBeenCalled();
        expect(checkErrorSpy).toHaveReturnedWith(true);
        expect(setErrorSpy).toHaveBeenCalled();
        nylasEditorTabs.updateFormState = jest.fn().mockReturnValue({
            ...JSON.parse(JSON.stringify(formState)),
            additionalFields: {
                dropdown: { ...dropdown, options: ['yes', ''] },
            },
        });
        await nylasEditorTabs.formSubmissionHandler(event);
        expect(checkErrorSpy).toHaveBeenCalled();
        expect(checkErrorSpy).toHaveReturnedWith(true);
        expect(setErrorSpy).toHaveBeenCalled();
    });
    it('should not give form error if radio / dropdown options are filled', async () => {
        const checkErrorSpy = jest.spyOn(nylasEditorTabs, 'checkForBookingFormErrors');
        const event = new Event('submit');
        const setErrorSpy = jest.spyOn(nylasEditorTabs, 'setError');
        nylasEditorTabs.updateFormState = jest.fn().mockReturnValue({
            ...JSON.parse(JSON.stringify(formState)),
            additionalFields: {
                radio_field: { ...radio_field, options: ['yes', 'no'] },
            },
        });
        await nylasEditorTabs.formSubmissionHandler(event);
        expect(checkErrorSpy).toHaveBeenCalled();
        expect(checkErrorSpy).toHaveReturnedWith(false);
        expect(setErrorSpy).not.toHaveBeenCalled();
        nylasEditorTabs.updateFormState = jest.fn().mockReturnValue({
            ...JSON.parse(JSON.stringify(formState)),
            additionalFields: {
                dropdown: { ...dropdown, options: ['yes', 'no'] },
            },
        });
        await nylasEditorTabs.formSubmissionHandler(event);
        expect(checkErrorSpy).toHaveBeenCalled();
        expect(checkErrorSpy).toHaveReturnedWith(false);
        expect(setErrorSpy).not.toHaveBeenCalled();
    });
});
describe('nylas-scheduler-editor create flow', () => {
    let nylasEditorTabs;
    let page;
    beforeEach(async () => {
        page = await newSpecPage({
            autoApplyChanges: true,
            components: [SelectDropdown, ButtonComponent, NylasBookingCalendarPicker, NylasEditorTabs],
            template: () => {
                return (h("nylas-editor-tabs", { mode: "composable" }, h(ExpressFlow, { currentUser: {
                        id: 'abc',
                        email: 'johndoe@example.com',
                        name: 'John Doe',
                    }, calendars: [
                        {
                            id: '123',
                            name: 'John Doe calendar',
                            email: 'johndoe@example.com',
                        },
                        {
                            id: '456',
                            name: 'Jane Doe',
                            email: 'janedoe@example.com',
                        },
                    ], selectedConfiguration: JSON.parse(JSON.stringify({
                        requires_session_auth: false,
                        scheduler: {
                            rescheduling_url: 'https://book.nylas.com/us/reschedule/:booking_ref',
                            cancellation_url: 'https://book.nylas.com/us/cancel/:booking_ref',
                            organizer_confirmation_url: 'https://book.nylas.com/us/confirm/:booking_ref',
                        },
                    })) })));
            },
        });
        nylasEditorTabs = page.rootInstance;
        const formMock = {
            checkValidity: jest.fn().mockReturnValue(true),
            acceptCharset: '',
            action: '',
            autocomplete: '',
            elements: {},
            encoding: '',
            enctype: '',
            length: 0,
            method: '',
            name: '',
            noValidate: false,
            target: '',
            reset: jest.fn(),
            submit: jest.fn(),
        };
        nylasEditorTabs.formRef = formMock;
        nylasEditorTabs.updateFormState = jest.fn().mockReturnValue(JSON.parse(JSON.stringify({
            event_booking: {
                title: 'test',
            },
            slug: 'dyewgafhjahjerfghjaerf',
        })));
        nylasEditorTabs.action = 'create';
    });
    it('renders', async () => {
        expect(page.root).toMatchSnapshot();
    });
    it('selects the first calendar if no primary calendar is available', async () => {
        const calendarPicker = page.root.querySelector('nylas-booking-calendar-picker');
        const calendarDropdown = calendarPicker.shadowRoot.querySelector('select-dropdown');
        const calendarDropdownButton = calendarDropdown.shadowRoot.querySelector('button');
        expect(calendarDropdownButton.textContent).toBe('John Doe calendar');
    });
});
describe('nylas-scheduler-editor test config merging', () => {
    let nylasEditorTabs;
    let page;
    beforeEach(async () => {
        page = await newSpecPage({
            autoApplyChanges: true,
            components: [NylasEditorTabs],
            template: () => {
                return h("nylas-editor-tabs", { mode: "app", selectedConfiguration: JSON.parse(JSON.stringify(selectedConfiguration)) });
            },
        });
        nylasEditorTabs = page.rootInstance;
        const formMock = {
            checkValidity: jest.fn().mockReturnValue(true),
            acceptCharset: '',
            action: '',
            autocomplete: '',
            elements: {},
            encoding: '',
            enctype: '',
            length: 0,
            method: '',
            name: '',
            noValidate: false,
            target: '',
            reset: jest.fn(),
            submit: jest.fn(),
        };
        nylasEditorTabs.formRef = formMock;
        nylasEditorTabs.action = 'edit';
        nylasEditorTabs.selectedConfiguration = selectedConfiguration;
    });
    it('should merge selectedConfiguration into configObject', async () => {
        const formState = {
            ...selectedConfiguration,
            slug: 'dyewgafhjahjerfghjaerf',
        };
        nylasEditorTabs.updateFormState = jest.fn().mockReturnValue(formState);
        const event = new Event('submit');
        await nylasEditorTabs.formSubmissionHandler(event);
        const emitSpy = jest.spyOn(nylasEditorTabs.schedulerConfigChanged, 'emit');
        await nylasEditorTabs.formSubmissionHandler(new Event('submit'));
        const finalConfig = emitSpy.mock.calls[0] && emitSpy.mock.calls[0][0] ? emitSpy.mock.calls[0][0].config : undefined;
        expect(finalConfig).toEqual(expect.objectContaining({
            slug: 'dyewgafhjahjerfghjaerf',
        }));
    });
});
describe('nylas-scheduler-editor test default timezone', () => {
    let nylasEditorTabs;
    let page;
    beforeEach(async () => {
        page = await newSpecPage({
            autoApplyChanges: true,
            components: [NylasEditorTabs],
            template: () => {
                return h("nylas-editor-tabs", { mode: "app", selectedConfiguration: JSON.parse(JSON.stringify(selectedConfiguration)) });
            },
        });
        nylasEditorTabs = page.rootInstance;
        const formMock = {
            checkValidity: jest.fn().mockReturnValue(true),
            acceptCharset: '',
            action: '',
            autocomplete: '',
            elements: {},
            encoding: '',
            enctype: '',
            length: 0,
            method: '',
            name: '',
            noValidate: false,
            target: '',
            reset: jest.fn(),
            submit: jest.fn(),
        };
        nylasEditorTabs.formRef = formMock;
        nylasEditorTabs.action = 'edit';
        nylasEditorTabs.selectedConfiguration = selectedConfiguration;
    });
    it('should set default participant timezone from the selected configuration if no openhours are present', async () => {
        const formState = {
            ...selectedConfiguration,
            availability: {
                timezone: 'America/Toronto',
            },
            participants: [
                {
                    email: 'test@test.com',
                    is_organizer: true,
                    name: '',
                    availability: {
                        calendar_ids: ['user@nylas.com'],
                    },
                    booking: {
                        calendar_id: 'user@nylas.com',
                    },
                },
            ],
        };
        nylasEditorTabs.updateFormState = jest.fn().mockReturnValue(formState);
        const event = new Event('submit');
        await nylasEditorTabs.formSubmissionHandler(event);
        const emitSpy = jest.spyOn(nylasEditorTabs.schedulerConfigChanged, 'emit');
        await nylasEditorTabs.formSubmissionHandler(new Event('submit'));
        const finalConfig = emitSpy.mock.calls[0] && emitSpy.mock.calls[0][0] ? emitSpy.mock.calls[0][0].config : undefined;
        expect(finalConfig?.participants).toEqual(expect.arrayContaining([
            {
                availability: { calendar_ids: ['user@nylas.com'], open_hours: [] },
                booking: { calendar_id: 'user@nylas.com' },
                email: 'test@test.com',
                is_organizer: true,
                name: '',
                timezone: 'America/Toronto',
            },
        ]));
    });
});
//# sourceMappingURL=nylas-editor-tabs.spec.js.map
