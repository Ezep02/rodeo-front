var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
import { RegisterComponent } from "../../../common/register-component";
import { debug, getBrowser, isNonPrintableKey, sanitize } from "../../../utils/utils";
import { Host, h } from "@stencil/core";
import i18next from "../../../utils/i18n";
import { EVENT_TITLE_TOKENS as eventDescriptionTokens } from "../../../common/constants";
export class NylasEventDescription {
    constructor() {
        this.selectedConfiguration = undefined;
        this.eventDescription = this.selectedConfiguration?.event_booking?.description;
        this.name = 'description';
        this.selectedLanguage = undefined;
        this.description = this.eventDescription || this.selectedConfiguration?.event_booking?.description || '';
        this.showTokens = false;
        this.availableTokens = eventDescriptionTokens.map(token => ({
            label: token.token,
            value: token.value,
            labelHTML: token,
        }));
        this.filteredTokens = this.availableTokens;
        this.ariaActivedescendant = '';
        this.currentWord = { $value: '', fullText: '', index: -1, focusOffset: -1 };
        this.validationError = '';
        this.additionalFieldTokens = [];
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-event-description', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-custom-booking-flow', 'selectedConfigurationChangedHandler', newValue);
        const description = newValue?.event_booking?.description || '';
        const additionalFields = newValue?.scheduler?.additional_fields || {};
        const newKeys = Object.keys(additionalFields) || [];
        const newTokens = newKeys.map(key => {
            return {
                token: `\$${key}`,
                value: `\${${key}}`,
                description: additionalFields[key].label || '',
            };
        });
        this.additionalFieldTokens = [...newTokens];
        this.availableTokens = [...eventDescriptionTokens, ...newTokens].map(token => ({
            label: token.token,
            value: token.value,
            labelHTML: token,
        }));
        this.filteredTokens = [...this.availableTokens];
        this.description = description;
        if (description) {
            this.updateEventDescriptionFromProp(description);
        }
    }
    selectedLanguageChangedHandler(newVal, oldVal) {
        if (newVal === oldVal)
            return;
        i18next.changeLanguage(newVal);
    }
    connectedCallback() {
        debug('nylas-event-description', 'connectedCallback');
    }
    componentWillLoad() {
        debug('nylas-event-description', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-event-description', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.description = this.eventDescription || '';
        }
    }
    disconnectedCallback() {
        debug('nylas-event-description', 'disconnectedCallback');
    }
    valueChangedHandler(event) {
        const { name, value } = event.detail;
        const additionalFields = value || {};
        if (name === 'additional-fields') {
            const newKeys = Object.keys(additionalFields) || [];
            const newTokens = newKeys.map(key => {
                return {
                    token: `\$${key}`,
                    value: `\${${key}}`,
                    description: additionalFields[key].label || '',
                };
            });
            this.additionalFieldTokens = [...newTokens];
            this.availableTokens = [...eventDescriptionTokens, ...newTokens].map(token => ({
                label: token.token,
                value: token.value,
                labelHTML: token,
            }));
            this.filteredTokens = [...this.availableTokens];
        }
    }
    updateEventDescriptionFromProp(newValue) {
        debug('nylas-event-description', 'updateEventDescriptionFromProp', newValue);
        const description = newValue || this.description;
        if (this.descriptionRef) {
            this.descriptionRef.innerHTML = this.highlightTokens(description);
        }
    }
    highlightTokens(description) {
        let outputHtml = description;
        [...eventDescriptionTokens, ...this.additionalFieldTokens].forEach(tokenObj => {
            const token = tokenObj.value;
            const regex = new RegExp(`(\\${token})(?!\\w)`, 'g');
            outputHtml = outputHtml?.replace(regex, '<span class="highlighted-tag">$1</span>') || '';
        });
        return outputHtml;
    }
    getCurrentSelectionForBrowser() {
        const getSelectionTextData = (nodeValue, offset, node, allSelected) => {
            const text = nodeValue.replace(/[\u200B-\u200D\uFEFF]/g, '');
            const dollarIndex = text.lastIndexOf('$');
            const lastWord = text.substring(dollarIndex).split(' ')[0];
            return {
                focusOffset: offset,
                dollarIndex,
                lastWord,
                currentText: text,
                node,
                allSelected,
            };
        };
        const isAllSelected = (selection) => selection.anchorOffset === 0 && selection.focusOffset === selection.focusNode?.nodeValue?.length;
        const currentBrowser = getBrowser();
        switch (currentBrowser) {
            case 'Chrome':
                const shadowRootSelection = this.host.shadowRoot?.getSelection();
                const focusNode = shadowRootSelection?.focusNode;
                const focusNodeValue = focusNode?.nodeValue || '';
                const allSelected = shadowRootSelection && isAllSelected(shadowRootSelection);
                return getSelectionTextData(focusNodeValue, shadowRootSelection?.focusOffset || -1, focusNode, allSelected);
            case 'Firefox':
                const selection = document.getSelection();
                const anchorNodeValue = selection?.anchorNode?.nodeValue || '';
                const allSelectedFirefox = selection && isAllSelected(selection);
                return getSelectionTextData(anchorNodeValue, selection?.focusOffset || -1, selection?.anchorNode, allSelectedFirefox);
            case 'Safari':
                const windowSelection = window.getSelection();
                const anchorNode = windowSelection?.getComposedRanges(this.host.shadowRoot)[0];
                const currentText = anchorNode?.startContainer?.nodeValue || '';
                const allSelectedSafari = windowSelection && isAllSelected(windowSelection);
                return getSelectionTextData(currentText, anchorNode?.endOffset || -1, anchorNode?.startContainer, allSelectedSafari);
            default:
                console.warn('Browser not supported');
                return null;
        }
    }
    handleChange(event) {
        let textContent = event.target.textContent || '';
        textContent = sanitize(textContent);
        const currentSelection = this.getCurrentSelectionForBrowser();
        if (!currentSelection) {
            this.updateEventDescription(textContent);
            this.resetDropdown();
            return;
        }
        const { focusOffset, dollarIndex, lastWord, currentText } = currentSelection;
        if (dollarIndex === -1 || focusOffset < dollarIndex) {
            this.updateEventDescription(textContent);
            this.resetDropdown();
            return;
        }
        if (lastWord.startsWith('$')) {
            this.showTokens = true;
            this.currentWord = {
                $value: lastWord,
                fullText: currentText,
                index: dollarIndex,
                focusOffset,
            };
            this.populateSuggestionsDropdown(lastWord);
        }
        else {
            this.resetDropdown();
        }
        this.updateEventDescription(textContent);
    }
    handleInputKeyDown(event) {
        const selection = this.getCurrentSelectionForBrowser();
        if (selection?.allSelected && !isNonPrintableKey(event)) {
            this.descriptionRef.innerHTML = '';
        }
        if (event.key === 'Enter') {
            event.preventDefault();
            const activeOption = this.host.shadowRoot?.getElementById(this.ariaActivedescendant);
            if (activeOption) {
                activeOption.click();
                this.ariaActivedescendant = '';
            }
        }
        else if (event.key === 'ArrowDown') {
            event.preventDefault();
            const activeOption = this.host.shadowRoot?.getElementById(this.ariaActivedescendant);
            if (activeOption) {
                const nextOption = activeOption.nextElementSibling;
                if (nextOption) {
                    this.ariaActivedescendant = nextOption.id;
                }
                else {
                    this.ariaActivedescendant = this.filteredTokens[0].label;
                }
            }
            else {
                this.ariaActivedescendant = this.filteredTokens[0].label;
            }
        }
        else if (event.key === 'ArrowUp') {
            event.preventDefault();
            const activeOption = this.host.shadowRoot?.getElementById(this.ariaActivedescendant);
            if (activeOption) {
                const prevOption = activeOption.previousElementSibling;
                if (prevOption) {
                    this.ariaActivedescendant = prevOption.id;
                }
                else {
                    this.ariaActivedescendant = this.filteredTokens[this.filteredTokens.length - 1].label;
                }
            }
            else {
                this.ariaActivedescendant = this.filteredTokens[this.filteredTokens.length - 1].label;
            }
        }
        else if (event.key === 'Escape') {
            event.preventDefault();
            this.resetDropdown();
        }
        else if (event.key === 'Backspace' || event.key === 'Delete') {
            const parentNode = selection?.node?.parentNode;
            if (selection?.currentText.startsWith('${') && parentNode && parentNode.nodeName === 'SPAN') {
                event.preventDefault();
                parentNode.removeChild(selection.node);
                parentNode.remove();
                this.resetDropdown();
            }
            if (this.descriptionRef.textContent === '' || selection?.allSelected) {
                this.descriptionRef.innerHTML = '';
                this.updateEventDescription('');
            }
        }
    }
    selectOption(e, option) {
        e.preventDefault();
        const word = this.currentWord.fullText;
        const dollarWord = this.currentWord.$value;
        let currentNode = this.descriptionRef.firstChild;
        let textNode = null;
        while (currentNode) {
            if (currentNode.nodeType === 3) {
                const currentNodeText = currentNode.textContent?.replace(/[\u200B-\u200D\uFEFF]/g, '') || '';
                const wordText = word.replace(/[\u200B-\u200D\uFEFF]/g, '');
                if (currentNodeText.includes(wordText)) {
                    textNode = currentNode;
                    break;
                }
            }
            currentNode = currentNode.nextSibling;
        }
        if (!textNode) {
            return;
        }
        const text = textNode.textContent || '';
        const index = text.indexOf(dollarWord);
        const textBefore = text.substring(0, index);
        const textAfter = text.substring(index + dollarWord.length);
        const newTextNode = document.createTextNode(textBefore);
        const newRange = document.createRange();
        const tagSpan = document.createElement('span');
        tagSpan.classList.add('highlighted-tag');
        tagSpan.textContent = `${option.value}`;
        const newTextNodeAfter = document.createTextNode(textAfter);
        if (textAfter !== '') {
            textNode.replaceWith(newTextNode, tagSpan, newTextNodeAfter);
            newRange.setStart(newTextNodeAfter, 1);
        }
        else {
            const afterNode = document.createTextNode('\u200B');
            textNode.replaceWith(newTextNode, tagSpan, afterNode);
            newRange.setStart(afterNode, 1);
        }
        this.resetDropdown();
        this.descriptionRef.focus();
        const sel = window.getSelection();
        newRange.collapse(true);
        sel?.removeAllRanges();
        sel?.addRange(newRange);
        this.updateEventDescription(this.descriptionRef.textContent || '');
    }
    populateSuggestionsDropdown(query = '') {
        this.filteredTokens = this.availableTokens.filter(obj => {
            return obj.label.startsWith(query.toString()) || obj.value.startsWith(query.toString());
        });
        if (this.filteredTokens.length > 0) {
            this.ariaActivedescendant = this.filteredTokens[0].label;
        }
    }
    get isInternalsAvailable() {
        return typeof this.internals !== 'undefined' && typeof this.internals.setValidity === 'function' && typeof this.internals.setFormValue === 'function';
    }
    updateEventDescription(text) {
        const value = text.replace(/ +/g, ' ');
        this.isInternalsAvailable && this.internals?.setFormValue(value, this.name);
        this.valueChanged.emit({ value: value, name: this.name });
    }
    resetDropdown() {
        this.showTokens = false;
        this.ariaActivedescendant = '';
    }
    getLabelHTML(token) {
        return (h("div", { class: "token-label" }, h("span", { class: "token" }, token.token), h("span", { class: "description" }, token.description)));
    }
    render() {
        return (h(Host, { key: '8b4913f5335b683eb20c2dcad08e6bf7d51fbfc7' }, h("div", { key: '3500070d6310d91ff27d2dd27b1a404e55f302bf', class: "nylas-event-description", part: "nedesc" }, h("label", { key: '9e4adbd5e0e89f3b09d65aefcb2b25f917760c91', htmlFor: "description" }, i18next.t('nylasEventDescription.headerTitle'), h("span", { key: '671f9cb5866a6fa6ee5d290abfeee2aab063b404', class: "label-icon" }, h("tooltip-component", { key: 'e931671a86e9286bb7a65deab016d502b0caf05a' }, h("info-icon", { key: 'f7f7745e60afd89122ed623a26a6a83bb62a3452', slot: "tooltip-icon" }), h("span", { key: '0ae1140d554c5d9c2d080dab390c393d60f968e8', slot: "tooltip-content" }, i18next.t('nylasEventDescription.tooltip.desc'))))), h("div", { key: '8a696082ddf7d0a02ae321aa4bf9bff4257fb175', id: "event-description", class: { 'event-description': true }, part: "nedesc__textarea", contentEditable: "true", onInput: e => this.handleChange(e), onKeyDown: event => this.handleInputKeyDown(event), ref: el => (this.descriptionRef = el) }), this.showTokens && this.filteredTokens?.length > 0 && (h("div", { class: "token-options", part: "nedesc__dropdown-content" }, h("ul", { tabindex: "-1", role: "listbox", "aria-label": this.name, "aria-activedescendant": this.ariaActivedescendant }, this.filteredTokens.map(option => (h("li", { tabindex: "0", key: option.label, id: option.label, class: { active: this.ariaActivedescendant === option.label }, onClick: e => this.selectOption(e, option), role: "option" }, this.getLabelHTML(option.labelHTML))))))), h("span", { key: '7e7b0ccdcd51db7cde89ef9f5bf3c202d62f1ac3', class: "help-text" }, i18next.t('nylasEventTitle.helpText', { context: 'start', field: i18next.t('nylasEventTitle.description') }), " ", h("code", { key: '5e9b9b6f5ad50aa3cb78a9bec621db7ad3878758' }, "$"), ' ', i18next.t('nylasEventTitle.helpText', { context: 'end' }), h("span", { key: 'abe23b6835fe9d0f7aef9a81897809669163a2a5', class: "label-icon" }, h("tooltip-component", { key: 'fc1297d3839f01f478e85c2ce0eeb5bf22b9b6eb' }, h("info-icon", { key: '8e8fa87ac1060ec2f6a7fb656bc9d22908450299', slot: "tooltip-icon" }), h("span", { key: 'c37ffca9c75e862a486c5f6e9a553dd94546ad9f', slot: "tooltip-content" }, i18next.t('nylasEventTitle.tooltip.desc'), " ", h("code", { key: '85835b17c04e36bfea09b0343f05fdae28104eb8' }, '${invitee}'))))))));
    }
    static get is() { return "nylas-event-description"; }
    static get encapsulation() { return "shadow"; }
    static get formAssociated() { return true; }
    static get originalStyleUrls() {
        return {
            "$": ["nylas-event-description.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["nylas-event-description.css"]
        };
    }
    static get properties() {
        return {
            "selectedConfiguration": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "Configuration",
                    "resolved": "Configuration | undefined",
                    "references": {
                        "Configuration": {
                            "location": "import",
                            "path": "@nylas/core",
                            "id": "../nylas-js-core/dist/index.d.ts::Configuration"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [{
                            "name": "standalone",
                            "text": "The selected config"
                        }],
                    "text": ""
                }
            },
            "eventDescription": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [{
                            "name": "standalone",
                            "text": "The event description stored in the configuration"
                        }],
                    "text": ""
                },
                "attribute": "event-description",
                "reflect": false,
                "defaultValue": "this.selectedConfiguration?.event_booking?.description"
            },
            "name": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "standalone",
                            "text": "The name of the event description input."
                        }],
                    "text": ""
                },
                "attribute": "name",
                "reflect": false,
                "defaultValue": "'description'"
            },
            "selectedLanguage": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "LANGUAGE_CODE",
                    "resolved": "LANGUAGE_CODE.de | LANGUAGE_CODE.en | LANGUAGE_CODE.es | LANGUAGE_CODE.fr | LANGUAGE_CODE.ja | LANGUAGE_CODE.nl | LANGUAGE_CODE.sv | LANGUAGE_CODE.zh | undefined",
                    "references": {
                        "LANGUAGE_CODE": {
                            "location": "import",
                            "path": "@/common/constants",
                            "id": "src/common/constants.ts::LANGUAGE_CODE"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The selected language."
                },
                "attribute": "selected-language",
                "reflect": false
            }
        };
    }
    static get states() {
        return {
            "description": {},
            "showTokens": {},
            "availableTokens": {},
            "filteredTokens": {},
            "ariaActivedescendant": {},
            "currentWord": {},
            "validationError": {},
            "additionalFieldTokens": {}
        };
    }
    static get events() {
        return [{
                "method": "valueChanged",
                "name": "valueChanged",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Event emitted when the event description changes."
                },
                "complexType": {
                    "original": "{\n    value: string;\n    name: string;\n  }",
                    "resolved": "{ value: string; name: string; }",
                    "references": {}
                }
            }];
    }
    static get elementRef() { return "host"; }
    static get watchers() {
        return [{
                "propName": "name",
                "methodName": "elementNameChangedHandler"
            }, {
                "propName": "selectedConfiguration",
                "methodName": "selectedConfigurationChangedHandler"
            }, {
                "propName": "selectedLanguage",
                "methodName": "selectedLanguageChangedHandler"
            }];
    }
    static get listeners() {
        return [{
                "name": "valueChanged",
                "method": "valueChangedHandler",
                "target": "document",
                "capture": false,
                "passive": false
            }];
    }
    static get attachInternalsMemberName() { return "internals"; }
}
__decorate([
    RegisterComponent({
        name: 'nylas-event-description',
        stateToProps: new Map([
            ['schedulerConfig.selectedConfiguration', 'selectedConfiguration'],
            ['schedulerConfig.selectedLanguage', 'selectedLanguage'],
        ]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NylasEventDescription.prototype, "render", null);
//# sourceMappingURL=nylas-event-description.js.map
