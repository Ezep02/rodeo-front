import { l as nr, d as T, u as rr, m as hn } from "./index-cd93b584.js";
class sr {
  constructor(e, n, r = !0, s) {
    this.automaticComponentRegistration = !0, this.registeredComponents = {}, this.propStateRegistrations = /* @__PURE__ */ new Map(), this.eventListenerRegistrations = /* @__PURE__ */ new Map(), this.host = e, this.stores = n, this.automaticComponentRegistration = r, this.eventOverrides = s, T(`[${this.hostTagName}] Initializing (abstract) provider.`, { eventOverrides: s }), this.registerComponent = this.registerComponent.bind(this), this.getStore = this.getStore.bind(this), Object.keys(this.stores).forEach((i) => {
      this.propStateRegistrations.set(i, /* @__PURE__ */ new Map());
    });
  }
  async componentWillLoad(e) {
    T(`[${this.hostTagName}] Will load`), this.setupStoreListeners(), this.nylasConnector = e;
    const n = Array.from(this.host.querySelectorAll("*")).filter((s) => s.tagName.toLowerCase().startsWith("nylas-"));
    T(`[${this.hostTagName}] Found ${n.length} child component(s).`, { childComponents: n });
    const r = n.map(async (s) => {
      const i = s;
      if (!i) {
        T(`[~${this.hostTagName}] (componentWillLoad) Component ${i.tagName} does not have a name. Skipping.`);
        return;
      }
      if (!i.registerNylasComponent) {
        T(`[~${this.hostTagName}] (componentWillLoad) Component ${i.tagName} is not a component that can be registered. Skipping.`, { component: i });
        return;
      }
      const o = {
        element: i,
        name: i.tagName.toLowerCase(),
        getStoresToProp: i.getStoresToProp,
        storeToProps: i.storeToProps,
        stateToProps: i.stateToProps,
        authToProp: i.authToProp,
        eventToProps: i.eventToProps,
        connectorToProp: i.connectorToProp,
        localPropsToProp: i.localPropsToProp
      };
      await this.registerComponent(o);
    });
    await Promise.all(r);
  }
  async componentDidLoad() {
    T(`[~${this.hostTagName}] (componentDidLoad) Did load`);
  }
  async componentDisconnected() {
    Object.values(this.stores).forEach((e) => {
      e.dispose();
    });
  }
  async registerComponentHandler(e) {
    if (e.stopPropagation(), !this.automaticComponentRegistration) {
      T(`~[${this.hostTagName}] (registerComponentHandler) Automatic component registration disabled. Skipping registration of ${e.detail.name}.`);
      return;
    }
    await this.registerComponent(e.detail);
  }
  async unregisterComponentHandler(e) {
    if (e.stopPropagation(), !this.automaticComponentRegistration) {
      T(`~[${this.hostTagName}] (unregisterComponentHandler) Automatic component registration disabled. Skipping unregistration of ${e.detail.name}.`);
      return;
    }
    this.unregisterComponent(e.detail);
  }
  async registerComponent(e) {
    T(`~[${this.hostTagName}] (registerComponent) Registering component ${e.name}.`);
    const n = e.element.dataset.nylasId;
    if (n && this.registeredComponents[n]) {
      T(`[${this.hostTagName}] (registerComponent) Component ${e.name} already registered. Skipping.`);
      return;
    }
    T(`[${this.hostTagName}] (registerComponent) Checking if "${e.element.localName}" component is defined`, { component: e }), await customElements.whenDefined(e.element.tagName.toLowerCase());
    const { stateToProps: r, getStoresToProp: s, eventToProps: i, storeToProps: o, connectorToProp: u, localPropsToProp: a, element: c } = e;
    c.dataset.nylasId = rr(), this.registeredComponents[c.dataset.nylasId] = e;
    const d = this.eventOverrides;
    i == null || i.forEach((l, h) => {
      var y;
      const f = this.nylasConnector, m = async (g) => {
        T(`[${this.hostTagName}] (registerComponent) Handling "${e.name}" prop "${String(h)}" event.`, { event: g }), h in d && (T(`[${this.hostTagName}] (registerComponent) Found event override for "${String(h)}" event. Calling override.`), await d[h](g, f)), g.defaultPrevented || await l(g, f);
      }, p = e.element.dataset.nylasId;
      p && !this.eventListenerRegistrations.has(p) && this.eventListenerRegistrations.set(p, []), p && ((y = this.eventListenerRegistrations.get(p)) == null || y.push([c, h, m])), T(`[${this.hostTagName}] (registerComponent) Setting "${e.name}" event "${String(h)}" to automcially call NylasConnector method.`);
      const v = hn(h.toString());
      T(`[${this.hostTagName}] (registerComponent) Adding event listener for "${v}" on "${c.tagName}"`), c.addEventListener(v, m);
    }), r == null || r.forEach((l, h) => {
      var y, g, b, k;
      const [f, m] = h.split("."), v = this.getStore(f).state[m];
      if (!c.dataset.nylasId) {
        T(`[${this.hostTagName}] (registerComponent) Component "${e.name}" not registered. Skipping.`, { component: e });
        return;
      }
      this.propStateRegistrations.has(f) || this.propStateRegistrations.set(f, /* @__PURE__ */ new Map()), (y = this.propStateRegistrations.get(f)) != null && y.has(m) ? (k = (b = this.propStateRegistrations.get(f)) == null ? void 0 : b.get(m)) == null || k.push({
        elementId: c.dataset.nylasId,
        propKey: l
      }) : (g = this.propStateRegistrations.get(f)) == null || g.set(m, [
        {
          elementId: c.dataset.nylasId,
          propKey: l
        }
      ]), c[l.toString()] = v, T(`[${this.hostTagName}] Setting "${e.name}" prop "${l.toString()}" to "${h}" value.`, { stateValue: v });
    }), a == null || a.forEach((l, h) => {
      const f = this.host[h];
      c[l.toString()] = f, T(`[${this.hostTagName}] Setting "${e.name}" prop "${l.toString()}" to the value of "${h}" value.`, { value: h, mappedPropValue: f });
    }), s && (c[s == null ? void 0 : s.toString()] = this.getStore, T(`[${this.hostTagName}] Setting "${e.name}" prop "${s.toString()}" to "getStore" method.`)), o == null || o.forEach((l, h) => {
      const f = this.getStore(h);
      c[l.toString()] = f, T(`[${this.hostTagName}] Setting "${e.name}" prop "${l.toString()}" to "${h}" store.`, { store: f });
    }), u && (c[u == null ? void 0 : u.toString()] = this.nylasConnector, T(`[${this.hostTagName}] Setting "${e.name}" prop "${u.toString()}" to "nylasConnector" value.`, { connectorToProp: u })), typeof c.registerCallback == "function" && (T(`[${this.hostTagName}] (registerComponent) Calling registerCallback method for "${e.name}".`), await c.registerCallback()), T(`[${this.hostTagName}] (registerComponent) Component ${e.name} registered.`);
  }
  unregisterComponent(e) {
    T(`[${this.hostTagName}] Unregistering component ${e.name}.`);
    const n = e.element.dataset.nylasId;
    if (!n) {
      T(`[${this.hostTagName}] (unregisterComponent) Unregistering component ${e.name}.`);
      return;
    }
    if (this.registeredComponents[n]) {
      T(`[${this.hostTagName}] (unregisterComponent) Component ${e.name} not registered. Skipping.`);
      return;
    }
    this.propStateRegistrations.forEach((s, i) => {
      s.forEach((o, u) => {
        var d, l;
        const a = (d = this.propStateRegistrations.get(i)) == null ? void 0 : d.get(u), c = a == null ? void 0 : a.filter((h) => h.elementId !== n);
        c && ((l = this.propStateRegistrations.get(i)) == null || l.set(u, c));
      });
    });
    const r = this.eventListenerRegistrations.get(n);
    r == null || r.forEach(([s, i, o]) => {
      const u = hn(i.toString());
      T(`[${this.hostTagName}] (unregisterComponent) Removing event listener for "${u}" on "${s.tagName}"`), s.removeEventListener(u, o);
    }), delete this.registeredComponents[n];
  }
  getStore(e) {
    const n = this.stores[e];
    if (!n)
      throw new Error(`[${this.hostTagName}] Store "${e.toString()}" not found.`);
    return n;
  }
  async setupStoreListeners() {
    const e = this;
    Object.entries(this.stores).forEach(([n, r]) => {
      T(`[${e.hostTagName}] (setupStoreListeners) Listening for changes in "${n}" store.`), r.use({
        set(s, i, o) {
          var c;
          if (T(`[${e.hostTagName}] (setupStoreListeners) Store "${n}" state "${s.toString()}" changed`, { newValue: i, oldValue: o }), i === o) {
            T(`[${e.hostTagName}] (setupStoreListeners) Store "${n}" state "${s.toString()}" unchanged. Skipping.`);
            return;
          }
          const u = e.registeredComponents;
          if (!u) {
            T(`[${e.hostTagName}] (setupStoreListeners) No registered components found. Skipping.`);
            return;
          }
          const a = ((c = e.propStateRegistrations.get(n)) == null ? void 0 : c.get(s.toString())) || [];
          T(`[${e.hostTagName}] (setupStoreListeners) Found ${a.length} prop(s) registered for "${s.toString()}" store.`, {
            props: a,
            propStateRegistrations: e.propStateRegistrations
          }), a.forEach(({ elementId: d, propKey: l }) => {
            const h = u[d];
            if (!h) {
              T(`[${e.hostTagName}] (setupStoreListeners) Component "${d}" not found. Skipping.`, { component: h });
              return;
            }
            const m = e.getStore(n).state[s];
            h.element[l.toString()] = m, T(`[${e.hostTagName}] (setupStoreListeners) Setting "${h.name}" prop "${l.toString()}" to "${s.toString()}" value.`, { stateValue: m });
          });
        }
      });
    });
  }
  get hostTagName() {
    var e, n;
    return ((n = (e = this.host) == null ? void 0 : e.tagName) == null ? void 0 : n.toLowerCase()) ?? "nylas-provider";
  }
}
class ns extends sr {
}
var ir = Object.defineProperty, or = (t, e, n) => e in t ? ir(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Pt = (t, e, n) => (or(t, typeof e != "symbol" ? e + "" : e, n), n), ar = /* @__PURE__ */ ((t) => (t.Error = "error", t.Warning = "warning", t.Info = "info", t.Success = "success", t))(ar || {});
const rs = (t) => t !== null && typeof t == "object" && "error" in t;
async function dn(t) {
  const e = new TextEncoder().encode(t), n = await crypto.subtle.digest("SHA-256", e), r = Array.from(new Uint8Array(n)).map((s) => s.toString(16).padStart(2, "0")).join("");
  return btoa(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
const K = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : nr, N = Object.keys, M = Array.isArray;
function U(t, e) {
  return typeof e != "object" || N(e).forEach(function(n) {
    t[n] = e[n];
  }), t;
}
typeof Promise > "u" || K.Promise || (K.Promise = Promise);
const Be = Object.getPrototypeOf, ur = {}.hasOwnProperty;
function z(t, e) {
  return ur.call(t, e);
}
function Ce(t, e) {
  typeof e == "function" && (e = e(Be(t))), (typeof Reflect > "u" ? N : Reflect.ownKeys)(e).forEach((n) => {
    ee(t, n, e[n]);
  });
}
const Cn = Object.defineProperty;
function ee(t, e, n, r) {
  Cn(t, e, U(n && z(n, "get") && typeof n.get == "function" ? { get: n.get, set: n.set, configurable: !0 } : { value: n, configurable: !0, writable: !0 }, r));
}
function ke(t) {
  return { from: function(e) {
    return t.prototype = Object.create(e.prototype), ee(t.prototype, "constructor", t), { extend: Ce.bind(null, t.prototype) };
  } };
}
const lr = Object.getOwnPropertyDescriptor;
function Jt(t, e) {
  let n;
  return lr(t, e) || (n = Be(t)) && Jt(n, e);
}
const cr = [].slice;
function ut(t, e, n) {
  return cr.call(t, e, n);
}
function Pn(t, e) {
  return e(t);
}
function Ie(t) {
  if (!t)
    throw new Error("Assertion Failed");
}
function En(t) {
  K.setImmediate ? setImmediate(t) : setTimeout(t, 0);
}
function Tn(t, e) {
  return t.reduce((n, r, s) => {
    var i = e(r, s);
    return i && (n[i[0]] = i[1]), n;
  }, {});
}
function te(t, e) {
  if (z(t, e))
    return t[e];
  if (!e)
    return t;
  if (typeof e != "string") {
    for (var n = [], r = 0, s = e.length; r < s; ++r) {
      var i = te(t, e[r]);
      n.push(i);
    }
    return n;
  }
  var o = e.indexOf(".");
  if (o !== -1) {
    var u = t[e.substr(0, o)];
    return u === void 0 ? void 0 : te(u, e.substr(o + 1));
  }
}
function H(t, e, n) {
  if (t && e !== void 0 && (!("isFrozen" in Object) || !Object.isFrozen(t)))
    if (typeof e != "string" && "length" in e) {
      Ie(typeof n != "string" && "length" in n);
      for (var r = 0, s = e.length; r < s; ++r)
        H(t, e[r], n[r]);
    } else {
      var i = e.indexOf(".");
      if (i !== -1) {
        var o = e.substr(0, i), u = e.substr(i + 1);
        if (u === "")
          n === void 0 ? M(t) && !isNaN(parseInt(o)) ? t.splice(o, 1) : delete t[o] : t[o] = n;
        else {
          var a = t[o];
          a && z(t, o) || (a = t[o] = {}), H(a, u, n);
        }
      } else
        n === void 0 ? M(t) && !isNaN(parseInt(e)) ? t.splice(e, 1) : delete t[e] : t[e] = n;
    }
}
function An(t) {
  var e = {};
  for (var n in t)
    z(t, n) && (e[n] = t[n]);
  return e;
}
const hr = [].concat;
function On(t) {
  return hr.apply([], t);
}
const In = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(On([8, 16, 32, 64].map((t) => ["Int", "Uint", "Float"].map((e) => e + t + "Array")))).filter((t) => K[t]), dr = In.map((t) => K[t]);
Tn(In, (t) => [t, !0]);
let se = null;
function We(t) {
  se = typeof WeakMap < "u" && /* @__PURE__ */ new WeakMap();
  const e = Et(t);
  return se = null, e;
}
function Et(t) {
  if (!t || typeof t != "object")
    return t;
  let e = se && se.get(t);
  if (e)
    return e;
  if (M(t)) {
    e = [], se && se.set(t, e);
    for (var n = 0, r = t.length; n < r; ++n)
      e.push(Et(t[n]));
  } else if (dr.indexOf(t.constructor) >= 0)
    e = t;
  else {
    const i = Be(t);
    for (var s in e = i === Object.prototype ? {} : Object.create(i), se && se.set(t, e), t)
      z(t, s) && (e[s] = Et(t[s]));
  }
  return e;
}
const { toString: fr } = {};
function Tt(t) {
  return fr.call(t).slice(8, -1);
}
const At = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", pr = typeof At == "symbol" ? function(t) {
  var e;
  return t != null && (e = t[At]) && e.apply(t);
} : function() {
  return null;
}, _e = {};
function J(t) {
  var e, n, r, s;
  if (arguments.length === 1) {
    if (M(t))
      return t.slice();
    if (this === _e && typeof t == "string")
      return [t];
    if (s = pr(t)) {
      for (n = []; !(r = s.next()).done; )
        n.push(r.value);
      return n;
    }
    if (t == null)
      return [t];
    if (typeof (e = t.length) == "number") {
      for (n = new Array(e); e--; )
        n[e] = t[e];
      return n;
    }
    return [t];
  }
  for (e = arguments.length, n = new Array(e); e--; )
    n[e] = arguments[e];
  return n;
}
const Zt = typeof Symbol < "u" ? (t) => t[Symbol.toStringTag] === "AsyncFunction" : () => !1;
var G = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function Kn(t, e) {
  G = t, jn = e;
}
var jn = () => !0;
const mr = !new Error("").stack;
function Pe() {
  if (mr)
    try {
      throw new Error();
    } catch (t) {
      return t;
    }
  return new Error();
}
function Ot(t, e) {
  var n = t.stack;
  return n ? (e = e || 0, n.indexOf(t.name) === 0 && (e += (t.name + t.message).split(`
`).length), n.split(`
`).slice(e).filter(jn).map((r) => `
` + r).join("")) : "";
}
var Rn = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], en = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Rn), gr = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
function xe(t, e) {
  this._e = Pe(), this.name = t, this.message = e;
}
function $n(t, e) {
  return t + ". Errors: " + Object.keys(e).map((n) => e[n].toString()).filter((n, r, s) => s.indexOf(n) === r).join(`
`);
}
function lt(t, e, n, r) {
  this._e = Pe(), this.failures = e, this.failedKeys = r, this.successCount = n, this.message = $n(t, e);
}
function je(t, e) {
  this._e = Pe(), this.name = "BulkError", this.failures = Object.keys(e).map((n) => e[n]), this.failuresByPos = e, this.message = $n(t, e);
}
ke(xe).from(Error).extend({ stack: { get: function() {
  return this._stack || (this._stack = this.name + ": " + this.message + Ot(this._e, 2));
} }, toString: function() {
  return this.name + ": " + this.message;
} }), ke(lt).from(xe), ke(je).from(xe);
var tn = en.reduce((t, e) => (t[e] = e + "Error", t), {});
const yr = xe;
var E = en.reduce((t, e) => {
  var n = e + "Error";
  function r(s, i) {
    this._e = Pe(), this.name = n, s ? typeof s == "string" ? (this.message = `${s}${i ? `
 ` + i : ""}`, this.inner = i || null) : typeof s == "object" && (this.message = `${s.name} ${s.message}`, this.inner = s) : (this.message = gr[e] || n, this.inner = null);
  }
  return ke(r).from(yr), t[e] = r, t;
}, {});
E.Syntax = SyntaxError, E.Type = TypeError, E.Range = RangeError;
var fn = Rn.reduce((t, e) => (t[e + "Error"] = E[e], t), {}), tt = en.reduce((t, e) => (["Syntax", "Type", "Range"].indexOf(e) === -1 && (t[e + "Error"] = E[e]), t), {});
function I() {
}
function Fe(t) {
  return t;
}
function vr(t, e) {
  return t == null || t === Fe ? e : function(n) {
    return e(t(n));
  };
}
function me(t, e) {
  return function() {
    t.apply(this, arguments), e.apply(this, arguments);
  };
}
function br(t, e) {
  return t === I ? e : function() {
    var n = t.apply(this, arguments);
    n !== void 0 && (arguments[0] = n);
    var r = this.onsuccess, s = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var i = e.apply(this, arguments);
    return r && (this.onsuccess = this.onsuccess ? me(r, this.onsuccess) : r), s && (this.onerror = this.onerror ? me(s, this.onerror) : s), i !== void 0 ? i : n;
  };
}
function wr(t, e) {
  return t === I ? e : function() {
    t.apply(this, arguments);
    var n = this.onsuccess, r = this.onerror;
    this.onsuccess = this.onerror = null, e.apply(this, arguments), n && (this.onsuccess = this.onsuccess ? me(n, this.onsuccess) : n), r && (this.onerror = this.onerror ? me(r, this.onerror) : r);
  };
}
function _r(t, e) {
  return t === I ? e : function(n) {
    var r = t.apply(this, arguments);
    U(n, r);
    var s = this.onsuccess, i = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var o = e.apply(this, arguments);
    return s && (this.onsuccess = this.onsuccess ? me(s, this.onsuccess) : s), i && (this.onerror = this.onerror ? me(i, this.onerror) : i), r === void 0 ? o === void 0 ? void 0 : o : U(r, o);
  };
}
function kr(t, e) {
  return t === I ? e : function() {
    return e.apply(this, arguments) !== !1 && t.apply(this, arguments);
  };
}
function nn(t, e) {
  return t === I ? e : function() {
    var n = t.apply(this, arguments);
    if (n && typeof n.then == "function") {
      for (var r = this, s = arguments.length, i = new Array(s); s--; )
        i[s] = arguments[s];
      return n.then(function() {
        return e.apply(r, i);
      });
    }
    return e.apply(this, arguments);
  };
}
tt.ModifyError = lt, tt.DexieError = xe, tt.BulkError = je;
var Me = {};
const Nn = 100, [It, ct, Kt] = typeof Promise > "u" ? [] : (() => {
  let t = Promise.resolve();
  if (typeof crypto > "u" || !crypto.subtle)
    return [t, Be(t), t];
  const e = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [e, Be(e), t];
})(), Dn = ct && ct.then, nt = It && It.constructor, rn = !!Kt;
var jt = !1, xr = Kt ? () => {
  Kt.then(Ye);
} : K.setImmediate ? setImmediate.bind(null, Ye) : K.MutationObserver ? () => {
  var t = document.createElement("div");
  new MutationObserver(() => {
    Ye(), t = null;
  }).observe(t, { attributes: !0 }), t.setAttribute("i", "1");
} : () => {
  setTimeout(Ye, 0);
}, Re = function(t, e) {
  Ke.push([t, e]), ht && (xr(), ht = !1);
}, Rt = !0, ht = !0, de = [], rt = [], $t = null, Nt = Fe, Se = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: gn, pgp: !1, env: {}, finalize: function() {
  this.unhandleds.forEach((t) => {
    try {
      gn(t[0], t[1]);
    } catch {
    }
  });
} }, P = Se, Ke = [], fe = 0, st = [];
function S(t) {
  if (typeof this != "object")
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [], this.onuncatched = I, this._lib = !1;
  var e = this._PSD = P;
  if (G && (this._stackHolder = Pe(), this._prev = null, this._numPrev = 0), typeof t != "function") {
    if (t !== Me)
      throw new TypeError("Not a function");
    return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Bt(this, this._value));
  }
  this._state = null, this._value = null, ++e.ref, Fn(this, t);
}
const Dt = { get: function() {
  var t = P, e = dt;
  function n(r, s) {
    var i = !t.global && (t !== P || e !== dt);
    const o = i && !ne();
    var u = new S((a, c) => {
      sn(this, new Bn(ft(r, t, i, o), ft(s, t, i, o), a, c, t));
    });
    return G && Ln(u, this), u;
  }
  return n.prototype = Me, n;
}, set: function(t) {
  ee(this, "then", t && t.prototype === Me ? Dt : { get: function() {
    return t;
  }, set: Dt.set });
} };
function Bn(t, e, n, r, s) {
  this.onFulfilled = typeof t == "function" ? t : null, this.onRejected = typeof e == "function" ? e : null, this.resolve = n, this.reject = r, this.psd = s;
}
function Fn(t, e) {
  try {
    e((n) => {
      if (t._state === null) {
        if (n === t)
          throw new TypeError("A promise cannot be resolved with itself.");
        var r = t._lib && ze();
        n && typeof n.then == "function" ? Fn(t, (s, i) => {
          n instanceof S ? n._then(s, i) : n.then(s, i);
        }) : (t._state = !0, t._value = n, Mn(t)), r && He();
      }
    }, Bt.bind(null, t));
  } catch (n) {
    Bt(t, n);
  }
}
function Bt(t, e) {
  if (rt.push(e), t._state === null) {
    var n = t._lib && ze();
    e = Nt(e), t._state = !1, t._value = e, G && e !== null && typeof e == "object" && !e._promise && function(r, s, i) {
      try {
        r.apply(null, i);
      } catch (o) {
        s && s(o);
      }
    }(() => {
      var r = Jt(e, "stack");
      e._promise = t, ee(e, "stack", { get: () => jt ? r && (r.get ? r.get.apply(e) : r.value) : t.stack });
    }), function(r) {
      de.some((s) => s._value === r._value) || de.push(r);
    }(t), Mn(t), n && He();
  }
}
function Mn(t) {
  var e = t._listeners;
  t._listeners = [];
  for (var n = 0, r = e.length; n < r; ++n)
    sn(t, e[n]);
  var s = t._PSD;
  --s.ref || s.finalize(), fe === 0 && (++fe, Re(() => {
    --fe == 0 && on();
  }, []));
}
function sn(t, e) {
  if (t._state !== null) {
    var n = t._state ? e.onFulfilled : e.onRejected;
    if (n === null)
      return (t._state ? e.resolve : e.reject)(t._value);
    ++e.psd.ref, ++fe, Re(Sr, [n, t, e]);
  } else
    t._listeners.push(e);
}
function Sr(t, e, n) {
  try {
    $t = e;
    var r, s = e._value;
    e._state ? r = t(s) : (rt.length && (rt = []), r = t(s), rt.indexOf(s) === -1 && function(i) {
      for (var o = de.length; o; )
        if (de[--o]._value === i._value)
          return void de.splice(o, 1);
    }(e)), n.resolve(r);
  } catch (i) {
    n.reject(i);
  } finally {
    $t = null, --fe == 0 && on(), --n.psd.ref || n.psd.finalize();
  }
}
function qn(t, e, n) {
  if (e.length === n)
    return e;
  var r = "";
  if (t._state === !1) {
    var s, i, o = t._value;
    o != null ? (s = o.name || "Error", i = o.message || o, r = Ot(o, 0)) : (s = o, i = ""), e.push(s + (i ? ": " + i : "") + r);
  }
  return G && ((r = Ot(t._stackHolder, 2)) && e.indexOf(r) === -1 && e.push(r), t._prev && qn(t._prev, e, n)), e;
}
function Ln(t, e) {
  var n = e ? e._numPrev + 1 : 0;
  n < 100 && (t._prev = e, t._numPrev = n);
}
function Ye() {
  ze() && He();
}
function ze() {
  var t = Rt;
  return Rt = !1, ht = !1, t;
}
function He() {
  var t, e, n;
  do
    for (; Ke.length > 0; )
      for (t = Ke, Ke = [], n = t.length, e = 0; e < n; ++e) {
        var r = t[e];
        r[0].apply(null, r[1]);
      }
  while (Ke.length > 0);
  Rt = !0, ht = !0;
}
function on() {
  var t = de;
  de = [], t.forEach((r) => {
    r._PSD.onunhandled.call(null, r._value, r);
  });
  for (var e = st.slice(0), n = e.length; n; )
    e[--n]();
}
function Ge(t) {
  return new S(Me, !1, t);
}
function j(t, e) {
  var n = P;
  return function() {
    var r = ze(), s = P;
    try {
      return ae(n, !0), t.apply(this, arguments);
    } catch (i) {
      e && e(i);
    } finally {
      ae(s, !1), r && He();
    }
  };
}
Ce(S.prototype, { then: Dt, _then: function(t, e) {
  sn(this, new Bn(null, null, t, e, P));
}, catch: function(t) {
  if (arguments.length === 1)
    return this.then(null, t);
  var e = arguments[0], n = arguments[1];
  return typeof e == "function" ? this.then(null, (r) => r instanceof e ? n(r) : Ge(r)) : this.then(null, (r) => r && r.name === e ? n(r) : Ge(r));
}, finally: function(t) {
  return this.then((e) => (t(), e), (e) => (t(), Ge(e)));
}, stack: { get: function() {
  if (this._stack)
    return this._stack;
  try {
    jt = !0;
    var t = qn(this, [], 20).join(`
From previous: `);
    return this._state !== null && (this._stack = t), t;
  } finally {
    jt = !1;
  }
} }, timeout: function(t, e) {
  return t < 1 / 0 ? new S((n, r) => {
    var s = setTimeout(() => r(new E.Timeout(e)), t);
    this.then(n, r).finally(clearTimeout.bind(null, s));
  }) : this;
} }), typeof Symbol < "u" && Symbol.toStringTag && ee(S.prototype, Symbol.toStringTag, "Dexie.Promise"), Se.env = Un(), Ce(S, { all: function() {
  var t = J.apply(null, arguments).map(Xe);
  return new S(function(e, n) {
    t.length === 0 && e([]);
    var r = t.length;
    t.forEach((s, i) => S.resolve(s).then((o) => {
      t[i] = o, --r || e(t);
    }, n));
  });
}, resolve: (t) => {
  if (t instanceof S)
    return t;
  if (t && typeof t.then == "function")
    return new S((n, r) => {
      t.then(n, r);
    });
  var e = new S(Me, !0, t);
  return Ln(e, $t), e;
}, reject: Ge, race: function() {
  var t = J.apply(null, arguments).map(Xe);
  return new S((e, n) => {
    t.map((r) => S.resolve(r).then(e, n));
  });
}, PSD: { get: () => P, set: (t) => P = t }, totalEchoes: { get: () => dt }, newPSD: oe, usePSD: Te, scheduler: { get: () => Re, set: (t) => {
  Re = t;
} }, rejectionMapper: { get: () => Nt, set: (t) => {
  Nt = t;
} }, follow: (t, e) => new S((n, r) => oe((s, i) => {
  var o = P;
  o.unhandleds = [], o.onunhandled = i, o.finalize = me(function() {
    (function(u) {
      function a() {
        u(), st.splice(st.indexOf(a), 1);
      }
      st.push(a), ++fe, Re(() => {
        --fe == 0 && on();
      }, []);
    })(() => {
      this.unhandleds.length === 0 ? s() : i(this.unhandleds[0]);
    });
  }, o.finalize), t();
}, e, n, r)) }), nt && (nt.allSettled && ee(S, "allSettled", function() {
  const t = J.apply(null, arguments).map(Xe);
  return new S((e) => {
    t.length === 0 && e([]);
    let n = t.length;
    const r = new Array(n);
    t.forEach((s, i) => S.resolve(s).then((o) => r[i] = { status: "fulfilled", value: o }, (o) => r[i] = { status: "rejected", reason: o }).then(() => --n || e(r)));
  });
}), nt.any && typeof AggregateError < "u" && ee(S, "any", function() {
  const t = J.apply(null, arguments).map(Xe);
  return new S((e, n) => {
    t.length === 0 && n(new AggregateError([]));
    let r = t.length;
    const s = new Array(r);
    t.forEach((i, o) => S.resolve(i).then((u) => e(u), (u) => {
      s[o] = u, --r || n(new AggregateError(s));
    }));
  });
}));
const F = { awaits: 0, echoes: 0, id: 0 };
var Cr = 0, it = [], bt = 0, dt = 0, Pr = 0;
function oe(t, e, n, r) {
  var s = P, i = Object.create(s);
  i.parent = s, i.ref = 0, i.global = !1, i.id = ++Pr;
  var o = Se.env;
  i.env = rn ? { Promise: S, PromiseProp: { value: S, configurable: !0, writable: !0 }, all: S.all, race: S.race, allSettled: S.allSettled, any: S.any, resolve: S.resolve, reject: S.reject, nthen: pn(o.nthen, i), gthen: pn(o.gthen, i) } : {}, e && U(i, e), ++s.ref, i.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var u = Te(i, t, n, r);
  return i.ref === 0 && i.finalize(), u;
}
function Ee() {
  return F.id || (F.id = ++Cr), ++F.awaits, F.echoes += Nn, F.id;
}
function ne() {
  return !!F.awaits && (--F.awaits == 0 && (F.id = 0), F.echoes = F.awaits * Nn, !0);
}
function Xe(t) {
  return F.echoes && t && t.constructor === nt ? (Ee(), t.then((e) => (ne(), e), (e) => (ne(), D(e)))) : t;
}
function Er(t) {
  ++dt, F.echoes && --F.echoes != 0 || (F.echoes = F.id = 0), it.push(P), ae(t, !0);
}
function Tr() {
  var t = it[it.length - 1];
  it.pop(), ae(t, !1);
}
function ae(t, e) {
  var n = P;
  if ((e ? !F.echoes || bt++ && t === P : !bt || --bt && t === P) || Vn(e ? Er.bind(null, t) : Tr), t !== P && (P = t, n === Se && (Se.env = Un()), rn)) {
    var r = Se.env.Promise, s = t.env;
    ct.then = s.nthen, r.prototype.then = s.gthen, (n.global || t.global) && (Object.defineProperty(K, "Promise", s.PromiseProp), r.all = s.all, r.race = s.race, r.resolve = s.resolve, r.reject = s.reject, s.allSettled && (r.allSettled = s.allSettled), s.any && (r.any = s.any));
  }
}
function Un() {
  var t = K.Promise;
  return rn ? { Promise: t, PromiseProp: Object.getOwnPropertyDescriptor(K, "Promise"), all: t.all, race: t.race, allSettled: t.allSettled, any: t.any, resolve: t.resolve, reject: t.reject, nthen: ct.then, gthen: t.prototype.then } : {};
}
function Te(t, e, n, r, s) {
  var i = P;
  try {
    return ae(t, !0), e(n, r, s);
  } finally {
    ae(i, !1);
  }
}
function Vn(t) {
  Dn.call(It, t);
}
function ft(t, e, n, r) {
  return typeof t != "function" ? t : function() {
    var s = P;
    n && Ee(), ae(e, !0);
    try {
      return t.apply(this, arguments);
    } finally {
      ae(s, !1), r && Vn(ne);
    }
  };
}
function pn(t, e) {
  return function(n, r) {
    return t.call(this, ft(n, e), ft(r, e));
  };
}
("" + Dn).indexOf("[native code]") === -1 && (Ee = ne = I);
const mn = "unhandledrejection";
function gn(t, e) {
  var n;
  try {
    n = e.onuncatched(t);
  } catch {
  }
  if (n !== !1)
    try {
      var r, s = { promise: e, reason: t };
      if (K.document && document.createEvent ? ((r = document.createEvent("Event")).initEvent(mn, !0, !0), U(r, s)) : K.CustomEvent && U(r = new CustomEvent(mn, { detail: s }), s), r && K.dispatchEvent && (dispatchEvent(r), !K.PromiseRejectionEvent && K.onunhandledrejection))
        try {
          K.onunhandledrejection(r);
        } catch {
        }
      G && r && !r.defaultPrevented && console.warn(`Unhandled rejection: ${t.stack || t}`);
    } catch {
    }
}
var D = S.reject;
function Ft(t, e, n, r) {
  if (t.idbdb && (t._state.openComplete || P.letThrough || t._vip)) {
    var s = t._createTransaction(e, n, t._dbSchema);
    try {
      s.create(), t._state.PR1398_maxLoop = 3;
    } catch (i) {
      return i.name === tn.InvalidState && t.isOpen() && --t._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), t._close(), t.open().then(() => Ft(t, e, n, r))) : D(i);
    }
    return s._promise(e, (i, o) => oe(() => (P.trans = s, r(i, o, s)))).then((i) => s._completion.then(() => i));
  }
  if (t._state.openComplete)
    return D(new E.DatabaseClosed(t._state.dbOpenError));
  if (!t._state.isBeingOpened) {
    if (!t._options.autoOpen)
      return D(new E.DatabaseClosed());
    t.open().catch(I);
  }
  return t._state.dbReadyPromise.then(() => Ft(t, e, n, r));
}
const yn = "3.2.4", he = String.fromCharCode(65535), Mt = -1 / 0, X = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Wn = "String expected.", $e = [], gt = typeof navigator < "u" && /(MSIE|Trident|Edge)/.test(navigator.userAgent), Ar = gt, Or = gt, zn = (t) => !/(dexie\.js|dexie\.min\.js)/.test(t), yt = "__dbnames", wt = "readonly", _t = "readwrite";
function ge(t, e) {
  return t ? e ? function() {
    return t.apply(this, arguments) && e.apply(this, arguments);
  } : t : e;
}
const Hn = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
function Qe(t) {
  return typeof t != "string" || /\./.test(t) ? (e) => e : (e) => (e[t] === void 0 && t in e && delete (e = We(e))[t], e);
}
class Ir {
  _trans(e, n, r) {
    const s = this._tx || P.trans, i = this.name;
    function o(a, c, d) {
      if (!d.schema[i])
        throw new E.NotFound("Table " + i + " not part of transaction");
      return n(d.idbtrans, d);
    }
    const u = ze();
    try {
      return s && s.db === this.db ? s === P.trans ? s._promise(e, o, r) : oe(() => s._promise(e, o, r), { trans: s, transless: P.transless || P }) : Ft(this.db, e, [this.name], o);
    } finally {
      u && He();
    }
  }
  get(e, n) {
    return e && e.constructor === Object ? this.where(e).first(n) : this._trans("readonly", (r) => this.core.get({ trans: r, key: e }).then((s) => this.hook.reading.fire(s))).then(n);
  }
  where(e) {
    if (typeof e == "string")
      return new this.db.WhereClause(this, e);
    if (M(e))
      return new this.db.WhereClause(this, `[${e.join("+")}]`);
    const n = N(e);
    if (n.length === 1)
      return this.where(n[0]).equals(e[n[0]]);
    const r = this.schema.indexes.concat(this.schema.primKey).filter((c) => c.compound && n.every((d) => c.keyPath.indexOf(d) >= 0) && c.keyPath.every((d) => n.indexOf(d) >= 0))[0];
    if (r && this.db._maxKey !== he)
      return this.where(r.name).equals(r.keyPath.map((c) => e[c]));
    !r && G && console.warn(`The query ${JSON.stringify(e)} on ${this.name} would benefit of a compound index [${n.join("+")}]`);
    const { idxByName: s } = this.schema, i = this.db._deps.indexedDB;
    function o(c, d) {
      try {
        return i.cmp(c, d) === 0;
      } catch {
        return !1;
      }
    }
    const [u, a] = n.reduce(([c, d], l) => {
      const h = s[l], f = e[l];
      return [c || h, c || !h ? ge(d, h && h.multi ? (m) => {
        const p = te(m, l);
        return M(p) && p.some((v) => o(f, v));
      } : (m) => o(f, te(m, l))) : d];
    }, [null, null]);
    return u ? this.where(u.name).equals(e[u.keyPath]).filter(a) : r ? this.filter(a) : this.where(n).equals("");
  }
  filter(e) {
    return this.toCollection().and(e);
  }
  count(e) {
    return this.toCollection().count(e);
  }
  offset(e) {
    return this.toCollection().offset(e);
  }
  limit(e) {
    return this.toCollection().limit(e);
  }
  each(e) {
    return this.toCollection().each(e);
  }
  toArray(e) {
    return this.toCollection().toArray(e);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(e) {
    return new this.db.Collection(new this.db.WhereClause(this, M(e) ? `[${e.join("+")}]` : e));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(e) {
    this.schema.mappedClass = e;
    const n = (r) => {
      if (!r)
        return r;
      const s = Object.create(e.prototype);
      for (var i in r)
        if (z(r, i))
          try {
            s[i] = r[i];
          } catch {
          }
      return s;
    };
    return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = n, this.hook("reading", n), e;
  }
  defineClass() {
    return this.mapToClass(function(e) {
      U(this, e);
    });
  }
  add(e, n) {
    const { auto: r, keyPath: s } = this.schema.primKey;
    let i = e;
    return s && r && (i = Qe(s)(e)), this._trans("readwrite", (o) => this.core.mutate({ trans: o, type: "add", keys: n != null ? [n] : null, values: [i] })).then((o) => o.numFailures ? S.reject(o.failures[0]) : o.lastResult).then((o) => {
      if (s)
        try {
          H(e, s, o);
        } catch {
        }
      return o;
    });
  }
  update(e, n) {
    if (typeof e != "object" || M(e))
      return this.where(":id").equals(e).modify(n);
    {
      const r = te(e, this.schema.primKey.keyPath);
      if (r === void 0)
        return D(new E.InvalidArgument("Given object does not contain its primary key"));
      try {
        typeof n != "function" ? N(n).forEach((s) => {
          H(e, s, n[s]);
        }) : n(e, { value: e, primKey: r });
      } catch {
      }
      return this.where(":id").equals(r).modify(n);
    }
  }
  put(e, n) {
    const { auto: r, keyPath: s } = this.schema.primKey;
    let i = e;
    return s && r && (i = Qe(s)(e)), this._trans("readwrite", (o) => this.core.mutate({ trans: o, type: "put", values: [i], keys: n != null ? [n] : null })).then((o) => o.numFailures ? S.reject(o.failures[0]) : o.lastResult).then((o) => {
      if (s)
        try {
          H(e, s, o);
        } catch {
        }
      return o;
    });
  }
  delete(e) {
    return this._trans("readwrite", (n) => this.core.mutate({ trans: n, type: "delete", keys: [e] })).then((n) => n.numFailures ? S.reject(n.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (e) => this.core.mutate({ trans: e, type: "deleteRange", range: Hn })).then((e) => e.numFailures ? S.reject(e.failures[0]) : void 0);
  }
  bulkGet(e) {
    return this._trans("readonly", (n) => this.core.getMany({ keys: e, trans: n }).then((r) => r.map((s) => this.hook.reading.fire(s))));
  }
  bulkAdd(e, n, r) {
    const s = Array.isArray(n) ? n : void 0, i = (r = r || (s ? void 0 : n)) ? r.allKeys : void 0;
    return this._trans("readwrite", (o) => {
      const { auto: u, keyPath: a } = this.schema.primKey;
      if (a && s)
        throw new E.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (s && s.length !== e.length)
        throw new E.InvalidArgument("Arguments objects and keys must have the same length");
      const c = e.length;
      let d = a && u ? e.map(Qe(a)) : e;
      return this.core.mutate({ trans: o, type: "add", keys: s, values: d, wantResults: i }).then(({ numFailures: l, results: h, lastResult: f, failures: m }) => {
        if (l === 0)
          return i ? h : f;
        throw new je(`${this.name}.bulkAdd(): ${l} of ${c} operations failed`, m);
      });
    });
  }
  bulkPut(e, n, r) {
    const s = Array.isArray(n) ? n : void 0, i = (r = r || (s ? void 0 : n)) ? r.allKeys : void 0;
    return this._trans("readwrite", (o) => {
      const { auto: u, keyPath: a } = this.schema.primKey;
      if (a && s)
        throw new E.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (s && s.length !== e.length)
        throw new E.InvalidArgument("Arguments objects and keys must have the same length");
      const c = e.length;
      let d = a && u ? e.map(Qe(a)) : e;
      return this.core.mutate({ trans: o, type: "put", keys: s, values: d, wantResults: i }).then(({ numFailures: l, results: h, lastResult: f, failures: m }) => {
        if (l === 0)
          return i ? h : f;
        throw new je(`${this.name}.bulkPut(): ${l} of ${c} operations failed`, m);
      });
    });
  }
  bulkDelete(e) {
    const n = e.length;
    return this._trans("readwrite", (r) => this.core.mutate({ trans: r, type: "delete", keys: e })).then(({ numFailures: r, lastResult: s, failures: i }) => {
      if (r === 0)
        return s;
      throw new je(`${this.name}.bulkDelete(): ${r} of ${n} operations failed`, i);
    });
  }
}
function Ne(t) {
  var e = {}, n = function(o, u) {
    if (u) {
      for (var a = arguments.length, c = new Array(a - 1); --a; )
        c[a - 1] = arguments[a];
      return e[o].subscribe.apply(null, c), t;
    }
    if (typeof o == "string")
      return e[o];
  };
  n.addEventType = i;
  for (var r = 1, s = arguments.length; r < s; ++r)
    i(arguments[r]);
  return n;
  function i(o, u, a) {
    if (typeof o != "object") {
      var c;
      u || (u = kr), a || (a = I);
      var d = { subscribers: [], fire: a, subscribe: function(l) {
        d.subscribers.indexOf(l) === -1 && (d.subscribers.push(l), d.fire = u(d.fire, l));
      }, unsubscribe: function(l) {
        d.subscribers = d.subscribers.filter(function(h) {
          return h !== l;
        }), d.fire = d.subscribers.reduce(u, a);
      } };
      return e[o] = n[o] = d, d;
    }
    N(c = o).forEach(function(l) {
      var h = c[l];
      if (M(h))
        i(l, c[l][0], c[l][1]);
      else {
        if (h !== "asap")
          throw new E.InvalidArgument("Invalid event config");
        var f = i(l, Fe, function() {
          for (var m = arguments.length, p = new Array(m); m--; )
            p[m] = arguments[m];
          f.subscribers.forEach(function(v) {
            En(function() {
              v.apply(null, p);
            });
          });
        });
      }
    });
  }
}
function Oe(t, e) {
  return ke(e).from({ prototype: t }), e;
}
function be(t, e) {
  return !(t.filter || t.algorithm || t.or) && (e ? t.justLimit : !t.replayFilter);
}
function kt(t, e) {
  t.filter = ge(t.filter, e);
}
function xt(t, e, n) {
  var r = t.replayFilter;
  t.replayFilter = r ? () => ge(r(), e()) : e, t.justLimit = n && !r;
}
function ot(t, e) {
  if (t.isPrimKey)
    return e.primaryKey;
  const n = e.getIndexByKeyPath(t.index);
  if (!n)
    throw new E.Schema("KeyPath " + t.index + " on object store " + e.name + " is not indexed");
  return n;
}
function vn(t, e, n) {
  const r = ot(t, e.schema);
  return e.openCursor({ trans: n, values: !t.keysOnly, reverse: t.dir === "prev", unique: !!t.unique, query: { index: r, range: t.range } });
}
function Je(t, e, n, r) {
  const s = t.replayFilter ? ge(t.filter, t.replayFilter()) : t.filter;
  if (t.or) {
    const i = {}, o = (u, a, c) => {
      if (!s || s(a, c, (h) => a.stop(h), (h) => a.fail(h))) {
        var d = a.primaryKey, l = "" + d;
        l === "[object ArrayBuffer]" && (l = "" + new Uint8Array(d)), z(i, l) || (i[l] = !0, e(u, a, c));
      }
    };
    return Promise.all([t.or._iterate(o, n), bn(vn(t, r, n), t.algorithm, o, !t.keysOnly && t.valueMapper)]);
  }
  return bn(vn(t, r, n), ge(t.algorithm, s), e, !t.keysOnly && t.valueMapper);
}
function bn(t, e, n, r) {
  var s = j(r ? (i, o, u) => n(r(i), o, u) : n);
  return t.then((i) => {
    if (i)
      return i.start(() => {
        var o = () => i.continue();
        e && !e(i, (u) => o = u, (u) => {
          i.stop(u), o = I;
        }, (u) => {
          i.fail(u), o = I;
        }) || s(i.value, i, (u) => o = u), o();
      });
  });
}
function L(t, e) {
  try {
    const n = wn(t), r = wn(e);
    if (n !== r)
      return n === "Array" ? 1 : r === "Array" ? -1 : n === "binary" ? 1 : r === "binary" ? -1 : n === "string" ? 1 : r === "string" ? -1 : n === "Date" ? 1 : r !== "Date" ? NaN : -1;
    switch (n) {
      case "number":
      case "Date":
      case "string":
        return t > e ? 1 : t < e ? -1 : 0;
      case "binary":
        return function(s, i) {
          const o = s.length, u = i.length, a = o < u ? o : u;
          for (let c = 0; c < a; ++c)
            if (s[c] !== i[c])
              return s[c] < i[c] ? -1 : 1;
          return o === u ? 0 : o < u ? -1 : 1;
        }(_n(t), _n(e));
      case "Array":
        return function(s, i) {
          const o = s.length, u = i.length, a = o < u ? o : u;
          for (let c = 0; c < a; ++c) {
            const d = L(s[c], i[c]);
            if (d !== 0)
              return d;
          }
          return o === u ? 0 : o < u ? -1 : 1;
        }(t, e);
    }
  } catch {
  }
  return NaN;
}
function wn(t) {
  const e = typeof t;
  if (e !== "object")
    return e;
  if (ArrayBuffer.isView(t))
    return "binary";
  const n = Tt(t);
  return n === "ArrayBuffer" ? "binary" : n;
}
function _n(t) {
  return t instanceof Uint8Array ? t : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : new Uint8Array(t);
}
class Kr {
  _read(e, n) {
    var r = this._ctx;
    return r.error ? r.table._trans(null, D.bind(null, r.error)) : r.table._trans("readonly", e).then(n);
  }
  _write(e) {
    var n = this._ctx;
    return n.error ? n.table._trans(null, D.bind(null, n.error)) : n.table._trans("readwrite", e, "locked");
  }
  _addAlgorithm(e) {
    var n = this._ctx;
    n.algorithm = ge(n.algorithm, e);
  }
  _iterate(e, n) {
    return Je(this._ctx, e, n, this._ctx.table.core);
  }
  clone(e) {
    var n = Object.create(this.constructor.prototype), r = Object.create(this._ctx);
    return e && U(r, e), n._ctx = r, n;
  }
  raw() {
    return this._ctx.valueMapper = null, this;
  }
  each(e) {
    var n = this._ctx;
    return this._read((r) => Je(n, e, r, n.table.core));
  }
  count(e) {
    return this._read((n) => {
      const r = this._ctx, s = r.table.core;
      if (be(r, !0))
        return s.count({ trans: n, query: { index: ot(r, s.schema), range: r.range } }).then((o) => Math.min(o, r.limit));
      var i = 0;
      return Je(r, () => (++i, !1), n, s).then(() => i);
    }).then(e);
  }
  sortBy(e, n) {
    const r = e.split(".").reverse(), s = r[0], i = r.length - 1;
    function o(c, d) {
      return d ? o(c[r[d]], d - 1) : c[s];
    }
    var u = this._ctx.dir === "next" ? 1 : -1;
    function a(c, d) {
      var l = o(c, i), h = o(d, i);
      return l < h ? -u : l > h ? u : 0;
    }
    return this.toArray(function(c) {
      return c.sort(a);
    }).then(n);
  }
  toArray(e) {
    return this._read((n) => {
      var r = this._ctx;
      if (r.dir === "next" && be(r, !0) && r.limit > 0) {
        const { valueMapper: s } = r, i = ot(r, r.table.core.schema);
        return r.table.core.query({ trans: n, limit: r.limit, values: !0, query: { index: i, range: r.range } }).then(({ result: o }) => s ? o.map(s) : o);
      }
      {
        const s = [];
        return Je(r, (i) => s.push(i), n, r.table.core).then(() => s);
      }
    }, e);
  }
  offset(e) {
    var n = this._ctx;
    return e <= 0 || (n.offset += e, be(n) ? xt(n, () => {
      var r = e;
      return (s, i) => r === 0 || (r === 1 ? (--r, !1) : (i(() => {
        s.advance(r), r = 0;
      }), !1));
    }) : xt(n, () => {
      var r = e;
      return () => --r < 0;
    })), this;
  }
  limit(e) {
    return this._ctx.limit = Math.min(this._ctx.limit, e), xt(this._ctx, () => {
      var n = e;
      return function(r, s, i) {
        return --n <= 0 && s(i), n >= 0;
      };
    }, !0), this;
  }
  until(e, n) {
    return kt(this._ctx, function(r, s, i) {
      return !e(r.value) || (s(i), n);
    }), this;
  }
  first(e) {
    return this.limit(1).toArray(function(n) {
      return n[0];
    }).then(e);
  }
  last(e) {
    return this.reverse().first(e);
  }
  filter(e) {
    var n, r;
    return kt(this._ctx, function(s) {
      return e(s.value);
    }), n = this._ctx, r = e, n.isMatch = ge(n.isMatch, r), this;
  }
  and(e) {
    return this.filter(e);
  }
  or(e) {
    return new this.db.WhereClause(this._ctx.table, e, this);
  }
  reverse() {
    return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(e) {
    var n = this._ctx;
    return n.keysOnly = !n.isMatch, this.each(function(r, s) {
      e(s.key, s);
    });
  }
  eachUniqueKey(e) {
    return this._ctx.unique = "unique", this.eachKey(e);
  }
  eachPrimaryKey(e) {
    var n = this._ctx;
    return n.keysOnly = !n.isMatch, this.each(function(r, s) {
      e(s.primaryKey, s);
    });
  }
  keys(e) {
    var n = this._ctx;
    n.keysOnly = !n.isMatch;
    var r = [];
    return this.each(function(s, i) {
      r.push(i.key);
    }).then(function() {
      return r;
    }).then(e);
  }
  primaryKeys(e) {
    var n = this._ctx;
    if (n.dir === "next" && be(n, !0) && n.limit > 0)
      return this._read((s) => {
        var i = ot(n, n.table.core.schema);
        return n.table.core.query({ trans: s, values: !1, limit: n.limit, query: { index: i, range: n.range } });
      }).then(({ result: s }) => s).then(e);
    n.keysOnly = !n.isMatch;
    var r = [];
    return this.each(function(s, i) {
      r.push(i.primaryKey);
    }).then(function() {
      return r;
    }).then(e);
  }
  uniqueKeys(e) {
    return this._ctx.unique = "unique", this.keys(e);
  }
  firstKey(e) {
    return this.limit(1).keys(function(n) {
      return n[0];
    }).then(e);
  }
  lastKey(e) {
    return this.reverse().firstKey(e);
  }
  distinct() {
    var e = this._ctx, n = e.index && e.table.schema.idxByName[e.index];
    if (!n || !n.multi)
      return this;
    var r = {};
    return kt(this._ctx, function(s) {
      var i = s.primaryKey.toString(), o = z(r, i);
      return r[i] = !0, !o;
    }), this;
  }
  modify(e) {
    var n = this._ctx;
    return this._write((r) => {
      var s;
      if (typeof e == "function")
        s = e;
      else {
        var i = N(e), o = i.length;
        s = function(p) {
          for (var v = !1, y = 0; y < o; ++y) {
            var g = i[y], b = e[g];
            te(p, g) !== b && (H(p, g, b), v = !0);
          }
          return v;
        };
      }
      const u = n.table.core, { outbound: a, extractKey: c } = u.schema.primaryKey, d = this.db._options.modifyChunkSize || 200, l = [];
      let h = 0;
      const f = [], m = (p, v) => {
        const { failures: y, numFailures: g } = v;
        h += p - g;
        for (let b of N(y))
          l.push(y[b]);
      };
      return this.clone().primaryKeys().then((p) => {
        const v = (y) => {
          const g = Math.min(d, p.length - y);
          return u.getMany({ trans: r, keys: p.slice(y, y + g), cache: "immutable" }).then((b) => {
            const k = [], C = [], x = a ? [] : null, w = [];
            for (let _ = 0; _ < g; ++_) {
              const R = b[_], O = { value: We(R), primKey: p[y + _] };
              s.call(O, O.value, O) !== !1 && (O.value == null ? w.push(p[y + _]) : a || L(c(R), c(O.value)) === 0 ? (C.push(O.value), a && x.push(p[y + _])) : (w.push(p[y + _]), k.push(O.value)));
            }
            const A = be(n) && n.limit === 1 / 0 && (typeof e != "function" || e === St) && { index: n.index, range: n.range };
            return Promise.resolve(k.length > 0 && u.mutate({ trans: r, type: "add", values: k }).then((_) => {
              for (let R in _.failures)
                w.splice(parseInt(R), 1);
              m(k.length, _);
            })).then(() => (C.length > 0 || A && typeof e == "object") && u.mutate({ trans: r, type: "put", keys: x, values: C, criteria: A, changeSpec: typeof e != "function" && e }).then((_) => m(C.length, _))).then(() => (w.length > 0 || A && e === St) && u.mutate({ trans: r, type: "delete", keys: w, criteria: A }).then((_) => m(w.length, _))).then(() => p.length > y + g && v(y + d));
          });
        };
        return v(0).then(() => {
          if (l.length > 0)
            throw new lt("Error modifying one or more objects", l, h, f);
          return p.length;
        });
      });
    });
  }
  delete() {
    var e = this._ctx, n = e.range;
    return be(e) && (e.isPrimKey && !Or || n.type === 3) ? this._write((r) => {
      const { primaryKey: s } = e.table.core.schema, i = n;
      return e.table.core.count({ trans: r, query: { index: s, range: i } }).then((o) => e.table.core.mutate({ trans: r, type: "deleteRange", range: i }).then(({ failures: u, lastResult: a, results: c, numFailures: d }) => {
        if (d)
          throw new lt("Could not delete some values", Object.keys(u).map((l) => u[l]), o - d);
        return o - d;
      }));
    }) : this.modify(St);
  }
}
const St = (t, e) => e.value = null;
function jr(t, e) {
  return t < e ? -1 : t === e ? 0 : 1;
}
function Rr(t, e) {
  return t > e ? -1 : t === e ? 0 : 1;
}
function W(t, e, n) {
  var r = t instanceof Gn ? new t.Collection(t) : t;
  return r._ctx.error = n ? new n(e) : new TypeError(e), r;
}
function we(t) {
  return new t.Collection(t, () => Yn("")).limit(0);
}
function $r(t, e, n, r, s, i) {
  for (var o = Math.min(t.length, r.length), u = -1, a = 0; a < o; ++a) {
    var c = e[a];
    if (c !== r[a])
      return s(t[a], n[a]) < 0 ? t.substr(0, a) + n[a] + n.substr(a + 1) : s(t[a], r[a]) < 0 ? t.substr(0, a) + r[a] + n.substr(a + 1) : u >= 0 ? t.substr(0, u) + e[u] + n.substr(u + 1) : null;
    s(t[a], c) < 0 && (u = a);
  }
  return o < r.length && i === "next" ? t + n.substr(t.length) : o < t.length && i === "prev" ? t.substr(0, n.length) : u < 0 ? null : t.substr(0, u) + r[u] + n.substr(u + 1);
}
function Ze(t, e, n, r) {
  var s, i, o, u, a, c, d, l = n.length;
  if (!n.every((p) => typeof p == "string"))
    return W(t, Wn);
  function h(p) {
    s = function(y) {
      return y === "next" ? (g) => g.toUpperCase() : (g) => g.toLowerCase();
    }(p), i = function(y) {
      return y === "next" ? (g) => g.toLowerCase() : (g) => g.toUpperCase();
    }(p), o = p === "next" ? jr : Rr;
    var v = n.map(function(y) {
      return { lower: i(y), upper: s(y) };
    }).sort(function(y, g) {
      return o(y.lower, g.lower);
    });
    u = v.map(function(y) {
      return y.upper;
    }), a = v.map(function(y) {
      return y.lower;
    }), c = p, d = p === "next" ? "" : r;
  }
  h("next");
  var f = new t.Collection(t, () => re(u[0], a[l - 1] + r));
  f._ondirectionchange = function(p) {
    h(p);
  };
  var m = 0;
  return f._addAlgorithm(function(p, v, y) {
    var g = p.key;
    if (typeof g != "string")
      return !1;
    var b = i(g);
    if (e(b, a, m))
      return !0;
    for (var k = null, C = m; C < l; ++C) {
      var x = $r(g, b, u[C], a[C], o, c);
      x === null && k === null ? m = C + 1 : (k === null || o(k, x) > 0) && (k = x);
    }
    return v(k !== null ? function() {
      p.continue(k + d);
    } : y), !1;
  }), f;
}
function re(t, e, n, r) {
  return { type: 2, lower: t, upper: e, lowerOpen: n, upperOpen: r };
}
function Yn(t) {
  return { type: 1, lower: t, upper: t };
}
class Gn {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(e, n, r, s) {
    r = r !== !1, s = s === !0;
    try {
      return this._cmp(e, n) > 0 || this._cmp(e, n) === 0 && (r || s) && (!r || !s) ? we(this) : new this.Collection(this, () => re(e, n, !r, !s));
    } catch {
      return W(this, X);
    }
  }
  equals(e) {
    return e == null ? W(this, X) : new this.Collection(this, () => Yn(e));
  }
  above(e) {
    return e == null ? W(this, X) : new this.Collection(this, () => re(e, void 0, !0));
  }
  aboveOrEqual(e) {
    return e == null ? W(this, X) : new this.Collection(this, () => re(e, void 0, !1));
  }
  below(e) {
    return e == null ? W(this, X) : new this.Collection(this, () => re(void 0, e, !1, !0));
  }
  belowOrEqual(e) {
    return e == null ? W(this, X) : new this.Collection(this, () => re(void 0, e));
  }
  startsWith(e) {
    return typeof e != "string" ? W(this, Wn) : this.between(e, e + he, !0, !0);
  }
  startsWithIgnoreCase(e) {
    return e === "" ? this.startsWith(e) : Ze(this, (n, r) => n.indexOf(r[0]) === 0, [e], he);
  }
  equalsIgnoreCase(e) {
    return Ze(this, (n, r) => n === r[0], [e], "");
  }
  anyOfIgnoreCase() {
    var e = J.apply(_e, arguments);
    return e.length === 0 ? we(this) : Ze(this, (n, r) => r.indexOf(n) !== -1, e, "");
  }
  startsWithAnyOfIgnoreCase() {
    var e = J.apply(_e, arguments);
    return e.length === 0 ? we(this) : Ze(this, (n, r) => r.some((s) => n.indexOf(s) === 0), e, he);
  }
  anyOf() {
    const e = J.apply(_e, arguments);
    let n = this._cmp;
    try {
      e.sort(n);
    } catch {
      return W(this, X);
    }
    if (e.length === 0)
      return we(this);
    const r = new this.Collection(this, () => re(e[0], e[e.length - 1]));
    r._ondirectionchange = (i) => {
      n = i === "next" ? this._ascending : this._descending, e.sort(n);
    };
    let s = 0;
    return r._addAlgorithm((i, o, u) => {
      const a = i.key;
      for (; n(a, e[s]) > 0; )
        if (++s, s === e.length)
          return o(u), !1;
      return n(a, e[s]) === 0 || (o(() => {
        i.continue(e[s]);
      }), !1);
    }), r;
  }
  notEqual(e) {
    return this.inAnyRange([[Mt, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
  }
  noneOf() {
    const e = J.apply(_e, arguments);
    if (e.length === 0)
      return new this.Collection(this);
    try {
      e.sort(this._ascending);
    } catch {
      return W(this, X);
    }
    const n = e.reduce((r, s) => r ? r.concat([[r[r.length - 1][1], s]]) : [[Mt, s]], null);
    return n.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(n, { includeLowers: !1, includeUppers: !1 });
  }
  inAnyRange(e, n) {
    const r = this._cmp, s = this._ascending, i = this._descending, o = this._min, u = this._max;
    if (e.length === 0)
      return we(this);
    if (!e.every((g) => g[0] !== void 0 && g[1] !== void 0 && s(g[0], g[1]) <= 0))
      return W(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", E.InvalidArgument);
    const a = !n || n.includeLowers !== !1, c = n && n.includeUppers === !0;
    let d, l = s;
    function h(g, b) {
      return l(g[0], b[0]);
    }
    try {
      d = e.reduce(function(g, b) {
        let k = 0, C = g.length;
        for (; k < C; ++k) {
          const x = g[k];
          if (r(b[0], x[1]) < 0 && r(b[1], x[0]) > 0) {
            x[0] = o(x[0], b[0]), x[1] = u(x[1], b[1]);
            break;
          }
        }
        return k === C && g.push(b), g;
      }, []), d.sort(h);
    } catch {
      return W(this, X);
    }
    let f = 0;
    const m = c ? (g) => s(g, d[f][1]) > 0 : (g) => s(g, d[f][1]) >= 0, p = a ? (g) => i(g, d[f][0]) > 0 : (g) => i(g, d[f][0]) >= 0;
    let v = m;
    const y = new this.Collection(this, () => re(d[0][0], d[d.length - 1][1], !a, !c));
    return y._ondirectionchange = (g) => {
      g === "next" ? (v = m, l = s) : (v = p, l = i), d.sort(h);
    }, y._addAlgorithm((g, b, k) => {
      for (var C = g.key; v(C); )
        if (++f, f === d.length)
          return b(k), !1;
      return !!function(x) {
        return !m(x) && !p(x);
      }(C) || (this._cmp(C, d[f][1]) === 0 || this._cmp(C, d[f][0]) === 0 || b(() => {
        l === s ? g.continue(d[f][0]) : g.continue(d[f][1]);
      }), !1);
    }), y;
  }
  startsWithAnyOf() {
    const e = J.apply(_e, arguments);
    return e.every((n) => typeof n == "string") ? e.length === 0 ? we(this) : this.inAnyRange(e.map((n) => [n, n + he])) : W(this, "startsWithAnyOf() only works with strings");
  }
}
function Y(t) {
  return j(function(e) {
    return qe(e), t(e.target.error), !1;
  });
}
function qe(t) {
  t.stopPropagation && t.stopPropagation(), t.preventDefault && t.preventDefault();
}
const Le = "storagemutated", ie = "x-storagemutated-1", ue = Ne(null, Le);
class Nr {
  _lock() {
    return Ie(!P.global), ++this._reculock, this._reculock !== 1 || P.global || (P.lockOwnerFor = this), this;
  }
  _unlock() {
    if (Ie(!P.global), --this._reculock == 0)
      for (P.global || (P.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked(); ) {
        var e = this._blockedFuncs.shift();
        try {
          Te(e[1], e[0]);
        } catch {
        }
      }
    return this;
  }
  _locked() {
    return this._reculock && P.lockOwnerFor !== this;
  }
  create(e) {
    if (!this.mode)
      return this;
    const n = this.db.idbdb, r = this.db._state.dbOpenError;
    if (Ie(!this.idbtrans), !e && !n)
      switch (r && r.name) {
        case "DatabaseClosedError":
          throw new E.DatabaseClosed(r);
        case "MissingAPIError":
          throw new E.MissingAPI(r.message, r);
        default:
          throw new E.OpenFailed(r);
      }
    if (!this.active)
      throw new E.TransactionInactive();
    return Ie(this._completion._state === null), (e = this.idbtrans = e || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : n.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }))).onerror = j((s) => {
      qe(s), this._reject(e.error);
    }), e.onabort = j((s) => {
      qe(s), this.active && this._reject(new E.Abort(e.error)), this.active = !1, this.on("abort").fire(s);
    }), e.oncomplete = j(() => {
      this.active = !1, this._resolve(), "mutatedParts" in e && ue.storagemutated.fire(e.mutatedParts);
    }), this;
  }
  _promise(e, n, r) {
    if (e === "readwrite" && this.mode !== "readwrite")
      return D(new E.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return D(new E.TransactionInactive());
    if (this._locked())
      return new S((i, o) => {
        this._blockedFuncs.push([() => {
          this._promise(e, n, r).then(i, o);
        }, P]);
      });
    if (r)
      return oe(() => {
        var i = new S((o, u) => {
          this._lock();
          const a = n(o, u, this);
          a && a.then && a.then(o, u);
        });
        return i.finally(() => this._unlock()), i._lib = !0, i;
      });
    var s = new S((i, o) => {
      var u = n(i, o, this);
      u && u.then && u.then(i, o);
    });
    return s._lib = !0, s;
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(e) {
    var n = this._root();
    const r = S.resolve(e);
    if (n._waitingFor)
      n._waitingFor = n._waitingFor.then(() => r);
    else {
      n._waitingFor = r, n._waitingQueue = [];
      var s = n.idbtrans.objectStore(n.storeNames[0]);
      (function o() {
        for (++n._spinCount; n._waitingQueue.length; )
          n._waitingQueue.shift()();
        n._waitingFor && (s.get(-1 / 0).onsuccess = o);
      })();
    }
    var i = n._waitingFor;
    return new S((o, u) => {
      r.then((a) => n._waitingQueue.push(j(o.bind(null, a))), (a) => n._waitingQueue.push(j(u.bind(null, a)))).finally(() => {
        n._waitingFor === i && (n._waitingFor = null);
      });
    });
  }
  abort() {
    this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new E.Abort()));
  }
  table(e) {
    const n = this._memoizedTables || (this._memoizedTables = {});
    if (z(n, e))
      return n[e];
    const r = this.schema[e];
    if (!r)
      throw new E.NotFound("Table " + e + " not part of transaction");
    const s = new this.db.Table(e, r, this);
    return s.core = this.db.core.table(e), n[e] = s, s;
  }
}
function qt(t, e, n, r, s, i, o) {
  return { name: t, keyPath: e, unique: n, multi: r, auto: s, compound: i, src: (n && !o ? "&" : "") + (r ? "*" : "") + (s ? "++" : "") + Xn(e) };
}
function Xn(t) {
  return typeof t == "string" ? t : t ? "[" + [].join.call(t, "+") + "]" : "";
}
function Qn(t, e, n) {
  return { name: t, primKey: e, indexes: n, mappedClass: null, idxByName: Tn(n, (r) => [r.name, r]) };
}
let Ue = (t) => {
  try {
    return t.only([[]]), Ue = () => [[]], [[]];
  } catch {
    return Ue = () => he, he;
  }
};
function Lt(t) {
  return t == null ? () => {
  } : typeof t == "string" ? function(e) {
    return e.split(".").length === 1 ? (n) => n[e] : (n) => te(n, e);
  }(t) : (e) => te(e, t);
}
function kn(t) {
  return [].slice.call(t);
}
let Dr = 0;
function De(t) {
  return t == null ? ":id" : typeof t == "string" ? t : `[${t.join("+")}]`;
}
function Br(t, e, n) {
  function r(a) {
    if (a.type === 3)
      return null;
    if (a.type === 4)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower: c, upper: d, lowerOpen: l, upperOpen: h } = a;
    return c === void 0 ? d === void 0 ? null : e.upperBound(d, !!h) : d === void 0 ? e.lowerBound(c, !!l) : e.bound(c, d, !!l, !!h);
  }
  const { schema: s, hasGetAll: i } = function(a, c) {
    const d = kn(a.objectStoreNames);
    return { schema: { name: a.name, tables: d.map((l) => c.objectStore(l)).map((l) => {
      const { keyPath: h, autoIncrement: f } = l, m = M(h), p = h == null, v = {}, y = { name: l.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: p, compound: m, keyPath: h, autoIncrement: f, unique: !0, extractKey: Lt(h) }, indexes: kn(l.indexNames).map((g) => l.index(g)).map((g) => {
        const { name: b, unique: k, multiEntry: C, keyPath: x } = g, w = { name: b, compound: M(x), keyPath: x, unique: k, multiEntry: C, extractKey: Lt(x) };
        return v[De(x)] = w, w;
      }), getIndexByKeyPath: (g) => v[De(g)] };
      return v[":id"] = y.primaryKey, h != null && (v[De(h)] = y.primaryKey), y;
    }) }, hasGetAll: d.length > 0 && "getAll" in c.objectStore(d[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) };
  }(t, n), o = s.tables.map((a) => function(c) {
    const d = c.name;
    return { name: d, schema: c, mutate: function({ trans: l, type: h, keys: f, values: m, range: p }) {
      return new Promise((v, y) => {
        v = j(v);
        const g = l.objectStore(d), b = g.keyPath == null, k = h === "put" || h === "add";
        if (!k && h !== "delete" && h !== "deleteRange")
          throw new Error("Invalid operation type: " + h);
        const { length: C } = f || m || { length: 1 };
        if (f && m && f.length !== m.length)
          throw new Error("Given keys array must have same length as given values array.");
        if (C === 0)
          return v({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let x;
        const w = [], A = [];
        let _ = 0;
        const R = (q) => {
          ++_, qe(q);
        };
        if (h === "deleteRange") {
          if (p.type === 4)
            return v({ numFailures: _, failures: A, results: [], lastResult: void 0 });
          p.type === 3 ? w.push(x = g.clear()) : w.push(x = g.delete(r(p)));
        } else {
          const [q, B] = k ? b ? [m, f] : [m, null] : [f, null];
          if (k)
            for (let $ = 0; $ < C; ++$)
              w.push(x = B && B[$] !== void 0 ? g[h](q[$], B[$]) : g[h](q[$])), x.onerror = R;
          else
            for (let $ = 0; $ < C; ++$)
              w.push(x = g[h](q[$])), x.onerror = R;
        }
        const O = (q) => {
          const B = q.target.result;
          w.forEach(($, ye) => $.error != null && (A[ye] = $.error)), v({ numFailures: _, failures: A, results: h === "delete" ? f : w.map(($) => $.result), lastResult: B });
        };
        x.onerror = (q) => {
          R(q), O(q);
        }, x.onsuccess = O;
      });
    }, getMany: ({ trans: l, keys: h }) => new Promise((f, m) => {
      f = j(f);
      const p = l.objectStore(d), v = h.length, y = new Array(v);
      let g, b = 0, k = 0;
      const C = (w) => {
        const A = w.target;
        y[A._pos] = A.result, ++k === b && f(y);
      }, x = Y(m);
      for (let w = 0; w < v; ++w)
        h[w] != null && (g = p.get(h[w]), g._pos = w, g.onsuccess = C, g.onerror = x, ++b);
      b === 0 && f(y);
    }), get: ({ trans: l, key: h }) => new Promise((f, m) => {
      f = j(f);
      const p = l.objectStore(d).get(h);
      p.onsuccess = (v) => f(v.target.result), p.onerror = Y(m);
    }), query: function(l) {
      return (h) => new Promise((f, m) => {
        f = j(f);
        const { trans: p, values: v, limit: y, query: g } = h, b = y === 1 / 0 ? void 0 : y, { index: k, range: C } = g, x = p.objectStore(d), w = k.isPrimaryKey ? x : x.index(k.name), A = r(C);
        if (y === 0)
          return f({ result: [] });
        if (l) {
          const _ = v ? w.getAll(A, b) : w.getAllKeys(A, b);
          _.onsuccess = (R) => f({ result: R.target.result }), _.onerror = Y(m);
        } else {
          let _ = 0;
          const R = v || !("openKeyCursor" in w) ? w.openCursor(A) : w.openKeyCursor(A), O = [];
          R.onsuccess = (q) => {
            const B = R.result;
            return B ? (O.push(v ? B.value : B.primaryKey), ++_ === y ? f({ result: O }) : void B.continue()) : f({ result: O });
          }, R.onerror = Y(m);
        }
      });
    }(i), openCursor: function({ trans: l, values: h, query: f, reverse: m, unique: p }) {
      return new Promise((v, y) => {
        v = j(v);
        const { index: g, range: b } = f, k = l.objectStore(d), C = g.isPrimaryKey ? k : k.index(g.name), x = m ? p ? "prevunique" : "prev" : p ? "nextunique" : "next", w = h || !("openKeyCursor" in C) ? C.openCursor(r(b), x) : C.openKeyCursor(r(b), x);
        w.onerror = Y(y), w.onsuccess = j((A) => {
          const _ = w.result;
          if (!_)
            return void v(null);
          _.___id = ++Dr, _.done = !1;
          const R = _.continue.bind(_);
          let O = _.continuePrimaryKey;
          O && (O = O.bind(_));
          const q = _.advance.bind(_), B = () => {
            throw new Error("Cursor not stopped");
          };
          _.trans = l, _.stop = _.continue = _.continuePrimaryKey = _.advance = () => {
            throw new Error("Cursor not started");
          }, _.fail = j(y), _.next = function() {
            let $ = 1;
            return this.start(() => $-- ? this.continue() : this.stop()).then(() => this);
          }, _.start = ($) => {
            const ye = new Promise((V, le) => {
              V = j(V), w.onerror = Y(le), _.fail = le, _.stop = (Ae) => {
                _.stop = _.continue = _.continuePrimaryKey = _.advance = B, V(Ae);
              };
            }), ve = () => {
              if (w.result)
                try {
                  $();
                } catch (V) {
                  _.fail(V);
                }
              else
                _.done = !0, _.start = () => {
                  throw new Error("Cursor behind last entry");
                }, _.stop();
            };
            return w.onsuccess = j((V) => {
              w.onsuccess = ve, ve();
            }), _.continue = R, _.continuePrimaryKey = O, _.advance = q, ve(), ye;
          }, v(_);
        }, y);
      });
    }, count({ query: l, trans: h }) {
      const { index: f, range: m } = l;
      return new Promise((p, v) => {
        const y = h.objectStore(d), g = f.isPrimaryKey ? y : y.index(f.name), b = r(m), k = b ? g.count(b) : g.count();
        k.onsuccess = j((C) => p(C.target.result)), k.onerror = Y(v);
      });
    } };
  }(a)), u = {};
  return o.forEach((a) => u[a.name] = a), { stack: "dbcore", transaction: t.transaction.bind(t), table(a) {
    if (!u[a])
      throw new Error(`Table '${a}' not found`);
    return u[a];
  }, MIN_KEY: -1 / 0, MAX_KEY: Ue(e), schema: s };
}
function Ut({ _novip: t }, e) {
  const n = e.db, r = function(s, i, { IDBKeyRange: o, indexedDB: u }, a) {
    return { dbcore: function(c, d) {
      return d.reduce((l, { create: h }) => ({ ...l, ...h(l) }), c);
    }(Br(i, o, a), s.dbcore) };
  }(t._middlewares, n, t._deps, e);
  t.core = r.dbcore, t.tables.forEach((s) => {
    const i = s.name;
    t.core.schema.tables.some((o) => o.name === i) && (s.core = t.core.table(i), t[i] instanceof t.Table && (t[i].core = s.core));
  });
}
function pt({ _novip: t }, e, n, r) {
  n.forEach((s) => {
    const i = r[s];
    e.forEach((o) => {
      const u = Jt(o, s);
      (!u || "value" in u && u.value === void 0) && (o === t.Transaction.prototype || o instanceof t.Transaction ? ee(o, s, { get() {
        return this.table(s);
      }, set(a) {
        Cn(this, s, { value: a, writable: !0, configurable: !0, enumerable: !0 });
      } }) : o[s] = new t.Table(s, i));
    });
  });
}
function Vt({ _novip: t }, e) {
  e.forEach((n) => {
    for (let r in n)
      n[r] instanceof t.Table && delete n[r];
  });
}
function Fr(t, e) {
  return t._cfg.version - e._cfg.version;
}
function Mr(t, e, n, r) {
  const s = t._dbSchema, i = t._createTransaction("readwrite", t._storeNames, s);
  i.create(n), i._completion.catch(r);
  const o = i._reject.bind(i), u = P.transless || P;
  oe(() => {
    P.trans = i, P.transless = u, e === 0 ? (N(s).forEach((a) => {
      Ct(n, a, s[a].primKey, s[a].indexes);
    }), Ut(t, n), S.follow(() => t.on.populate.fire(i)).catch(o)) : function({ _novip: a }, c, d, l) {
      const h = [], f = a._versions;
      let m = a._dbSchema = zt(a, a.idbdb, l), p = !1;
      const v = f.filter((g) => g._cfg.version >= c);
      function y() {
        return h.length ? S.resolve(h.shift()(d.idbtrans)).then(y) : S.resolve();
      }
      return v.forEach((g) => {
        h.push(() => {
          const b = m, k = g._cfg.dbschema;
          Ht(a, b, l), Ht(a, k, l), m = a._dbSchema = k;
          const C = Jn(b, k);
          C.add.forEach((w) => {
            Ct(l, w[0], w[1].primKey, w[1].indexes);
          }), C.change.forEach((w) => {
            if (w.recreate)
              throw new E.Upgrade("Not yet support for changing primary key");
            {
              const A = l.objectStore(w.name);
              w.add.forEach((_) => Wt(A, _)), w.change.forEach((_) => {
                A.deleteIndex(_.name), Wt(A, _);
              }), w.del.forEach((_) => A.deleteIndex(_));
            }
          });
          const x = g._cfg.contentUpgrade;
          if (x && g._cfg.version > c) {
            Ut(a, l), d._memoizedTables = {}, p = !0;
            let w = An(k);
            C.del.forEach((O) => {
              w[O] = b[O];
            }), Vt(a, [a.Transaction.prototype]), pt(a, [a.Transaction.prototype], N(w), w), d.schema = w;
            const A = Zt(x);
            let _;
            A && Ee();
            const R = S.follow(() => {
              if (_ = x(d), _ && A) {
                var O = ne.bind(null, null);
                _.then(O, O);
              }
            });
            return _ && typeof _.then == "function" ? S.resolve(_) : R.then(() => _);
          }
        }), h.push((b) => {
          (!p || !Ar) && function(k, C) {
            [].slice.call(C.db.objectStoreNames).forEach((x) => k[x] == null && C.db.deleteObjectStore(x));
          }(g._cfg.dbschema, b), Vt(a, [a.Transaction.prototype]), pt(a, [a.Transaction.prototype], a._storeNames, a._dbSchema), d.schema = a._dbSchema;
        });
      }), y().then(() => {
        var g, b;
        b = l, N(g = m).forEach((k) => {
          b.db.objectStoreNames.contains(k) || Ct(b, k, g[k].primKey, g[k].indexes);
        });
      });
    }(t, e, i, n).catch(o);
  });
}
function Jn(t, e) {
  const n = { del: [], add: [], change: [] };
  let r;
  for (r in t)
    e[r] || n.del.push(r);
  for (r in e) {
    const s = t[r], i = e[r];
    if (s) {
      const o = { name: r, def: i, recreate: !1, del: [], add: [], change: [] };
      if ("" + (s.primKey.keyPath || "") != "" + (i.primKey.keyPath || "") || s.primKey.auto !== i.primKey.auto && !gt)
        o.recreate = !0, n.change.push(o);
      else {
        const u = s.idxByName, a = i.idxByName;
        let c;
        for (c in u)
          a[c] || o.del.push(c);
        for (c in a) {
          const d = u[c], l = a[c];
          d ? d.src !== l.src && o.change.push(l) : o.add.push(l);
        }
        (o.del.length > 0 || o.add.length > 0 || o.change.length > 0) && n.change.push(o);
      }
    } else
      n.add.push([r, i]);
  }
  return n;
}
function Ct(t, e, n, r) {
  const s = t.db.createObjectStore(e, n.keyPath ? { keyPath: n.keyPath, autoIncrement: n.auto } : { autoIncrement: n.auto });
  return r.forEach((i) => Wt(s, i)), s;
}
function Wt(t, e) {
  t.createIndex(e.name, e.keyPath, { unique: e.unique, multiEntry: e.multi });
}
function zt(t, e, n) {
  const r = {};
  return ut(e.objectStoreNames, 0).forEach((s) => {
    const i = n.objectStore(s);
    let o = i.keyPath;
    const u = qt(Xn(o), o || "", !1, !1, !!i.autoIncrement, o && typeof o != "string", !0), a = [];
    for (let d = 0; d < i.indexNames.length; ++d) {
      const l = i.index(i.indexNames[d]);
      o = l.keyPath;
      var c = qt(l.name, o, !!l.unique, !!l.multiEntry, !1, o && typeof o != "string", !1);
      a.push(c);
    }
    r[s] = Qn(s, u, a);
  }), r;
}
function Ht({ _novip: t }, e, n) {
  const r = n.db.objectStoreNames;
  for (let s = 0; s < r.length; ++s) {
    const i = r[s], o = n.objectStore(i);
    t._hasGetAll = "getAll" in o;
    for (let u = 0; u < o.indexNames.length; ++u) {
      const a = o.indexNames[u], c = o.index(a).keyPath, d = typeof c == "string" ? c : "[" + ut(c).join("+") + "]";
      if (e[i]) {
        const l = e[i].idxByName[d];
        l && (l.name = a, delete e[i].idxByName[d], e[i].idxByName[a] = l);
      }
    }
  }
  typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && K.WorkerGlobalScope && K instanceof K.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (t._hasGetAll = !1);
}
class qr {
  _parseStoresSpec(e, n) {
    N(e).forEach((r) => {
      if (e[r] !== null) {
        var s = e[r].split(",").map((o, u) => {
          const a = (o = o.trim()).replace(/([&*]|\+\+)/g, ""), c = /^\[/.test(a) ? a.match(/^\[(.*)\]$/)[1].split("+") : a;
          return qt(a, c || null, /\&/.test(o), /\*/.test(o), /\+\+/.test(o), M(c), u === 0);
        }), i = s.shift();
        if (i.multi)
          throw new E.Schema("Primary key cannot be multi-valued");
        s.forEach((o) => {
          if (o.auto)
            throw new E.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!o.keyPath)
            throw new E.Schema("Index must have a name and cannot be an empty string");
        }), n[r] = Qn(r, i, s);
      }
    });
  }
  stores(e) {
    const n = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? U(this._cfg.storesSource, e) : e;
    const r = n._versions, s = {};
    let i = {};
    return r.forEach((o) => {
      U(s, o._cfg.storesSource), i = o._cfg.dbschema = {}, o._parseStoresSpec(s, i);
    }), n._dbSchema = i, Vt(n, [n._allTables, n, n.Transaction.prototype]), pt(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], N(i), i), n._storeNames = N(i), this;
  }
  upgrade(e) {
    return this._cfg.contentUpgrade = nn(this._cfg.contentUpgrade || I, e), this;
  }
}
function an(t, e) {
  let n = t._dbNamesDB;
  return n || (n = t._dbNamesDB = new pe(yt, { addons: [], indexedDB: t, IDBKeyRange: e }), n.version(1).stores({ dbnames: "name" })), n.table("dbnames");
}
function un(t) {
  return t && typeof t.databases == "function";
}
function Yt(t) {
  return oe(function() {
    return P.letThrough = !0, t();
  });
}
function Lr() {
  var t;
  return !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(e) {
    var n = function() {
      return indexedDB.databases().finally(e);
    };
    t = setInterval(n, 100), n();
  }).finally(function() {
    return clearInterval(t);
  }) : Promise.resolve();
}
function Ur(t) {
  const e = t._state, { indexedDB: n } = t._deps;
  if (e.isBeingOpened || t.idbdb)
    return e.dbReadyPromise.then(() => e.dbOpenError ? D(e.dbOpenError) : t);
  G && (e.openCanceller._stackHolder = Pe()), e.isBeingOpened = !0, e.dbOpenError = null, e.openComplete = !1;
  const r = e.openCanceller;
  function s() {
    if (e.openCanceller !== r)
      throw new E.DatabaseClosed("db.open() was cancelled");
  }
  let i = e.dbReadyResolve, o = null, u = !1;
  return S.race([r, (typeof navigator > "u" ? S.resolve() : Lr()).then(() => new S((a, c) => {
    if (s(), !n)
      throw new E.MissingAPI();
    const d = t.name, l = e.autoSchema ? n.open(d) : n.open(d, Math.round(10 * t.verno));
    if (!l)
      throw new E.MissingAPI();
    l.onerror = Y(c), l.onblocked = j(t._fireOnBlocked), l.onupgradeneeded = j((h) => {
      if (o = l.transaction, e.autoSchema && !t._options.allowEmptyDB) {
        l.onerror = qe, o.abort(), l.result.close();
        const m = n.deleteDatabase(d);
        m.onsuccess = m.onerror = j(() => {
          c(new E.NoSuchDatabase(`Database ${d} doesnt exist`));
        });
      } else {
        o.onerror = Y(c);
        var f = h.oldVersion > Math.pow(2, 62) ? 0 : h.oldVersion;
        u = f < 1, t._novip.idbdb = l.result, Mr(t, f / 10, o, c);
      }
    }, c), l.onsuccess = j(() => {
      o = null;
      const h = t._novip.idbdb = l.result, f = ut(h.objectStoreNames);
      if (f.length > 0)
        try {
          const p = h.transaction((m = f).length === 1 ? m[0] : m, "readonly");
          e.autoSchema ? function({ _novip: v }, y, g) {
            v.verno = y.version / 10;
            const b = v._dbSchema = zt(0, y, g);
            v._storeNames = ut(y.objectStoreNames, 0), pt(v, [v._allTables], N(b), b);
          }(t, h, p) : (Ht(t, t._dbSchema, p), function(v, y) {
            const g = Jn(zt(0, v.idbdb, y), v._dbSchema);
            return !(g.add.length || g.change.some((b) => b.add.length || b.change.length));
          }(t, p) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), Ut(t, p);
        } catch {
        }
      var m;
      $e.push(t), h.onversionchange = j((p) => {
        e.vcFired = !0, t.on("versionchange").fire(p);
      }), h.onclose = j((p) => {
        t.on("close").fire(p);
      }), u && function({ indexedDB: p, IDBKeyRange: v }, y) {
        !un(p) && y !== yt && an(p, v).put({ name: y }).catch(I);
      }(t._deps, d), a();
    }, c);
  }))]).then(() => (s(), e.onReadyBeingFired = [], S.resolve(Yt(() => t.on.ready.fire(t.vip))).then(function a() {
    if (e.onReadyBeingFired.length > 0) {
      let c = e.onReadyBeingFired.reduce(nn, I);
      return e.onReadyBeingFired = [], S.resolve(Yt(() => c(t.vip))).then(a);
    }
  }))).finally(() => {
    e.onReadyBeingFired = null, e.isBeingOpened = !1;
  }).then(() => t).catch((a) => {
    e.dbOpenError = a;
    try {
      o && o.abort();
    } catch {
    }
    return r === e.openCanceller && t._close(), D(a);
  }).finally(() => {
    e.openComplete = !0, i();
  });
}
function Gt(t) {
  var e = (i) => t.next(i), n = s(e), r = s((i) => t.throw(i));
  function s(i) {
    return (o) => {
      var u = i(o), a = u.value;
      return u.done ? a : a && typeof a.then == "function" ? a.then(n, r) : M(a) ? Promise.all(a).then(n, r) : n(a);
    };
  }
  return s(e)();
}
function Vr(t, e, n) {
  var r = arguments.length;
  if (r < 2)
    throw new E.InvalidArgument("Too few arguments");
  for (var s = new Array(r - 1); --r; )
    s[r - 1] = arguments[r];
  return n = s.pop(), [t, On(s), n];
}
function Zn(t, e, n, r, s) {
  return S.resolve().then(() => {
    const i = P.transless || P, o = t._createTransaction(e, n, t._dbSchema, r), u = { trans: o, transless: i };
    if (r)
      o.idbtrans = r.idbtrans;
    else
      try {
        o.create(), t._state.PR1398_maxLoop = 3;
      } catch (l) {
        return l.name === tn.InvalidState && t.isOpen() && --t._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), t._close(), t.open().then(() => Zn(t, e, n, null, s))) : D(l);
      }
    const a = Zt(s);
    let c;
    a && Ee();
    const d = S.follow(() => {
      if (c = s.call(o, o), c)
        if (a) {
          var l = ne.bind(null, null);
          c.then(l, l);
        } else
          typeof c.next == "function" && typeof c.throw == "function" && (c = Gt(c));
    }, u);
    return (c && typeof c.then == "function" ? S.resolve(c).then((l) => o.active ? l : D(new E.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : d.then(() => c)).then((l) => (r && o._resolve(), o._completion.then(() => l))).catch((l) => (o._reject(l), D(l)));
  });
}
function et(t, e, n) {
  const r = M(t) ? t.slice() : [t];
  for (let s = 0; s < n; ++s)
    r.push(e);
  return r;
}
const Wr = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(t) {
  return { ...t, table(e) {
    const n = t.table(e), { schema: r } = n, s = {}, i = [];
    function o(c, d, l) {
      const h = De(c), f = s[h] = s[h] || [], m = c == null ? 0 : typeof c == "string" ? 1 : c.length, p = d > 0, v = { ...l, isVirtual: p, keyTail: d, keyLength: m, extractKey: Lt(c), unique: !p && l.unique };
      return f.push(v), v.isPrimaryKey || i.push(v), m > 1 && o(m === 2 ? c[0] : c.slice(0, m - 1), d + 1, l), f.sort((y, g) => y.keyTail - g.keyTail), v;
    }
    const u = o(r.primaryKey.keyPath, 0, r.primaryKey);
    s[":id"] = [u];
    for (const c of r.indexes)
      o(c.keyPath, 0, c);
    function a(c) {
      const d = c.query.index;
      return d.isVirtual ? { ...c, query: { index: d, range: (l = c.query.range, h = d.keyTail, { type: l.type === 1 ? 2 : l.type, lower: et(l.lower, l.lowerOpen ? t.MAX_KEY : t.MIN_KEY, h), lowerOpen: !0, upper: et(l.upper, l.upperOpen ? t.MIN_KEY : t.MAX_KEY, h), upperOpen: !0 }) } } : c;
      var l, h;
    }
    return { ...n, schema: { ...r, primaryKey: u, indexes: i, getIndexByKeyPath: function(c) {
      const d = s[De(c)];
      return d && d[0];
    } }, count: (c) => n.count(a(c)), query: (c) => n.query(a(c)), openCursor(c) {
      const { keyTail: d, isVirtual: l, keyLength: h } = c.query.index;
      return l ? n.openCursor(a(c)).then((f) => f && function(m) {
        return Object.create(m, { continue: { value: function(p) {
          p != null ? m.continue(et(p, c.reverse ? t.MAX_KEY : t.MIN_KEY, d)) : c.unique ? m.continue(m.key.slice(0, h).concat(c.reverse ? t.MIN_KEY : t.MAX_KEY, d)) : m.continue();
        } }, continuePrimaryKey: { value(p, v) {
          m.continuePrimaryKey(et(p, t.MAX_KEY, d), v);
        } }, primaryKey: { get: () => m.primaryKey }, key: { get() {
          const p = m.key;
          return h === 1 ? p[0] : p.slice(0, h);
        } }, value: { get: () => m.value } });
      }(f)) : n.openCursor(c);
    } };
  } };
} };
function ln(t, e, n, r) {
  return n = n || {}, r = r || "", N(t).forEach((s) => {
    if (z(e, s)) {
      var i = t[s], o = e[s];
      if (typeof i == "object" && typeof o == "object" && i && o) {
        const u = Tt(i);
        u !== Tt(o) ? n[r + s] = e[s] : u === "Object" ? ln(i, o, n, r + s + ".") : i !== o && (n[r + s] = e[s]);
      } else
        i !== o && (n[r + s] = e[s]);
    } else
      n[r + s] = void 0;
  }), N(e).forEach((s) => {
    z(t, s) || (n[r + s] = e[s]);
  }), n;
}
const zr = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: (t) => ({ ...t, table(e) {
  const n = t.table(e), { primaryKey: r } = n.schema;
  return { ...n, mutate(s) {
    const i = P.trans, { deleting: o, creating: u, updating: a } = i.table(e).hook;
    switch (s.type) {
      case "add":
        if (u.fire === I)
          break;
        return i._promise("readwrite", () => c(s), !0);
      case "put":
        if (u.fire === I && a.fire === I)
          break;
        return i._promise("readwrite", () => c(s), !0);
      case "delete":
        if (o.fire === I)
          break;
        return i._promise("readwrite", () => c(s), !0);
      case "deleteRange":
        if (o.fire === I)
          break;
        return i._promise("readwrite", () => function(l) {
          return d(l.trans, l.range, 1e4);
        }(s), !0);
    }
    return n.mutate(s);
    function c(l) {
      const h = P.trans, f = l.keys || function(m, p) {
        return p.type === "delete" ? p.keys : p.keys || p.values.map(m.extractKey);
      }(r, l);
      if (!f)
        throw new Error("Keys missing");
      return (l = l.type === "add" || l.type === "put" ? { ...l, keys: f } : { ...l }).type !== "delete" && (l.values = [...l.values]), l.keys && (l.keys = [...l.keys]), function(m, p, v) {
        return p.type === "add" ? Promise.resolve([]) : m.getMany({ trans: p.trans, keys: v, cache: "immutable" });
      }(n, l, f).then((m) => {
        const p = f.map((v, y) => {
          const g = m[y], b = { onerror: null, onsuccess: null };
          if (l.type === "delete")
            o.fire.call(b, v, g, h);
          else if (l.type === "add" || g === void 0) {
            const k = u.fire.call(b, v, l.values[y], h);
            v == null && k != null && (v = k, l.keys[y] = v, r.outbound || H(l.values[y], r.keyPath, v));
          } else {
            const k = ln(g, l.values[y]), C = a.fire.call(b, k, v, g, h);
            if (C) {
              const x = l.values[y];
              Object.keys(C).forEach((w) => {
                z(x, w) ? x[w] = C[w] : H(x, w, C[w]);
              });
            }
          }
          return b;
        });
        return n.mutate(l).then(({ failures: v, results: y, numFailures: g, lastResult: b }) => {
          for (let k = 0; k < f.length; ++k) {
            const C = y ? y[k] : f[k], x = p[k];
            C == null ? x.onerror && x.onerror(v[k]) : x.onsuccess && x.onsuccess(l.type === "put" && m[k] ? l.values[k] : C);
          }
          return { failures: v, results: y, numFailures: g, lastResult: b };
        }).catch((v) => (p.forEach((y) => y.onerror && y.onerror(v)), Promise.reject(v)));
      });
    }
    function d(l, h, f) {
      return n.query({ trans: l, values: !1, query: { index: r, range: h }, limit: f }).then(({ result: m }) => c({ type: "delete", keys: m, trans: l }).then((p) => p.numFailures > 0 ? Promise.reject(p.failures[0]) : m.length < f ? { failures: [], numFailures: 0, lastResult: void 0 } : d(l, { ...h, lower: m[m.length - 1], lowerOpen: !0 }, f)));
    }
  } };
} }) };
function er(t, e, n) {
  try {
    if (!e || e.keys.length < t.length)
      return null;
    const r = [];
    for (let s = 0, i = 0; s < e.keys.length && i < t.length; ++s)
      L(e.keys[s], t[i]) === 0 && (r.push(n ? We(e.values[s]) : e.values[s]), ++i);
    return r.length === t.length ? r : null;
  } catch {
    return null;
  }
}
const Hr = { stack: "dbcore", level: -1, create: (t) => ({ table: (e) => {
  const n = t.table(e);
  return { ...n, getMany: (r) => {
    if (!r.cache)
      return n.getMany(r);
    const s = er(r.keys, r.trans._cache, r.cache === "clone");
    return s ? S.resolve(s) : n.getMany(r).then((i) => (r.trans._cache = { keys: r.keys, values: r.cache === "clone" ? We(i) : i }, i));
  }, mutate: (r) => (r.type !== "add" && (r.trans._cache = null), n.mutate(r)) };
} }) };
function cn(t) {
  return !("from" in t);
}
const Q = function(t, e) {
  if (!this) {
    const n = new Q();
    return t && "d" in t && U(n, t), n;
  }
  U(this, arguments.length ? { d: 1, from: t, to: arguments.length > 1 ? e : t } : { d: 0 });
};
function Ve(t, e, n) {
  const r = L(e, n);
  if (isNaN(r))
    return;
  if (r > 0)
    throw RangeError();
  if (cn(t))
    return U(t, { from: e, to: n, d: 1 });
  const s = t.l, i = t.r;
  if (L(n, t.from) < 0)
    return s ? Ve(s, e, n) : t.l = { from: e, to: n, d: 1, l: null, r: null }, xn(t);
  if (L(e, t.to) > 0)
    return i ? Ve(i, e, n) : t.r = { from: e, to: n, d: 1, l: null, r: null }, xn(t);
  L(e, t.from) < 0 && (t.from = e, t.l = null, t.d = i ? i.d + 1 : 1), L(n, t.to) > 0 && (t.to = n, t.r = null, t.d = t.l ? t.l.d + 1 : 1);
  const o = !t.r;
  s && !t.l && mt(t, s), i && o && mt(t, i);
}
function mt(t, e) {
  cn(e) || function n(r, { from: s, to: i, l: o, r: u }) {
    Ve(r, s, i), o && n(r, o), u && n(r, u);
  }(t, e);
}
function Yr(t, e) {
  const n = Xt(e);
  let r = n.next();
  if (r.done)
    return !1;
  let s = r.value;
  const i = Xt(t);
  let o = i.next(s.from), u = o.value;
  for (; !r.done && !o.done; ) {
    if (L(u.from, s.to) <= 0 && L(u.to, s.from) >= 0)
      return !0;
    L(s.from, u.from) < 0 ? s = (r = n.next(u.from)).value : u = (o = i.next(s.from)).value;
  }
  return !1;
}
function Xt(t) {
  let e = cn(t) ? null : { s: 0, n: t };
  return { next(n) {
    const r = arguments.length > 0;
    for (; e; )
      switch (e.s) {
        case 0:
          if (e.s = 1, r)
            for (; e.n.l && L(n, e.n.from) < 0; )
              e = { up: e, n: e.n.l, s: 1 };
          else
            for (; e.n.l; )
              e = { up: e, n: e.n.l, s: 1 };
        case 1:
          if (e.s = 2, !r || L(n, e.n.to) <= 0)
            return { value: e.n, done: !1 };
        case 2:
          if (e.n.r) {
            e.s = 3, e = { up: e, n: e.n.r, s: 0 };
            continue;
          }
        case 3:
          e = e.up;
      }
    return { done: !0 };
  } };
}
function xn(t) {
  var e, n;
  const r = (((e = t.r) === null || e === void 0 ? void 0 : e.d) || 0) - (((n = t.l) === null || n === void 0 ? void 0 : n.d) || 0), s = r > 1 ? "r" : r < -1 ? "l" : "";
  if (s) {
    const i = s === "r" ? "l" : "r", o = { ...t }, u = t[s];
    t.from = u.from, t.to = u.to, t[s] = u[s], o[s] = u[i], t[i] = o, o.d = Sn(o);
  }
  t.d = Sn(t);
}
function Sn({ r: t, l: e }) {
  return (t ? e ? Math.max(t.d, e.d) : t.d : e ? e.d : 0) + 1;
}
Ce(Q.prototype, { add(t) {
  return mt(this, t), this;
}, addKey(t) {
  return Ve(this, t, t), this;
}, addKeys(t) {
  return t.forEach((e) => Ve(this, e, e)), this;
}, [At]() {
  return Xt(this);
} });
const Gr = { stack: "dbcore", level: 0, create: (t) => {
  const e = t.schema.name, n = new Q(t.MIN_KEY, t.MAX_KEY);
  return { ...t, table: (r) => {
    const s = t.table(r), { schema: i } = s, { primaryKey: o } = i, { extractKey: u, outbound: a } = o, c = { ...s, mutate: (h) => {
      const f = h.trans, m = f.mutatedParts || (f.mutatedParts = {}), p = (x) => {
        const w = `idb://${e}/${r}/${x}`;
        return m[w] || (m[w] = new Q());
      }, v = p(""), y = p(":dels"), { type: g } = h;
      let [b, k] = h.type === "deleteRange" ? [h.range] : h.type === "delete" ? [h.keys] : h.values.length < 50 ? [[], h.values] : [];
      const C = h.trans._cache;
      return s.mutate(h).then((x) => {
        if (M(b)) {
          g !== "delete" && (b = x.results), v.addKeys(b);
          const w = er(b, C);
          w || g === "add" || y.addKeys(b), (w || k) && function(A, _, R, O) {
            function q(B) {
              const $ = A(B.name || "");
              function ye(V) {
                return V != null ? B.extractKey(V) : null;
              }
              const ve = (V) => B.multiEntry && M(V) ? V.forEach((le) => $.addKey(le)) : $.addKey(V);
              (R || O).forEach((V, le) => {
                const Ae = R && ye(R[le]), vt = O && ye(O[le]);
                L(Ae, vt) !== 0 && (Ae != null && ve(Ae), vt != null && ve(vt));
              });
            }
            _.indexes.forEach(q);
          }(p, i, w, k);
        } else if (b) {
          const w = { from: b.lower, to: b.upper };
          y.add(w), v.add(w);
        } else
          v.add(n), y.add(n), i.indexes.forEach((w) => p(w.name).add(n));
        return x;
      });
    } }, d = ({ query: { index: h, range: f } }) => {
      var m, p;
      return [h, new Q((m = f.lower) !== null && m !== void 0 ? m : t.MIN_KEY, (p = f.upper) !== null && p !== void 0 ? p : t.MAX_KEY)];
    }, l = { get: (h) => [o, new Q(h.key)], getMany: (h) => [o, new Q().addKeys(h.keys)], count: d, query: d, openCursor: d };
    return N(l).forEach((h) => {
      c[h] = function(f) {
        const { subscr: m } = P;
        if (m) {
          const p = (k) => {
            const C = `idb://${e}/${r}/${k}`;
            return m[C] || (m[C] = new Q());
          }, v = p(""), y = p(":dels"), [g, b] = l[h](f);
          if (p(g.name || "").add(b), !g.isPrimaryKey) {
            if (h !== "count") {
              const k = h === "query" && a && f.values && s.query({ ...f, values: !1 });
              return s[h].apply(this, arguments).then((C) => {
                if (h === "query") {
                  if (a && f.values)
                    return k.then(({ result: w }) => (v.addKeys(w), C));
                  const x = f.values ? C.result.map(u) : C.result;
                  f.values ? v.addKeys(x) : y.addKeys(x);
                } else if (h === "openCursor") {
                  const x = C, w = f.values;
                  return x && Object.create(x, { key: { get: () => (y.addKey(x.primaryKey), x.key) }, primaryKey: { get() {
                    const A = x.primaryKey;
                    return y.addKey(A), A;
                  } }, value: { get: () => (w && v.addKey(x.primaryKey), x.value) } });
                }
                return C;
              });
            }
            y.add(n);
          }
        }
        return s[h].apply(this, arguments);
      };
    }), c;
  } };
} };
class pe {
  constructor(e, n) {
    this._middlewares = {}, this.verno = 0;
    const r = pe.dependencies;
    this._options = n = { addons: pe.addons, autoOpen: !0, indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange, ...n }, this._deps = { indexedDB: n.indexedDB, IDBKeyRange: n.IDBKeyRange };
    const { addons: s } = n;
    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
    const i = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: I, dbReadyPromise: null, cancelOpen: I, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3 };
    var o;
    i.dbReadyPromise = new S((u) => {
      i.dbReadyResolve = u;
    }), i.openCanceller = new S((u, a) => {
      i.cancelOpen = a;
    }), this._state = i, this.name = e, this.on = Ne(this, "populate", "blocked", "versionchange", "close", { ready: [nn, I] }), this.on.ready.subscribe = Pn(this.on.ready.subscribe, (u) => (a, c) => {
      pe.vip(() => {
        const d = this._state;
        if (d.openComplete)
          d.dbOpenError || S.resolve().then(a), c && u(a);
        else if (d.onReadyBeingFired)
          d.onReadyBeingFired.push(a), c && u(a);
        else {
          u(a);
          const l = this;
          c || u(function h() {
            l.on.ready.unsubscribe(a), l.on.ready.unsubscribe(h);
          });
        }
      });
    }), this.Collection = (o = this, Oe(Kr.prototype, function(u, a) {
      this.db = o;
      let c = Hn, d = null;
      if (a)
        try {
          c = a();
        } catch (m) {
          d = m;
        }
      const l = u._ctx, h = l.table, f = h.hook.reading.fire;
      this._ctx = { table: h, index: l.index, isPrimKey: !l.index || h.schema.primKey.keyPath && l.index === h.schema.primKey.name, range: c, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: d, or: l.or, valueMapper: f !== Fe ? f : null };
    })), this.Table = function(u) {
      return Oe(Ir.prototype, function(a, c, d) {
        this.db = u, this._tx = d, this.name = a, this.schema = c, this.hook = u._allTables[a] ? u._allTables[a].hook : Ne(null, { creating: [br, I], reading: [vr, Fe], updating: [_r, I], deleting: [wr, I] });
      });
    }(this), this.Transaction = function(u) {
      return Oe(Nr.prototype, function(a, c, d, l, h) {
        this.db = u, this.mode = a, this.storeNames = c, this.schema = d, this.chromeTransactionDurability = l, this.idbtrans = null, this.on = Ne(this, "complete", "error", "abort"), this.parent = h || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new S((f, m) => {
          this._resolve = f, this._reject = m;
        }), this._completion.then(() => {
          this.active = !1, this.on.complete.fire();
        }, (f) => {
          var m = this.active;
          return this.active = !1, this.on.error.fire(f), this.parent ? this.parent._reject(f) : m && this.idbtrans && this.idbtrans.abort(), D(f);
        });
      });
    }(this), this.Version = function(u) {
      return Oe(qr.prototype, function(a) {
        this.db = u, this._cfg = { version: a, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      });
    }(this), this.WhereClause = function(u) {
      return Oe(Gn.prototype, function(a, c, d) {
        this.db = u, this._ctx = { table: a, index: c === ":id" ? null : c, or: d };
        const l = u._deps.indexedDB;
        if (!l)
          throw new E.MissingAPI();
        this._cmp = this._ascending = l.cmp.bind(l), this._descending = (h, f) => l.cmp(f, h), this._max = (h, f) => l.cmp(h, f) > 0 ? h : f, this._min = (h, f) => l.cmp(h, f) < 0 ? h : f, this._IDBKeyRange = u._deps.IDBKeyRange;
      });
    }(this), this.on("versionchange", (u) => {
      u.newVersion > 0 ? console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`), this.close();
    }), this.on("blocked", (u) => {
      !u.newVersion || u.newVersion < u.oldVersion ? console.warn(`Dexie.delete('${this.name}') was blocked`) : console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${u.oldVersion / 10}`);
    }), this._maxKey = Ue(n.IDBKeyRange), this._createTransaction = (u, a, c, d) => new this.Transaction(u, a, c, this._options.chromeTransactionDurability, d), this._fireOnBlocked = (u) => {
      this.on("blocked").fire(u), $e.filter((a) => a.name === this.name && a !== this && !a._state.vcFired).map((a) => a.on("versionchange").fire(u));
    }, this.use(Wr), this.use(zr), this.use(Gr), this.use(Hr), this.vip = Object.create(this, { _vip: { value: !0 } }), s.forEach((u) => u(this));
  }
  version(e) {
    if (isNaN(e) || e < 0.1)
      throw new E.Type("Given version is not a positive number");
    if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened)
      throw new E.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, e);
    const n = this._versions;
    var r = n.filter((s) => s._cfg.version === e)[0];
    return r || (r = new this.Version(e), n.push(r), n.sort(Fr), r.stores({}), this._state.autoSchema = !1, r);
  }
  _whenReady(e) {
    return this.idbdb && (this._state.openComplete || P.letThrough || this._vip) ? e() : new S((n, r) => {
      if (this._state.openComplete)
        return r(new E.DatabaseClosed(this._state.dbOpenError));
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen)
          return void r(new E.DatabaseClosed());
        this.open().catch(I);
      }
      this._state.dbReadyPromise.then(n, r);
    }).then(e);
  }
  use({ stack: e, create: n, level: r, name: s }) {
    s && this.unuse({ stack: e, name: s });
    const i = this._middlewares[e] || (this._middlewares[e] = []);
    return i.push({ stack: e, create: n, level: r ?? 10, name: s }), i.sort((o, u) => o.level - u.level), this;
  }
  unuse({ stack: e, name: n, create: r }) {
    return e && this._middlewares[e] && (this._middlewares[e] = this._middlewares[e].filter((s) => r ? s.create !== r : !!n && s.name !== n)), this;
  }
  open() {
    return Ur(this);
  }
  _close() {
    const e = this._state, n = $e.indexOf(this);
    if (n >= 0 && $e.splice(n, 1), this.idbdb) {
      try {
        this.idbdb.close();
      } catch {
      }
      this._novip.idbdb = null;
    }
    e.dbReadyPromise = new S((r) => {
      e.dbReadyResolve = r;
    }), e.openCanceller = new S((r, s) => {
      e.cancelOpen = s;
    });
  }
  close() {
    this._close();
    const e = this._state;
    this._options.autoOpen = !1, e.dbOpenError = new E.DatabaseClosed(), e.isBeingOpened && e.cancelOpen(e.dbOpenError);
  }
  delete() {
    const e = arguments.length > 0, n = this._state;
    return new S((r, s) => {
      const i = () => {
        this.close();
        var o = this._deps.indexedDB.deleteDatabase(this.name);
        o.onsuccess = j(() => {
          (function({ indexedDB: u, IDBKeyRange: a }, c) {
            !un(u) && c !== yt && an(u, a).delete(c).catch(I);
          })(this._deps, this.name), r();
        }), o.onerror = Y(s), o.onblocked = this._fireOnBlocked;
      };
      if (e)
        throw new E.InvalidArgument("Arguments not allowed in db.delete()");
      n.isBeingOpened ? n.dbReadyPromise.then(i) : i();
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return this.idbdb !== null;
  }
  hasBeenClosed() {
    const e = this._state.dbOpenError;
    return e && e.name === "DatabaseClosed";
  }
  hasFailed() {
    return this._state.dbOpenError !== null;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return N(this._allTables).map((e) => this._allTables[e]);
  }
  transaction() {
    const e = Vr.apply(this, arguments);
    return this._transaction.apply(this, e);
  }
  _transaction(e, n, r) {
    let s = P.trans;
    s && s.db === this && e.indexOf("!") === -1 || (s = null);
    const i = e.indexOf("?") !== -1;
    let o, u;
    e = e.replace("!", "").replace("?", "");
    try {
      if (u = n.map((c) => {
        var d = c instanceof this.Table ? c.name : c;
        if (typeof d != "string")
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return d;
      }), e == "r" || e === wt)
        o = wt;
      else {
        if (e != "rw" && e != _t)
          throw new E.InvalidArgument("Invalid transaction mode: " + e);
        o = _t;
      }
      if (s) {
        if (s.mode === wt && o === _t) {
          if (!i)
            throw new E.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
          s = null;
        }
        s && u.forEach((c) => {
          if (s && s.storeNames.indexOf(c) === -1) {
            if (!i)
              throw new E.SubTransaction("Table " + c + " not included in parent transaction.");
            s = null;
          }
        }), i && s && !s.active && (s = null);
      }
    } catch (c) {
      return s ? s._promise(null, (d, l) => {
        l(c);
      }) : D(c);
    }
    const a = Zn.bind(null, this, o, u, s, r);
    return s ? s._promise(o, a, "lock") : P.trans ? Te(P.transless, () => this._whenReady(a)) : this._whenReady(a);
  }
  table(e) {
    if (!z(this._allTables, e))
      throw new E.InvalidTable(`Table ${e} does not exist`);
    return this._allTables[e];
  }
}
const Xr = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable";
class Qr {
  constructor(e) {
    this._subscribe = e;
  }
  subscribe(e, n, r) {
    return this._subscribe(e && typeof e != "function" ? e : { next: e, error: n, complete: r });
  }
  [Xr]() {
    return this;
  }
}
function tr(t, e) {
  return N(e).forEach((n) => {
    mt(t[n] || (t[n] = new Q()), e[n]);
  }), t;
}
function Jr(t) {
  let e, n = !1;
  const r = new Qr((s) => {
    const i = Zt(t);
    let o = !1, u = {}, a = {};
    const c = { get closed() {
      return o;
    }, unsubscribe: () => {
      o = !0, ue.storagemutated.unsubscribe(f);
    } };
    s.start && s.start(c);
    let d = !1, l = !1;
    function h() {
      return N(a).some((p) => u[p] && Yr(u[p], a[p]));
    }
    const f = (p) => {
      tr(u, p), h() && m();
    }, m = () => {
      if (d || o)
        return;
      u = {};
      const p = {}, v = function(y) {
        i && Ee();
        const g = () => oe(t, { subscr: y, trans: null }), b = P.trans ? Te(P.transless, g) : g();
        return i && b.then(ne, ne), b;
      }(p);
      l || (ue(Le, f), l = !0), d = !0, Promise.resolve(v).then((y) => {
        n = !0, e = y, d = !1, o || (h() ? m() : (u = {}, a = p, s.next && s.next(y)));
      }, (y) => {
        d = !1, n = !1, s.error && s.error(y), c.unsubscribe();
      });
    };
    return m(), c;
  });
  return r.hasValue = () => n, r.getValue = () => e, r;
}
let Qt;
try {
  Qt = { indexedDB: K.indexedDB || K.mozIndexedDB || K.webkitIndexedDB || K.msIndexedDB, IDBKeyRange: K.IDBKeyRange || K.webkitIDBKeyRange };
} catch {
  Qt = { indexedDB: null, IDBKeyRange: null };
}
const ce = pe;
function at(t) {
  let e = Z;
  try {
    Z = !0, ue.storagemutated.fire(t);
  } finally {
    Z = e;
  }
}
Ce(ce, { ...tt, delete: (t) => new ce(t, { addons: [] }).delete(), exists: (t) => new ce(t, { addons: [] }).open().then((e) => (e.close(), !0)).catch("NoSuchDatabaseError", () => !1), getDatabaseNames(t) {
  try {
    return function({ indexedDB: e, IDBKeyRange: n }) {
      return un(e) ? Promise.resolve(e.databases()).then((r) => r.map((s) => s.name).filter((s) => s !== yt)) : an(e, n).toCollection().primaryKeys();
    }(ce.dependencies).then(t);
  } catch {
    return D(new E.MissingAPI());
  }
}, defineClass: () => function(t) {
  U(this, t);
}, ignoreTransaction: (t) => P.trans ? Te(P.transless, t) : t(), vip: Yt, async: function(t) {
  return function() {
    try {
      var e = Gt(t.apply(this, arguments));
      return e && typeof e.then == "function" ? e : S.resolve(e);
    } catch (n) {
      return D(n);
    }
  };
}, spawn: function(t, e, n) {
  try {
    var r = Gt(t.apply(n, e || []));
    return r && typeof r.then == "function" ? r : S.resolve(r);
  } catch (s) {
    return D(s);
  }
}, currentTransaction: { get: () => P.trans || null }, waitFor: function(t, e) {
  const n = S.resolve(typeof t == "function" ? ce.ignoreTransaction(t) : t).timeout(e || 6e4);
  return P.trans ? P.trans.waitFor(n) : n;
}, Promise: S, debug: { get: () => G, set: (t) => {
  Kn(t, t === "dexie" ? () => !0 : zn);
} }, derive: ke, extend: U, props: Ce, override: Pn, Events: Ne, on: ue, liveQuery: Jr, extendObservabilitySet: tr, getByKeyPath: te, setByKeyPath: H, delByKeyPath: function(t, e) {
  typeof e == "string" ? H(t, e, void 0) : "length" in e && [].map.call(e, function(n) {
    H(t, n, void 0);
  });
}, shallowClone: An, deepClone: We, getObjectDiff: ln, cmp: L, asap: En, minKey: Mt, addons: [], connections: $e, errnames: tn, dependencies: Qt, semVer: yn, version: yn.split(".").map((t) => parseInt(t)).reduce((t, e, n) => t + e / Math.pow(10, 2 * n)) }), ce.maxKey = Ue(ce.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (ue(Le, (t) => {
  if (!Z) {
    let e;
    gt ? (e = document.createEvent("CustomEvent"), e.initCustomEvent(ie, !0, !0, t)) : e = new CustomEvent(ie, { detail: t }), Z = !0, dispatchEvent(e), Z = !1;
  }
}), addEventListener(ie, ({ detail: t }) => {
  Z || at(t);
}));
let Z = !1;
if (typeof BroadcastChannel < "u") {
  const t = new BroadcastChannel(ie);
  typeof t.unref == "function" && t.unref(), ue(Le, (e) => {
    Z || t.postMessage(e);
  }), t.onmessage = (e) => {
    e.data && at(e.data);
  };
} else if (typeof self < "u" && typeof navigator < "u") {
  ue(Le, (e) => {
    try {
      Z || (typeof localStorage < "u" && localStorage.setItem(ie, JSON.stringify({ trig: Math.random(), changedParts: e })), typeof self.clients == "object" && [...self.clients.matchAll({ includeUncontrolled: !0 })].forEach((n) => n.postMessage({ type: ie, changedParts: e })));
    } catch {
    }
  }), typeof addEventListener < "u" && addEventListener("storage", (e) => {
    if (e.key === ie) {
      const n = JSON.parse(e.newValue);
      n && at(n.changedParts);
    }
  });
  const t = self.document && navigator.serviceWorker;
  t && t.addEventListener("message", function({ data: e }) {
    e && e.type === ie && at(e.changedParts);
  });
}
S.rejectionMapper = function(t, e) {
  if (!t || t instanceof xe || t instanceof TypeError || t instanceof SyntaxError || !t.name || !fn[t.name])
    return t;
  var n = new fn[t.name](e || t.message, t);
  return "stack" in t && ee(n, "stack", { get: function() {
    return this.inner.stack;
  } }), n;
}, Kn(G, zn);
class Zr extends pe {
  constructor() {
    super("NylasAuthDatabase"), Pt(this, "grant"), Pt(this, "pkce"), this.version(1).stores({
      grant: "++id,token",
      pkce: "++id,codeVerifier"
    }), this.grant = this.table("grant"), this.pkce = this.table("pkce");
  }
}
class es {
  constructor() {
    Pt(this, "theDB"), this.theDB = new Zr();
  }
  async setCodeVerifier(e) {
    await this.theDB.pkce.put({ id: 1, codeVerifier: e }, 1);
  }
  async getCodeVerifier() {
    const [e] = await this.theDB.pkce.toArray();
    return e ? e.codeVerifier : null;
  }
  async getTokenInfo() {
    const e = await this.theDB.grant.get(1);
    return e ? e.token : null;
  }
  async setTokenInfo(e) {
    await this.theDB.grant.put({ id: 1, token: e }, 1);
  }
  async reset() {
    await this.theDB.grant.clear();
  }
}
function ss(t) {
  const e = "NylasAuth";
  if (!t)
    throw new Error("NylasAuth requires a config object");
  let n = null;
  if (t.storageType === "indexeddb" && (n = new es()), !n)
    throw new Error("NylasAuth requires a storage object");
  const r = [
    {
      type: "read-only",
      value: "https://www.googleapis.com/auth/gmail.readonly"
    },
    {
      type: "modify",
      value: "https://www.googleapis.com/auth/gmail.modify"
    },
    {
      type: "compose",
      value: "https://www.googleapis.com/auth/gmail.compose"
    },
    {
      type: "insert",
      value: "https://www.googleapis.com/auth/gmail.insert"
    },
    {
      type: "labels",
      value: "https://www.googleapis.com/auth/gmail.labels"
    },
    {
      type: "metadata",
      value: "https://www.googleapis.com/auth/gmail.metadata"
    },
    {
      type: "settings.basic",
      value: "https://www.googleapis.com/auth/gmail.settings.basic"
    },
    {
      type: "settings.sharing",
      value: "https://www.googleapis.com/auth/gmail.settings.sharing"
    }
  ], s = [
    {
      type: "read-only",
      value: "https://outlook.office.com/mail.read"
    },
    {
      type: "modify",
      value: "https://outlook.office.com/mail.readwrite"
    },
    {
      type: "send",
      value: "https://outlook.office.com/mail.send"
    },
    {
      type: "offline",
      value: "offline_access"
    }
  ];
  async function i(o, u, a, c = !0, d, l) {
    const h = await (n == null ? void 0 : n.getTokenInfo()), f = new URL(o, d ?? t.apiUri), m = new Headers();
    m.append("Accept", "application/json"), m.append("Content-Type", "application/json"), m.append("User-Agent", e), h && m.append("Authorization", `Bearer ${h.access_token}`);
    const p = await fetch(f.toString(), {
      method: u || "GET",
      headers: m,
      mode: "cors",
      referrer: location.origin,
      body: a ? JSON.stringify(a) : void 0,
      ...l || {}
    });
    return c ? await p.json() : p.body;
  }
  return {
    config: t,
    /**
     * This method will make a request to the Nylas API to exchange an authorization code for an access token.
     * @param scopes The scopes that were used to generate the authorization code
     * @param email The email that was used to generate the authorization code
     * @param provider The provider that was used to generate the authorization code
     * @returns A promise that resolves to a URL string that can be used to redirect the user to the Nylas API to complete the authorization flow
     */
    async getHostedAuthRedirectURL(o = t.defaultScopes, u, a) {
      const c = await dn(Math.random().toString()), d = await dn(c);
      await (n == null ? void 0 : n.setCodeVerifier(c));
      const l = new URL(`${t.apiUri}/v3/connect/auth`);
      return l.searchParams.set("client_id", t.clientId), l.searchParams.set("response_type", "code"), l.searchParams.set("scope", o.join(" ")), l.searchParams.set("redirect_uri", t.redirectURI), l.searchParams.set("access_type", "offline"), l.searchParams.set("code_challenge", d), l.searchParams.set("code_challenge_method", "S256"), l.searchParams.set("options", "rotate_refresh_token"), a && l.searchParams.set("provider", a), u && l.searchParams.set("login_hint", u), l.toString();
    },
    /**
     * This method will make a request to the Nylas API to exchange an authorization code for an access token.
     * @param path A path to the Nylas API, e.g. `/v3/grants/methreads`
     * @param method GET, POST, PUT, DELETE, etc.
     * @param body A JSON object to send as the body of the request
     * @param domain The domain to use for the request, e.g. `api.us.nylas.com`
     * @param parseJSON Whether to parse the response as JSON or return the raw response (default: true)
     * @returns
     */
    nylasAPIRequest: i,
    /**
     * This method will make a request to the Nylas API to exchange an authorization code for an access token.
     * @param code  The authorization code that was returned from the Nylas API
     * @returns A promise that resolves to a TokenExchangeResponse object
     */
    async exchangeAuthCodeForTokenInfo(o) {
      if (!o)
        return null;
      const u = await (n == null ? void 0 : n.getCodeVerifier()), a = await this.nylasAPIRequest("/v3/connect/token", "POST", {
        code: o,
        client_id: t.clientId,
        grant_type: "authorization_code",
        redirect_uri: t.redirectURI,
        code_verifier: u
      });
      return "error" in a || await (n == null ? void 0 : n.setTokenInfo(a)), a;
    },
    /**
     * This method will make a `application/octet-stream` request to the Nylas API to download a file.
     */
    async nylasDownloadFileRequest(o, u = "GET", a) {
      const c = await (n == null ? void 0 : n.getTokenInfo()), d = new URL(o, t.apiUri), l = new Headers();
      return l.append("Accept", "application/json"), l.append("Content-Type", "application/octet-stream"), l.append("User-Agent", e), c && l.append("Authorization", `Bearer ${c.access_token}`), (await fetch(d.toString(), {
        method: u,
        headers: l,
        mode: "cors",
        referrer: location.origin,
        body: a ? JSON.stringify(a) : void 0
      })).blob();
    },
    /**
     * This methid will clear the access token from the storage object
     */
    async logout() {
      const o = await (n == null ? void 0 : n.getTokenInfo());
      o && await this.nylasAPIRequest(`/v3/connect/revoke?token=${o.access_token}`, "POST"), await (n == null ? void 0 : n.reset());
    },
    /**
     * This method will make a request to the Nylas API to exchange an authorization code for an access token.
     * @returns A promise that resolves to a boolean indicating whether the user is authenticated
     */
    async isAuthenticated() {
      return !!await (n == null ? void 0 : n.getTokenInfo());
    },
    /**
     * This method will return information about the current access token.
     * @returns A promise with the token info
     */
    async getTokenInfo() {
      const o = await (n == null ? void 0 : n.getTokenInfo());
      if (!o)
        return null;
      const { access_token: u, ...a } = o;
      return a;
    },
    /**
     * This method will make a request to the Nylas API to validate if the current access token is valid.
     * @returns A promise that resolves to a boolean indicating whether the current access token is valid
     */
    async isAccessTokenValid() {
      const o = await (n == null ? void 0 : n.getTokenInfo());
      return o ? "data" in await this.nylasAPIRequest(`/v3/connect/tokeninfo?id_token=${o.id_token}`, "GET") : !1;
    },
    /**
     * This method will make a request to the Nylas API to refresh the current access token.
     * @returns A promise that resolves to a TokenExchangeResponse object
     */
    async refreshAccessToken() {
      const o = await (n == null ? void 0 : n.getTokenInfo());
      if (!o)
        return null;
      const u = await this.nylasAPIRequest("/v3/connect/token", "POST", {
        client_id: t.clientId,
        grant_type: "refresh_token",
        refresh_token: o.refresh_token
      });
      return "error" in u || await (n == null ? void 0 : n.setTokenInfo(u)), u;
    },
    /**
     * This method will return true if the current access token has the given scope
     * based on the type of scope (e.g. 'read-only', 'modify', 'compose', 'insert', 'labels', 'metadata', 'settings.basic', or 'settings.sharing')
     * @param type Either 'read-only', 'modify', 'compose', 'insert', 'labels', 'metadata', 'settings.basic', or 'settings.sharing'
     */
    async hasScopeByType(o = "email", u) {
      const a = await (n == null ? void 0 : n.getTokenInfo());
      if (!a)
        return !1;
      const c = a.scope.toLowerCase().split(" ");
      let d = [];
      const l = Array.isArray(u) ? u : [u];
      return o === "email" && (d = [...s, ...r].filter((h) => l.includes(h.type))), d.every((h) => c.includes(h.value));
    },
    /**
     * A helper method to check if the current access token has a given scope.
     * @param scope The scope(s) to check for in the current access token  (e.g. https://www.googleapis.com/auth/gmail.modify)
     * @returns boolean indicating whether the current access token has the given scope
     */
    async hasScope(o) {
      const u = await (n == null ? void 0 : n.getTokenInfo());
      if (!u)
        return !1;
      const a = u.scope.toLowerCase().split(" ");
      return (Array.isArray(o) ? o : [o]).some((c) => a.includes(c.toLowerCase()));
    }
  };
}
export {
  ns as N,
  rs as X,
  ss as e,
  ar as n
};
