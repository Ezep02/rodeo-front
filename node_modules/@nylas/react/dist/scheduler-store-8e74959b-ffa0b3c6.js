import { d as L, a as F, i as d, j as R } from "./index-cd93b584.js";
var B;
(function(o) {
  o.Component = "component", o.Api = "api", o.Auth = "auth";
})(B || (B = {}));
var M;
(function(o) {
  o.endtime_not_in_future = "endtime_not_in_future", o.no_booking_info = "no_booking_info", o.no_timeslot_selected = "no_timeslot_selected", o.no_timezone_selected = "no_timezone_selected", o.no_booking_id = "no_booking_id", o.no_salt = "no_salt", o.invalid_start_time = "invalid_start_time", o.invalid_end_time = "invalid_end_time", o.invalid_timezone = "invalid_timezone";
})(M || (M = {}));
var $;
(function(o) {
  o.invalid_session = "invalid_session", o.general_error = "general_error", o.internal_error = "internal_error", o.invalid_request_error = "invalid_request_error", o.timeslot_not_available = "timeslot_not_available", o.provider_error = "provider_error", o.not_found_error = "not_found_error";
})($ || ($ = {}));
class C {
  constructor() {
    this.component = (e) => {
      const t = B.Component, s = `${e} Error`;
      return {
        endtime_not_in_future: (i = '"endtime" can not be in the future') => ({
          title: s,
          message: i,
          category: t
        }),
        no_booking_info: (i = "No booking info provided") => ({
          title: s,
          message: i,
          category: t
        }),
        no_timeslot_selected: (i = "No timeslot selected") => ({
          title: s,
          message: i,
          category: t
        }),
        no_timezone_selected: (i = "No timezone selected") => ({
          title: s,
          message: i,
          category: t
        }),
        no_booking_id: (i = "No booking id provided") => ({
          title: s,
          message: i,
          category: t
        }),
        no_salt: (i = "No salt provided") => ({
          title: s,
          message: i,
          category: t
        }),
        invalid_start_time: (i = "Invalid start time") => ({
          title: s,
          message: i,
          category: t
        }),
        invalid_end_time: (i = "Invalid end time") => ({
          title: s,
          message: i,
          category: t
        }),
        invalid_timezone: (i = "Invalid timezone") => ({
          title: s,
          message: i,
          category: t
        })
      };
    }, this.api = (e) => {
      const t = B.Api, s = `${e} Error`;
      return {
        invalid_session: (i) => ({
          title: s,
          message: i,
          category: t
        }),
        general_error: (i) => ({
          title: s,
          message: i,
          category: t
        }),
        internal_error: (i) => ({
          title: s,
          message: i,
          category: t
        }),
        invalid_request_error: (i) => ({
          title: s,
          message: i,
          category: t
        }),
        timeslot_not_available: (i) => ({
          title: s,
          message: i,
          category: t
        }),
        provider_error: (i) => ({
          title: s,
          message: i,
          category: t
        }),
        not_found_error: (i) => ({
          title: s,
          message: i,
          category: t
        })
      };
    };
  }
}
class N {
  constructor({ schedulerAPIURL: e, schedulerStore: t, sessionId: s, configId: i, slug: r, clientId: n }) {
    this.errors = new C(), this.schedulerStore = t, this.schedulerAPIURL = e, this.sessionId = s, this.configId = i, this.slug = r, this.clientId = n;
  }
  getHeaders() {
    return this.sessionId ? {
      Authorization: `Bearer ${this.sessionId}`
    } : {};
  }
  async makeAPIRequest(e, t, s, i = {}) {
    try {
      const r = new URL(this.schedulerAPIURL), n = "1.3.4";
      return r.pathname = e, await (await fetch(decodeURIComponent(r.toString()), {
        method: t,
        headers: {
          "Content-Type": "application/json",
          Origin: window.location.origin,
          "X-Source": "nylas-scheduling",
          "X-Nylas-Web-Elements-Version": n,
          ...i
        },
        body: s
      })).json();
    } catch (r) {
      return {
        error: {
          message: r.message,
          title: "API request failed",
          type: "api"
        }
      };
    }
  }
  getErrorMessage(e) {
    var s, i, r, n;
    let t = (e == null ? void 0 : e.message) || (e == null ? void 0 : e.title) || "Something went wrong";
    return (e == null ? void 0 : e.type) === "provider_error" && (t = ((i = (s = e == null ? void 0 : e.provider_error) == null ? void 0 : s.error) == null ? void 0 : i.message) || ((n = (r = e == null ? void 0 : e.provider_error) == null ? void 0 : r.error) == null ? void 0 : n.title) || "Something went wrong"), t;
  }
  setConfigId(e) {
    this.configId = e;
  }
  selectDate(e) {
    this.schedulerStore.set("selectedDate", e), this.schedulerStore.set("selectedTimeslot", null);
  }
  selectTime(e) {
    this.schedulerStore.set("selectedTimeslot", e);
  }
  selectTimezone(e) {
    this.schedulerStore.set("selectedTimezone", e);
  }
  selectLanguage(e) {
    this.schedulerStore.set("selectedLanguage", e), d.changeLanguage(e);
  }
  async toggleAdditionalData(e) {
    e || await this.refetchAvailability(), this.schedulerStore.set("showBookingForm", e);
  }
  setParticipantName(e) {
    const { bookingInfo: t } = this.schedulerStore.state;
    this.schedulerStore.set("bookingInfo", {
      ...t,
      primaryParticipant: {
        ...t == null ? void 0 : t.primaryParticipant,
        name: e
      }
    });
  }
  setParticipantEmail(e) {
    const { bookingInfo: t } = this.schedulerStore.state;
    this.schedulerStore.set("bookingInfo", {
      ...t,
      primaryParticipant: {
        ...t == null ? void 0 : t.primaryParticipant,
        email: e
      }
    });
  }
  async refetchAvailability() {
    const e = /* @__PURE__ */ new Date(), t = new Date(e.getFullYear(), e.getMonth(), 1).getTime() / 1e3, s = t < e.getTime() / 1e3 ? Math.floor(e.getTime() / 1e3) : t, i = new Date(e.getFullYear(), e.getMonth() + 1, 1).getTime() / 1e3;
    return await this.getAvailability(s, i);
  }
  async resetStoreStateAndFetchAvailability() {
    const e = /* @__PURE__ */ new Date(), t = await this.refetchAvailability(), s = this.schedulerStore.get("availability").find((r) => new Date(r.start_time) > /* @__PURE__ */ new Date());
    let i = e;
    return s && (i = s.start_time), this.schedulerStore.set("selectedDate", i), this.schedulerStore.set("eventInfo", null), this.schedulerStore.set("showBookingForm", !1), this.schedulerStore.set("selectedTimeslot", null), t;
  }
  async setReschedule(e) {
    this.schedulerStore.set("isLoading", !0);
    const t = this.schedulerStore.state.eventInfo;
    return t && this.schedulerStore.set("reschedulingEventInfo", t), this.schedulerStore.set("rescheduleBookingId", e), await this.getUISettings(), await this.resetStoreStateAndFetchAvailability().finally(() => {
      this.schedulerStore.set("isLoading", !1);
    });
  }
  async setCancel(e) {
    this.schedulerStore.set("cancelBookingId", e);
  }
  async setReject(e) {
    this.schedulerStore.set("rejectBookingId", e);
  }
  async resetCancel() {
    const e = await this.resetStoreStateAndFetchAvailability();
    return this.schedulerStore.set("cancelBookingId", ""), this.schedulerStore.set("rejectBookingId", ""), this.schedulerStore.set("cancelledEventInfo", null), e;
  }
  async goBack() {
    this.schedulerStore.set("cancelBookingId", "");
  }
  async resetConfirm() {
    const e = await this.resetStoreStateAndFetchAvailability();
    return this.schedulerStore.set("organizerConfirmationBookingId", ""), this.schedulerStore.set("confirmedEventInfo", void 0), e;
  }
  async bookTimeslot(e) {
    var I;
    this.schedulerStore.set("isLoading", !0);
    const { selectedTimeslot: t, selectedTimezone: s, bookingInfo: i, selectedLanguage: r } = this.schedulerStore.state;
    if (!e && !i)
      return { error: this.errors.component(d.t("createBookingErrorTitle")).no_booking_info() };
    const n = (e == null ? void 0 : e.timeslot) || t;
    if (!n)
      return { error: this.errors.component(d.t("createBookingErrorTitle")).no_timeslot_selected() };
    const a = e && (e != null && e.timezone) ? e == null ? void 0 : e.timezone : s, l = r || "en-US";
    if (!a)
      return { error: this.errors.component(d.t("createBookingErrorTitle")).no_timezone_selected() };
    const u = this.schedulerStore.get("availabilityOrderEmails");
    let c = "";
    if (u.length > 0) {
      const k = (n == null ? void 0 : n.emails) || [];
      for (let f = 0; f < u.length; f++)
        if (k.includes(u[f])) {
          c = u[f];
          break;
        }
    }
    const h = {};
    Object.entries((i == null ? void 0 : i.additionalFields) || {}).forEach(([k, f]) => {
      h[k] = f.value;
    });
    const _ = e ? e == null ? void 0 : e.primaryParticipant : i == null ? void 0 : i.primaryParticipant, S = e ? (e == null ? void 0 : e.guests) || [] : (i == null ? void 0 : i.guests) || [], p = e ? e == null ? void 0 : e.additionalFields : h, T = this.getHeaders(), v = `/v3/scheduling/bookings${!this.sessionId && this.configId ? `?configuration_id=${this.configId}` : !this.sessionId && this.slug && this.clientId ? `?slug=${this.slug}&client_id=${this.clientId}` : ""}`, g = await this.makeAPIRequest(decodeURIComponent(v), "POST", JSON.stringify({
      participants: c ? [{ email: c }] : void 0,
      additional_fields: p,
      additional_guests: S,
      guest: { ..._ },
      start_time: n.start_time.getTime() / 1e3,
      end_time: n.end_time.getTime() / 1e3,
      timezone: a,
      email_language: this.getTwoLetterLanguageCode(l)
    }), T);
    if ("error" in g) {
      this.schedulerStore.set("isLoading", !1);
      const k = (I = g.error) == null ? void 0 : I.type;
      let f = g.error;
      if (k && k in this.errors.api("Create Booking")) {
        const E = this.getErrorMessage(f);
        f = this.errors.api("Create Booking")[k](E);
      }
      return { error: f };
    }
    return "data" in g && this.schedulerStore.set("eventInfo", g == null ? void 0 : g.data), this.schedulerStore.set("isLoading", !1), g;
  }
  async getUISettings() {
    var n;
    this.schedulerStore.set("isLoading", !0);
    const e = this.schedulerStore.get("rescheduleBookingId"), t = this.getHeaders();
    let s = !this.sessionId && this.configId ? `?configuration_id=${this.configId}` : !this.sessionId && this.slug && this.clientId ? `?slug=${this.slug}&client_id=${this.clientId}` : "";
    e && s ? s += `&booking_id=${e}` : e && (s += `?booking_id=${e}`);
    const i = `/v3/scheduling/ui-settings${s}`, r = await this.makeAPIRequest(i, "GET", void 0, t);
    if ("error" in r) {
      this.schedulerStore.set("isLoading", !1);
      const a = (n = r.error) == null ? void 0 : n.type;
      let l = r.error;
      return a && a in this.errors.api(d.t("getUISettingErrorTitle")) && (l = this.errors.api(d.t("getUISettingErrorTitle"))[a]((l == null ? void 0 : l.message) || (l == null ? void 0 : l.title) || "Something went wrong")), { error: l };
    }
    return "data" in r && this.schedulerStore.set("configSettings", r.data), this.schedulerStore.set("isLoading", !1), r;
  }
  getTwoLetterLanguageCode(e) {
    return e.split("-")[0];
  }
  getStartTimeWithMinBookingNotice(e) {
    var r;
    const t = (r = this.schedulerStore.get("configSettings")) == null ? void 0 : r.scheduler, s = t == null ? void 0 : t.min_booking_notice;
    if (!s)
      return e;
    const i = (/* @__PURE__ */ new Date()).getTime();
    return e < (i + s * 60 * 1e3) / 1e3 ? Math.floor((i + s * 60 * 1e3) / 1e3) : e;
  }
  getEndTimeForAvailableDaysInFuture(e) {
    var n, a;
    const t = /* @__PURE__ */ new Date(), s = (a = (n = this.schedulerStore.get("configSettings")) == null ? void 0 : n.scheduler) == null ? void 0 : a.available_days_in_future, i = Math.floor(R(t, s).getTime() / 1e3);
    return Math.min(i, e);
  }
  async getAvailability(e = 0, t = 0) {
    var _, S, p, T;
    this.schedulerStore.set("isLoading", !0);
    const s = new URLSearchParams(), i = /* @__PURE__ */ new Date(), r = i.getTime();
    if (t && t < r / 1e3)
      return this.schedulerStore.set("isLoading", !1), { error: this.errors.component(d.t("getAvailabilityErrorTitle")).endtime_not_in_future() };
    if (!e) {
      const m = new Date(i.getFullYear(), i.getMonth(), 1);
      e = Math.floor(m.getTime() / 1e3);
    }
    if (!t) {
      const m = new Date(i.getFullYear(), i.getMonth() + 1, 0);
      t = Math.floor(m.getTime() / 1e3);
    }
    t = this.getEndTimeForAvailableDaysInFuture(t);
    const n = this.getStartTimeWithMinBookingNotice(e);
    e = n, t = n > t ? n + 1 : t, s.append("start_time", encodeURIComponent(e.toString())), s.append("end_time", encodeURIComponent(t.toString())), this.configId && !this.sessionId ? s.append("configuration_id", encodeURIComponent(this.configId)) : this.slug && this.clientId && !this.sessionId && (s.append("slug", encodeURIComponent(this.slug)), s.append("client_id", encodeURIComponent(this.clientId)));
    const a = this.schedulerStore.get("rescheduleBookingId");
    a && s.append("booking_id", encodeURIComponent(a));
    const l = s.toString(), u = `/v3/scheduling/availability${l ? `?${l}` : ""}`, c = this.getHeaders(), h = await this.makeAPIRequest(decodeURIComponent(u), "GET", void 0, c);
    if ("error" in h) {
      this.schedulerStore.set("availability", []), this.schedulerStore.set("isLoading", !1);
      const m = (_ = h.error) == null ? void 0 : _.type;
      let v = h.error;
      if (m && m in this.errors.api(d.t("getAvailabilityErrorTitle"))) {
        const g = this.getErrorMessage(v);
        v = this.errors.api(d.t("getAvailabilityErrorTitle"))[m](g);
      }
      return { error: v };
    }
    if ("data" in h) {
      const v = (((p = (S = h.data) == null ? void 0 : S.time_slots) == null ? void 0 : p.map((I) => ({
        ...I,
        start_time: new Date(I.start_time * 1e3),
        end_time: new Date(I.end_time * 1e3)
      }))) || []).filter((I) => I.start_time.getTime() > r);
      this.schedulerStore.set("availability", v);
      const g = ((T = h.data) == null ? void 0 : T.order) || [];
      this.schedulerStore.set("availabilityOrderEmails", g);
    }
    return this.schedulerStore.set("isLoading", !1), h;
  }
  async cancelBooking(e, t) {
    var a;
    if (this.schedulerStore.set("isLoading", !0), !e)
      return { error: this.errors.component(d.t("cancelBookingErrorTitle")).no_booking_id() };
    const s = !this.sessionId && this.configId ? `?configuration_id=${this.configId}` : !this.sessionId && this.slug && this.clientId ? `?slug=${this.slug}&client_id=${this.clientId}` : "", i = `/v3/scheduling/bookings/${e}${s}`, r = this.getHeaders(), n = await this.makeAPIRequest(decodeURIComponent(i), "DELETE", JSON.stringify({
      action: "cancel",
      cancellation_reason: t
    }), r);
    if ("error" in n) {
      this.schedulerStore.set("isLoading", !1);
      const l = (a = n.error) == null ? void 0 : a.type;
      let u = n.error;
      if (l && l in this.errors.api(d.t("cancelBookingErrorTitle"))) {
        const c = this.getErrorMessage(u);
        u = this.errors.api(d.t("cancelBookingErrorTitle"))[l](c);
      }
      return { error: u };
    }
    return this.schedulerStore.set("cancelledEventInfo", {
      booking_id: e
    }), this.schedulerStore.set("rescheduleBookingId", ""), this.schedulerStore.set("isLoading", !1), n;
  }
  async rescheduleBooking(e, t) {
    var A;
    if (this.schedulerStore.set("isLoading", !0), !e)
      return { error: this.errors.component(d.t("rescheduleBookingErrorTitle")).no_booking_id() };
    const s = this.errors.api(d.t("rescheduleBookingErrorTitle")), i = this.errors.component(d.t("rescheduleBookingErrorTitle")), { bookingInfo: r, selectedTimeslot: n, selectedTimezone: a, selectedLanguage: l } = this.schedulerStore.state, { startTime: u, endTime: c, timezone: h } = t, _ = u || (n == null ? void 0 : n.start_time);
    if (!_)
      return { error: i.invalid_start_time('Please pass "startTime" in data or set "selectedTimeslot" in the defaultSchedulerState.') };
    const S = c || (n == null ? void 0 : n.end_time);
    if (!S)
      return { error: i.invalid_end_time('Please pass "endTime" in data or set "selectedTimeslot" in the defaultSchedulerState.') };
    const p = this.schedulerStore.get("availabilityOrderEmails");
    let T = "";
    if (p.length > 0) {
      const b = (n == null ? void 0 : n.emails) || [];
      for (let y = 0; y < p.length; y++)
        if (b.includes(p[y])) {
          T = p[y];
          break;
        }
    }
    const m = h || a;
    if (!m)
      return { error: i.invalid_timezone('Please pass "timezone" in data or set "selectedTimezone" in the defaultSchedulerState.') };
    const v = {};
    Object.entries((r == null ? void 0 : r.additionalFields) || {}).forEach(([b, y]) => {
      v[b] = y.value;
    });
    const g = t ? t == null ? void 0 : t.primaryParticipant : r == null ? void 0 : r.primaryParticipant, I = t ? (t == null ? void 0 : t.guests) || [] : (r == null ? void 0 : r.guests) || [], k = t ? t == null ? void 0 : t.additionalFields : v, f = !this.sessionId && this.configId ? `?configuration_id=${this.configId}` : !this.sessionId && this.slug && this.clientId ? `?slug=${this.slug}&client_id=${this.clientId}` : "", E = `/v3/scheduling/bookings/${e}${f}`, P = this.getHeaders(), w = await this.makeAPIRequest(decodeURIComponent(E), "PATCH", JSON.stringify({
      start_time: _.getTime() / 1e3,
      end_time: S.getTime() / 1e3,
      timezone: m,
      additional_fields: k,
      guest: { ...g },
      additional_guests: I,
      participants: T ? [{ email: T }] : void 0,
      email_language: this.getTwoLetterLanguageCode(l)
    }), P);
    if ("error" in w) {
      this.schedulerStore.set("isLoading", !1);
      const b = (A = w.error) == null ? void 0 : A.type;
      let y = w.error;
      if (b && b in s) {
        const z = this.getErrorMessage(y);
        y = s[b](z);
      }
      return { error: y };
    }
    const D = this.schedulerStore.get("reschedulingEventInfo");
    if ("data" in w)
      this.schedulerStore.set("eventInfo", w == null ? void 0 : w.data);
    else if (D)
      this.schedulerStore.set("eventInfo", D);
    else {
      const b = {
        booking_id: e
      };
      this.schedulerStore.set("eventInfo", b);
    }
    return this.schedulerStore.set("isLoading", !1), w;
  }
  async updateBooking(e) {
    var h;
    this.schedulerStore.set("isLoading", !0);
    const { bookingId: t, status: s, reason: i } = e, r = this.schedulerStore.get("organizerConfirmationSalt"), n = s === "confirmed" ? d.t("confirmBookingErrorTitle") : d.t("rejectBookingErrorTitle");
    if (!t)
      return { error: this.errors.component(n).no_booking_id() };
    if (!r)
      return { error: this.errors.component(n).no_salt() };
    const a = !this.sessionId && this.configId ? `?configuration_id=${this.configId}` : !this.sessionId && this.slug && this.clientId ? `?slug=${this.slug}&client_id=${this.clientId}` : "", l = `/v3/scheduling/bookings/${t}${a}`, u = this.getHeaders(), c = await this.makeAPIRequest(decodeURIComponent(l), "PUT", JSON.stringify({
      status: s,
      cancellation_reason: i,
      salt: r
    }), u);
    if ("error" in c) {
      this.schedulerStore.set("isLoading", !1);
      const _ = (h = c.error) == null ? void 0 : h.type;
      let S = c.error;
      if (_ && _ in this.errors.api(n)) {
        const p = this.getErrorMessage(S);
        S = this.errors.api(n)[_](p);
      }
      return { error: S };
    }
    return "data" in c && s === "confirmed" ? this.schedulerStore.set("confirmedEventInfo", c == null ? void 0 : c.data) : "request_id" in c && s === "cancelled" && this.schedulerStore.set("cancelledEventInfo", {
      booking_id: t
    }), this.schedulerStore.set("organizerConfirmationBookingId", ""), this.schedulerStore.set("isLoading", !1), c;
  }
}
function O(o = {}) {
  const e = {
    selectedDate: null,
    selectedLanguage: navigator.language,
    selectedTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    selectedTimeslot: null,
    showBookingForm: !1,
    availabilityOrderEmails: [],
    selectableDates: null,
    availability: [],
    eventDuration: 0,
    state: "ready",
    eventInfo: null,
    cancelledEventInfo: null,
    isLoading: !1,
    nylasBranding: !0,
    ...o
  };
  L("[defaultNylasStoreState]: ", e);
  const t = F(e);
  return t.onChange("availability", (s) => {
    L("[availability]: ", s);
    const i = s.map((a) => a.start_time);
    L("[selectableDates]: ", i), t.set("selectableDates", i);
    const r = s[0];
    if (!r)
      return;
    const n = Math.floor((r.end_time.getTime() - r.start_time.getTime()) / 6e4);
    L("[durationMinutes]: ", n), t.set("eventDuration", n);
  }), t.reset = () => {
    for (const s in e) {
      const i = e[s];
      t.set(s, i);
    }
  }, t;
}
export {
  O as C,
  B as E,
  N
};
