var O = Object.defineProperty;
var P = (r, t, n) => t in r ? O(r, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : r[t] = n;
var b = (r, t, n) => (P(r, typeof t != "symbol" ? t + "" : t, n), n);
import { p as process, b as commonjsGlobal, r as registerInstance, c as createEvent, d as debug, N as NylasIdentityRequestWrapper, i as instance, h, H as Host, g as getElement, B as Buffer, F as Fragment, e as dataResponse } from "./index-cd93b584.js";
import { N as NylasBaseProvider, X as Xr } from "./index.es-ef72cd61-3075f564.js";
import { C as CreateNylasSchedulerConfigStore } from "./scheduler-config-store-ed4a8dfd-622802c7.js";
import { L as LANGUAGE_CODE, a as LANGUAGE_MAP } from "./constants-91d76d21-1638ead6.js";
import "react";
import "react-dom";
class NylasSchedulerConfigAPIConnector {
  constructor({ nylasApiRequest: t, nylasSchedulerConfigStore: n }) {
    this.nylasApiRequest = t, this.nylasSchedulerConfigStore = n;
  }
  async currentUser() {
    return this.nylasApiRequest ? this.nylasApiRequest.currentUser() : (console.warn("Nylas API Request is not initialized"), null);
  }
  async getCalendars() {
    var s;
    if (!this.nylasApiRequest)
      return console.warn("Nylas API Request is not initialized"), dataResponse(null, {
        message: "Error fetching calendars: Nylas API Request is not initialized"
      });
    const [t, n] = await this.nylasApiRequest.request({
      method: "GET",
      path: "calendars"
    });
    return n ? dataResponse(null, {
      message: "Error fetching calendars: " + n.message
    }) : Xr(t) ? dataResponse(null, {
      message: "Error fetching calendars: " + ((s = t.error) == null ? void 0 : s.message)
    }) : (this.nylasSchedulerConfigStore.state.calendars = t.data, dataResponse(t.data));
  }
  async getConfigurationById(t, n = !1) {
    var a;
    if (!this.nylasApiRequest)
      return console.warn("Nylas API Request is not initialized"), dataResponse(null, {
        message: "Error fetching configuration: Nylas API Request is not initialized"
      });
    if (!n) {
      const d = this.nylasSchedulerConfigStore.state.configurations.find((l) => l.id === t);
      if (d)
        return this.nylasSchedulerConfigStore.state.selectedConfiguration = d, dataResponse(d);
    }
    const [s, c] = await this.nylasApiRequest.request({
      method: "GET",
      path: `scheduling/configurations/${t}`
    });
    return c ? dataResponse(null, {
      message: "Error fetching configuration: " + c.message
    }) : Xr(s) ? dataResponse(null, {
      message: "Error fetching configuration: " + ((a = s.error) == null ? void 0 : a.message)
    }) : (this.nylasSchedulerConfigStore.state.selectedConfiguration = s.data, this.nylasSchedulerConfigStore.state.configurations.find((d) => d.id === t) ? this.nylasSchedulerConfigStore.state.configurations = this.nylasSchedulerConfigStore.state.configurations.map((d) => d.id === t ? s.data : d) : this.nylasSchedulerConfigStore.state.configurations = [...this.nylasSchedulerConfigStore.state.configurations, s.data], dataResponse(s.data));
  }
  async getConfigurations(t) {
    var a;
    if (!this.nylasApiRequest)
      return console.warn("Nylas API Request is not initialized"), dataResponse(null, {
        message: "Error fetching configurations: Nylas API Request is not initialized"
      });
    const n = 50, [s, c] = await this.nylasApiRequest.request({
      method: "GET",
      path: `scheduling/configurations?limit=${n}${t ? `&page_token=${t}` : ""}`
    });
    return c ? dataResponse(null, {
      message: "Error fetching configurations: " + c.message
    }) : Xr(s) ? dataResponse(null, {
      message: "Error fetching configurations: " + ((a = s.error) == null ? void 0 : a.message)
    }) : (this.nylasSchedulerConfigStore.state.configurations = s.data, this.nylasSchedulerConfigStore.state.listConfigurationsNextCursor = s.next_cursor || null, dataResponse(s.data));
  }
  async createConfiguration(t) {
    var c;
    if (!this.nylasApiRequest)
      return console.warn("Nylas API Request is not initialized"), dataResponse(null, {
        message: "Error creating configuration: Nylas API Request is not initialized"
      });
    const [n, s] = await this.nylasApiRequest.request({
      method: "POST",
      path: "scheduling/configurations",
      body: t
    });
    return s ? dataResponse(null, {
      message: "Error creating configuration: " + s.message
    }) : Xr(n) ? dataResponse(null, {
      message: "Error creating configuration: " + ((c = n.error) == null ? void 0 : c.message)
    }) : (this.nylasSchedulerConfigStore.state.selectedConfiguration = n.data, this.nylasSchedulerConfigStore.state.configurations = [...this.nylasSchedulerConfigStore.state.configurations, n.data], dataResponse(n.data));
  }
  async updateConfiguration(t) {
    var c;
    if (!this.nylasApiRequest)
      return console.warn("Nylas API Request is not initialized"), dataResponse(null, {
        message: "Error updating configuration: Nylas API Request is not initialized"
      });
    const [n, s] = await this.nylasApiRequest.request({
      method: "PUT",
      path: `scheduling/configurations/${t.id}`,
      body: t
    });
    return s ? dataResponse(null, {
      message: "Error updating configuration: " + s.message
    }) : Xr(n) ? dataResponse(null, {
      message: "Error updating configuration: " + ((c = n.error) == null ? void 0 : c.message)
    }) : (this.nylasSchedulerConfigStore.state.selectedConfiguration = n.data, this.nylasSchedulerConfigStore.state.configurations.find((a) => a.id === t.id) ? this.nylasSchedulerConfigStore.state.configurations = this.nylasSchedulerConfigStore.state.configurations.map((a) => a.id === t.id ? n.data : a) : this.nylasSchedulerConfigStore.state.configurations = [...this.nylasSchedulerConfigStore.state.configurations, n.data], dataResponse(n.data));
  }
  async deleteConfiguration(t) {
    var c, a;
    if (!this.nylasApiRequest)
      return console.warn("Nylas API Request is not initialized"), dataResponse(null, {
        message: "Error deleting configuration: Nylas API Request is not initialized"
      });
    const [n, s] = await this.nylasApiRequest.request({
      method: "DELETE",
      path: `scheduling/configurations/${t}`
    });
    return s ? dataResponse(null, {
      message: "Error deleting configuration: " + s.message
    }) : Xr(n) ? dataResponse(null, {
      message: "Error deleting configuration: " + ((c = n.error) == null ? void 0 : c.message)
    }) : (this.nylasSchedulerConfigStore.state.configurations = this.nylasSchedulerConfigStore.state.configurations.filter((d) => d.id !== t), ((a = this.nylasSchedulerConfigStore.state.selectedConfiguration) == null ? void 0 : a.id) === t && this.nylasSchedulerConfigStore.resetSelectedConfiguration(), dataResponse(n.data));
  }
}
class NylasSchedulerConfigConnector {
  constructor({ nylasApiRequest: t, nylasSchedulerConfigStore: n }) {
    this.nylasApiRequest = t, this.nylasSchedulerConfigStore = n;
  }
  init() {
    debug("NylasSchedulerConfigConnector init");
  }
  get schedulerConfigStore() {
    return this.nylasSchedulerConfigStore;
  }
  get schedulerConfig() {
    return this._schedulerConfigConnector ? this._schedulerConfigConnector : (this._schedulerConfigConnector = new NylasSchedulerConfigAPIConnector({
      nylasApiRequest: this.nylasApiRequest,
      nylasSchedulerConfigStore: this.nylasSchedulerConfigStore
    }), this._schedulerConfigConnector);
  }
  resetStores() {
    debug("NylasSchedulerConfigConnector resetStores"), this.nylasSchedulerConfigStore.reset();
  }
  async logout() {
    debug("NylasSchedulerConfigConnector logout"), this.resetStores();
  }
}
class LocalStorage {
  get(t) {
    return new Promise((n) => {
      const s = window.localStorage.getItem(t);
      n(s ? JSON.parse(s) : null);
    });
  }
  async remove(t) {
    return window.localStorage.removeItem(t), new Promise((n) => {
      n(null);
    });
  }
  set(t, n) {
    return window.localStorage.setItem(t, JSON.stringify(n)), new Promise((s) => {
      s(null);
    });
  }
}
const PKCE_KEY = "pkce", GRANT_KEY = "grant", USER_KEY = "user";
class Storage {
  constructor(t) {
    b(this, "Storage", new LocalStorage());
    if (t) {
      this.Storage = t;
      return;
    }
  }
  setPKCE(t) {
    const n = Buffer.from(t);
    this.Storage.set(PKCE_KEY, n.toString("base64"));
  }
  async getPKCE() {
    try {
      const t = await this.Storage.get(PKCE_KEY);
      if (t)
        return Buffer.from(t, "base64").toString("utf8");
    } catch {
      return null;
    }
    return null;
  }
  removePKCE() {
    this.Storage.remove(PKCE_KEY);
  }
  setGrant(t, n = !1) {
    const { grant_id: s } = t;
    this.Storage.set(`${GRANT_KEY}${n ? "-" + s : ""}`, t);
  }
  removeGrant(t, n = !1) {
    this.Storage.remove(`${GRANT_KEY}${n ? "-" + t : ""}`);
  }
  async getGrant(t, n = !1) {
    const s = await this.Storage.get(`${GRANT_KEY}${n ? "-" + t : ""}`);
    return s || null;
  }
  // setUserToken is used to store the IDToken in storage
  async setUserToken(t) {
    const n = await this.getUserTokens();
    if (n)
      if (n.find((c) => c.sub === t.sub)) {
        const c = n.map((a) => (a.sub === t.sub && (a = t), a));
        this.Storage.set(USER_KEY, c);
      } else {
        const c = [...n, t];
        this.Storage.set(USER_KEY, c);
      }
    else
      this.Storage.set(USER_KEY, [t]);
  }
  // getUserToken is used to retrieve a specific IDToken from storage
  async getUserToken(t = "") {
    const n = await this.Storage.get(USER_KEY);
    return n ? t === "" ? n[0] : n.find((c) => c.sub === t) : null;
  }
  // getUserTokens is used to retrieve all IDTokens from storage
  async getUserTokens() {
    const t = await this.Storage.get(USER_KEY);
    return t || null;
  }
  // removeUserTokens is used to remove all IDTokens from storage
  removeUserTokens() {
    this.Storage.remove(USER_KEY);
  }
  // removeUserToken is used to remove a specific IDToken from storage
  async removeUserToken(t) {
    const n = await this.getUserTokens(), s = n == null ? void 0 : n.filter((c) => c.sub !== t);
    this.Storage.set(USER_KEY, s);
  }
  async clearSession() {
    const t = await this.getUserTokens();
    t == null || t.forEach((n) => {
      this.removeGrant(n.sub);
    }), this.removePKCE(), this.removeUserTokens();
  }
}
class IndexedDBStorage {
  constructor() {
    b(this, "databaseName", "identity-db");
    b(this, "storeName", "identity");
  }
  get(t) {
    const n = this;
    return new Promise((s, c) => {
      n.openDatabase().then(function(a) {
        const d = a.transaction(n.storeName, "readwrite"), u = d.objectStore(n.storeName).get(t);
        u.onsuccess = () => {
          s(u.result);
        }, u.onerror = () => {
          c(u.error);
        }, d.oncomplete = () => {
          a.close();
        };
      });
    });
  }
  async remove(t) {
    const n = this;
    return new Promise((s, c) => {
      const a = indexedDB.open(this.databaseName);
      a.onupgradeneeded = function(d) {
        d.target.result.createObjectStore(n.storeName);
      }, a.onerror = () => {
        c(a.error);
      }, a.onsuccess = (d) => {
        const l = d.target.result, u = l.transaction(this.storeName, "readwrite"), y = u.objectStore(this.storeName).delete(t);
        y.onsuccess = () => {
          s(null);
        }, y.onerror = () => {
          c(y.error);
        }, u.oncomplete = () => {
          l.close();
        };
      };
    });
  }
  set(t, n) {
    return new Promise((s, c) => {
      const a = indexedDB.open(this.databaseName);
      a.onerror = () => {
        c(a.error);
      }, a.onupgradeneeded = (d) => {
        d.target.result.createObjectStore(this.storeName);
      }, a.onsuccess = (d) => {
        const l = d.target.result, u = l.transaction(this.storeName, "readwrite"), y = u.objectStore(this.storeName).put(n, t);
        y.onsuccess = () => {
          s(n);
        }, y.onerror = () => {
          c(y.error);
        }, u.oncomplete = () => {
          l.close();
        };
      };
    });
  }
  openDatabase() {
    const t = this;
    return new Promise(function(n, s) {
      const c = indexedDB.open(t.databaseName, 2);
      c.onupgradeneeded = function(a) {
        a.target.result.createObjectStore(t.storeName);
      }, c.onsuccess = function(a) {
        n(a.target.result);
      }, c.onerror = function(a) {
        s(a.error);
      };
    });
  }
}
var sha256 = { exports: {} };
(function(module) {
  (function() {
    var ERROR = "input is invalid type", WINDOW = typeof window == "object", root = WINDOW ? window : {};
    root.JS_SHA256_NO_WINDOW && (WINDOW = !1);
    var WEB_WORKER = !WINDOW && typeof self == "object", NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    NODE_JS ? root = commonjsGlobal : WEB_WORKER && (root = self);
    var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && !0 && module.exports, ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", HEX_CHARS = "0123456789abcdef".split(""), EXTRA = [-2147483648, 8388608, 32768, 128], SHIFT = [24, 16, 8, 0], K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ], OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"], blocks = [];
    (root.JS_SHA256_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(r) {
      return Object.prototype.toString.call(r) === "[object Array]";
    }), ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(r) {
      return typeof r == "object" && r.buffer && r.buffer.constructor === ArrayBuffer;
    });
    var createOutputMethod = function(r, t) {
      return function(n) {
        return new Sha256(t, !0).update(n)[r]();
      };
    }, createMethod = function(r) {
      var t = createOutputMethod("hex", r);
      NODE_JS && (t = nodeWrap(t, r)), t.create = function() {
        return new Sha256(r);
      }, t.update = function(c) {
        return t.create().update(c);
      };
      for (var n = 0; n < OUTPUT_TYPES.length; ++n) {
        var s = OUTPUT_TYPES[n];
        t[s] = createOutputMethod(s, r);
      }
      return t;
    }, nodeWrap = function(method, is224) {
      var crypto = eval("require('crypto')"), Buffer = eval("require('buffer').Buffer"), algorithm = is224 ? "sha224" : "sha256", nodeMethod = function(r) {
        if (typeof r == "string")
          return crypto.createHash(algorithm).update(r, "utf8").digest("hex");
        if (r == null)
          throw new Error(ERROR);
        return r.constructor === ArrayBuffer && (r = new Uint8Array(r)), Array.isArray(r) || ArrayBuffer.isView(r) || r.constructor === Buffer ? crypto.createHash(algorithm).update(new Buffer(r)).digest("hex") : method(r);
      };
      return nodeMethod;
    }, createHmacOutputMethod = function(r, t) {
      return function(n, s) {
        return new HmacSha256(n, t, !0).update(s)[r]();
      };
    }, createHmacMethod = function(r) {
      var t = createHmacOutputMethod("hex", r);
      t.create = function(c) {
        return new HmacSha256(c, r);
      }, t.update = function(c, a) {
        return t.create(c).update(a);
      };
      for (var n = 0; n < OUTPUT_TYPES.length; ++n) {
        var s = OUTPUT_TYPES[n];
        t[s] = createHmacOutputMethod(s, r);
      }
      return t;
    };
    function Sha256(r, t) {
      t ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], r ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = r;
    }
    Sha256.prototype.update = function(r) {
      if (!this.finalized) {
        var t, n = typeof r;
        if (n !== "string") {
          if (n === "object") {
            if (r === null)
              throw new Error(ERROR);
            if (ARRAY_BUFFER && r.constructor === ArrayBuffer)
              r = new Uint8Array(r);
            else if (!Array.isArray(r) && (!ARRAY_BUFFER || !ArrayBuffer.isView(r)))
              throw new Error(ERROR);
          } else
            throw new Error(ERROR);
          t = !0;
        }
        for (var s, c = 0, a, d = r.length, l = this.blocks; c < d; ) {
          if (this.hashed && (this.hashed = !1, l[0] = this.block, l[16] = l[1] = l[2] = l[3] = l[4] = l[5] = l[6] = l[7] = l[8] = l[9] = l[10] = l[11] = l[12] = l[13] = l[14] = l[15] = 0), t)
            for (a = this.start; c < d && a < 64; ++c)
              l[a >> 2] |= r[c] << SHIFT[a++ & 3];
          else
            for (a = this.start; c < d && a < 64; ++c)
              s = r.charCodeAt(c), s < 128 ? l[a >> 2] |= s << SHIFT[a++ & 3] : s < 2048 ? (l[a >> 2] |= (192 | s >> 6) << SHIFT[a++ & 3], l[a >> 2] |= (128 | s & 63) << SHIFT[a++ & 3]) : s < 55296 || s >= 57344 ? (l[a >> 2] |= (224 | s >> 12) << SHIFT[a++ & 3], l[a >> 2] |= (128 | s >> 6 & 63) << SHIFT[a++ & 3], l[a >> 2] |= (128 | s & 63) << SHIFT[a++ & 3]) : (s = 65536 + ((s & 1023) << 10 | r.charCodeAt(++c) & 1023), l[a >> 2] |= (240 | s >> 18) << SHIFT[a++ & 3], l[a >> 2] |= (128 | s >> 12 & 63) << SHIFT[a++ & 3], l[a >> 2] |= (128 | s >> 6 & 63) << SHIFT[a++ & 3], l[a >> 2] |= (128 | s & 63) << SHIFT[a++ & 3]);
          this.lastByteIndex = a, this.bytes += a - this.start, a >= 64 ? (this.block = l[16], this.start = a - 64, this.hash(), this.hashed = !0) : this.start = a;
        }
        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
      }
    }, Sha256.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var r = this.blocks, t = this.lastByteIndex;
        r[16] = this.block, r[t >> 2] |= EXTRA[t & 3], this.block = r[16], t >= 56 && (this.hashed || this.hash(), r[0] = this.block, r[16] = r[1] = r[2] = r[3] = r[4] = r[5] = r[6] = r[7] = r[8] = r[9] = r[10] = r[11] = r[12] = r[13] = r[14] = r[15] = 0), r[14] = this.hBytes << 3 | this.bytes >>> 29, r[15] = this.bytes << 3, this.hash();
      }
    }, Sha256.prototype.hash = function() {
      var r = this.h0, t = this.h1, n = this.h2, s = this.h3, c = this.h4, a = this.h5, d = this.h6, l = this.h7, u = this.blocks, f, y, g, m, p, w, S, v, x, _, A;
      for (f = 16; f < 64; ++f)
        p = u[f - 15], y = (p >>> 7 | p << 25) ^ (p >>> 18 | p << 14) ^ p >>> 3, p = u[f - 2], g = (p >>> 17 | p << 15) ^ (p >>> 19 | p << 13) ^ p >>> 10, u[f] = u[f - 16] + y + u[f - 7] + g << 0;
      for (A = t & n, f = 0; f < 64; f += 4)
        this.first ? (this.is224 ? (v = 300032, p = u[0] - 1413257819, l = p - 150054599 << 0, s = p + 24177077 << 0) : (v = 704751109, p = u[0] - 210244248, l = p - 1521486534 << 0, s = p + 143694565 << 0), this.first = !1) : (y = (r >>> 2 | r << 30) ^ (r >>> 13 | r << 19) ^ (r >>> 22 | r << 10), g = (c >>> 6 | c << 26) ^ (c >>> 11 | c << 21) ^ (c >>> 25 | c << 7), v = r & t, m = v ^ r & n ^ A, S = c & a ^ ~c & d, p = l + g + S + K[f] + u[f], w = y + m, l = s + p << 0, s = p + w << 0), y = (s >>> 2 | s << 30) ^ (s >>> 13 | s << 19) ^ (s >>> 22 | s << 10), g = (l >>> 6 | l << 26) ^ (l >>> 11 | l << 21) ^ (l >>> 25 | l << 7), x = s & r, m = x ^ s & t ^ v, S = l & c ^ ~l & a, p = d + g + S + K[f + 1] + u[f + 1], w = y + m, d = n + p << 0, n = p + w << 0, y = (n >>> 2 | n << 30) ^ (n >>> 13 | n << 19) ^ (n >>> 22 | n << 10), g = (d >>> 6 | d << 26) ^ (d >>> 11 | d << 21) ^ (d >>> 25 | d << 7), _ = n & s, m = _ ^ n & r ^ x, S = d & l ^ ~d & c, p = a + g + S + K[f + 2] + u[f + 2], w = y + m, a = t + p << 0, t = p + w << 0, y = (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10), g = (a >>> 6 | a << 26) ^ (a >>> 11 | a << 21) ^ (a >>> 25 | a << 7), A = t & n, m = A ^ t & s ^ _, S = a & d ^ ~a & l, p = c + g + S + K[f + 3] + u[f + 3], w = y + m, c = r + p << 0, r = p + w << 0;
      this.h0 = this.h0 + r << 0, this.h1 = this.h1 + t << 0, this.h2 = this.h2 + n << 0, this.h3 = this.h3 + s << 0, this.h4 = this.h4 + c << 0, this.h5 = this.h5 + a << 0, this.h6 = this.h6 + d << 0, this.h7 = this.h7 + l << 0;
    }, Sha256.prototype.hex = function() {
      this.finalize();
      var r = this.h0, t = this.h1, n = this.h2, s = this.h3, c = this.h4, a = this.h5, d = this.h6, l = this.h7, u = HEX_CHARS[r >> 28 & 15] + HEX_CHARS[r >> 24 & 15] + HEX_CHARS[r >> 20 & 15] + HEX_CHARS[r >> 16 & 15] + HEX_CHARS[r >> 12 & 15] + HEX_CHARS[r >> 8 & 15] + HEX_CHARS[r >> 4 & 15] + HEX_CHARS[r & 15] + HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[t & 15] + HEX_CHARS[n >> 28 & 15] + HEX_CHARS[n >> 24 & 15] + HEX_CHARS[n >> 20 & 15] + HEX_CHARS[n >> 16 & 15] + HEX_CHARS[n >> 12 & 15] + HEX_CHARS[n >> 8 & 15] + HEX_CHARS[n >> 4 & 15] + HEX_CHARS[n & 15] + HEX_CHARS[s >> 28 & 15] + HEX_CHARS[s >> 24 & 15] + HEX_CHARS[s >> 20 & 15] + HEX_CHARS[s >> 16 & 15] + HEX_CHARS[s >> 12 & 15] + HEX_CHARS[s >> 8 & 15] + HEX_CHARS[s >> 4 & 15] + HEX_CHARS[s & 15] + HEX_CHARS[c >> 28 & 15] + HEX_CHARS[c >> 24 & 15] + HEX_CHARS[c >> 20 & 15] + HEX_CHARS[c >> 16 & 15] + HEX_CHARS[c >> 12 & 15] + HEX_CHARS[c >> 8 & 15] + HEX_CHARS[c >> 4 & 15] + HEX_CHARS[c & 15] + HEX_CHARS[a >> 28 & 15] + HEX_CHARS[a >> 24 & 15] + HEX_CHARS[a >> 20 & 15] + HEX_CHARS[a >> 16 & 15] + HEX_CHARS[a >> 12 & 15] + HEX_CHARS[a >> 8 & 15] + HEX_CHARS[a >> 4 & 15] + HEX_CHARS[a & 15] + HEX_CHARS[d >> 28 & 15] + HEX_CHARS[d >> 24 & 15] + HEX_CHARS[d >> 20 & 15] + HEX_CHARS[d >> 16 & 15] + HEX_CHARS[d >> 12 & 15] + HEX_CHARS[d >> 8 & 15] + HEX_CHARS[d >> 4 & 15] + HEX_CHARS[d & 15];
      return this.is224 || (u += HEX_CHARS[l >> 28 & 15] + HEX_CHARS[l >> 24 & 15] + HEX_CHARS[l >> 20 & 15] + HEX_CHARS[l >> 16 & 15] + HEX_CHARS[l >> 12 & 15] + HEX_CHARS[l >> 8 & 15] + HEX_CHARS[l >> 4 & 15] + HEX_CHARS[l & 15]), u;
    }, Sha256.prototype.toString = Sha256.prototype.hex, Sha256.prototype.digest = function() {
      this.finalize();
      var r = this.h0, t = this.h1, n = this.h2, s = this.h3, c = this.h4, a = this.h5, d = this.h6, l = this.h7, u = [
        r >> 24 & 255,
        r >> 16 & 255,
        r >> 8 & 255,
        r & 255,
        t >> 24 & 255,
        t >> 16 & 255,
        t >> 8 & 255,
        t & 255,
        n >> 24 & 255,
        n >> 16 & 255,
        n >> 8 & 255,
        n & 255,
        s >> 24 & 255,
        s >> 16 & 255,
        s >> 8 & 255,
        s & 255,
        c >> 24 & 255,
        c >> 16 & 255,
        c >> 8 & 255,
        c & 255,
        a >> 24 & 255,
        a >> 16 & 255,
        a >> 8 & 255,
        a & 255,
        d >> 24 & 255,
        d >> 16 & 255,
        d >> 8 & 255,
        d & 255
      ];
      return this.is224 || u.push(l >> 24 & 255, l >> 16 & 255, l >> 8 & 255, l & 255), u;
    }, Sha256.prototype.array = Sha256.prototype.digest, Sha256.prototype.arrayBuffer = function() {
      this.finalize();
      var r = new ArrayBuffer(this.is224 ? 28 : 32), t = new DataView(r);
      return t.setUint32(0, this.h0), t.setUint32(4, this.h1), t.setUint32(8, this.h2), t.setUint32(12, this.h3), t.setUint32(16, this.h4), t.setUint32(20, this.h5), t.setUint32(24, this.h6), this.is224 || t.setUint32(28, this.h7), r;
    };
    function HmacSha256(r, t, n) {
      var s, c = typeof r;
      if (c === "string") {
        var a = [], d = r.length, l = 0, u;
        for (s = 0; s < d; ++s)
          u = r.charCodeAt(s), u < 128 ? a[l++] = u : u < 2048 ? (a[l++] = 192 | u >> 6, a[l++] = 128 | u & 63) : u < 55296 || u >= 57344 ? (a[l++] = 224 | u >> 12, a[l++] = 128 | u >> 6 & 63, a[l++] = 128 | u & 63) : (u = 65536 + ((u & 1023) << 10 | r.charCodeAt(++s) & 1023), a[l++] = 240 | u >> 18, a[l++] = 128 | u >> 12 & 63, a[l++] = 128 | u >> 6 & 63, a[l++] = 128 | u & 63);
        r = a;
      } else if (c === "object") {
        if (r === null)
          throw new Error(ERROR);
        if (ARRAY_BUFFER && r.constructor === ArrayBuffer)
          r = new Uint8Array(r);
        else if (!Array.isArray(r) && (!ARRAY_BUFFER || !ArrayBuffer.isView(r)))
          throw new Error(ERROR);
      } else
        throw new Error(ERROR);
      r.length > 64 && (r = new Sha256(t, !0).update(r).array());
      var f = [], y = [];
      for (s = 0; s < 64; ++s) {
        var g = r[s] || 0;
        f[s] = 92 ^ g, y[s] = 54 ^ g;
      }
      Sha256.call(this, t, n), this.update(y), this.oKeyPad = f, this.inner = !0, this.sharedMemory = n;
    }
    HmacSha256.prototype = new Sha256(), HmacSha256.prototype.finalize = function() {
      if (Sha256.prototype.finalize.call(this), this.inner) {
        this.inner = !1;
        var r = this.array();
        Sha256.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(r), Sha256.prototype.finalize.call(this);
      }
    };
    var exports = createMethod();
    exports.sha256 = exports, exports.sha224 = createMethod(!0), exports.sha256.hmac = createHmacMethod(), exports.sha224.hmac = createHmacMethod(!0), COMMON_JS ? module.exports = exports : (root.sha256 = exports.sha256, root.sha224 = exports.sha224);
  })();
})(sha256);
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(r) {
  return typeof r == "string" && REGEX.test(r);
}
var byteToHex = [];
for (var i = 0; i < 256; ++i)
  byteToHex.push((i + 256).toString(16).substr(1));
function stringify(r) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = (byteToHex[r[t + 0]] + byteToHex[r[t + 1]] + byteToHex[r[t + 2]] + byteToHex[r[t + 3]] + "-" + byteToHex[r[t + 4]] + byteToHex[r[t + 5]] + "-" + byteToHex[r[t + 6]] + byteToHex[r[t + 7]] + "-" + byteToHex[r[t + 8]] + byteToHex[r[t + 9]] + "-" + byteToHex[r[t + 10]] + byteToHex[r[t + 11]] + byteToHex[r[t + 12]] + byteToHex[r[t + 13]] + byteToHex[r[t + 14]] + byteToHex[r[t + 15]]).toLowerCase();
  if (!validate(n))
    throw TypeError("Stringified UUID is invalid");
  return n;
}
function v4(r, t, n) {
  r = r || {};
  var s = r.random || (r.rng || rng)();
  if (s[6] = s[6] & 15 | 64, s[8] = s[8] & 63 | 128, t) {
    n = n || 0;
    for (var c = 0; c < 16; ++c)
      t[n + c] = s[c];
    return t;
  }
  return stringify(s);
}
async function getBytes(r, t) {
  const n = r.getReader();
  let s;
  for (; !(s = await n.read()).done; )
    t(s.value);
}
function getLines(r) {
  let t, n, s, c = !1;
  return function(d) {
    t === void 0 ? (t = d, n = 0, s = -1) : t = concat(t, d);
    const l = t.length;
    let u = 0;
    for (; n < l; ) {
      c && (t[n] === 10 && (u = ++n), c = !1);
      let f = -1;
      for (; n < l && f === -1; ++n)
        switch (t[n]) {
          case 58:
            s === -1 && (s = n - u);
            break;
          case 13:
            c = !0;
          case 10:
            f = n;
            break;
        }
      if (f === -1)
        break;
      r(t.subarray(u, f), s), u = n, s = -1;
    }
    u === l ? t = void 0 : u !== 0 && (t = t.subarray(u), n -= u);
  };
}
function getMessages(r, t, n) {
  let s = newMessage();
  const c = new TextDecoder();
  return function(d, l) {
    if (d.length === 0)
      n == null || n(s), s = newMessage();
    else if (l > 0) {
      const u = c.decode(d.subarray(0, l)), f = l + (d[l + 1] === 32 ? 2 : 1), y = c.decode(d.subarray(f));
      switch (u) {
        case "data":
          s.data = s.data ? s.data + `
` + y : y;
          break;
        case "event":
          s.event = y;
          break;
        case "id":
          r(s.id = y);
          break;
        case "retry":
          const g = parseInt(y, 10);
          isNaN(g) || t(s.retry = g);
          break;
      }
    }
  };
}
function concat(r, t) {
  const n = new Uint8Array(r.length + t.length);
  return n.set(r), n.set(t, r.length), n;
}
function newMessage() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}
var __rest = function(r, t) {
  var n = {};
  for (var s in r)
    Object.prototype.hasOwnProperty.call(r, s) && t.indexOf(s) < 0 && (n[s] = r[s]);
  if (r != null && typeof Object.getOwnPropertySymbols == "function")
    for (var c = 0, s = Object.getOwnPropertySymbols(r); c < s.length; c++)
      t.indexOf(s[c]) < 0 && Object.prototype.propertyIsEnumerable.call(r, s[c]) && (n[s[c]] = r[s[c]]);
  return n;
};
const EventStreamContentType = "text/event-stream", DefaultRetryInterval = 1e3, LastEventId = "last-event-id";
function fetchEventSource(r, t) {
  var { signal: n, headers: s, onopen: c, onmessage: a, onclose: d, onerror: l, openWhenHidden: u, fetch: f } = t, y = __rest(t, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"]);
  return new Promise((g, m) => {
    const p = Object.assign({}, s);
    p.accept || (p.accept = EventStreamContentType);
    let w;
    function S() {
      w.abort(), document.hidden || T();
    }
    u || document.addEventListener("visibilitychange", S);
    let v = DefaultRetryInterval, x = 0;
    function _() {
      document.removeEventListener("visibilitychange", S), window.clearTimeout(x), w.abort();
    }
    n == null || n.addEventListener("abort", () => {
      _(), g();
    });
    const A = f ?? window.fetch, U = c ?? defaultOnOpen;
    async function T() {
      var R;
      w = new AbortController();
      try {
        const I = await A(r, Object.assign(Object.assign({}, y), { headers: p, signal: w.signal }));
        await U(I), await getBytes(I.body, getLines(getMessages((k) => {
          k ? p[LastEventId] = k : delete p[LastEventId];
        }, (k) => {
          v = k;
        }, a))), d == null || d(), _(), g();
      } catch (I) {
        if (!w.signal.aborted)
          try {
            const k = (R = l == null ? void 0 : l(I)) !== null && R !== void 0 ? R : v;
            window.clearTimeout(x), x = window.setTimeout(T, k);
          } catch (k) {
            _(), m(k);
          }
      }
    }
    T();
  });
}
function defaultOnOpen(r) {
  const t = r.headers.get("content-type");
  if (!(t != null && t.startsWith(EventStreamContentType)))
    throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${t}`);
}
function Base64EncodeUrl(r) {
  return r.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function getTimestamp() {
  return Math.floor(Date.now() / 1e3);
}
function e(r) {
  this.message = r;
}
e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
var r$1 = typeof window < "u" && window.atob && window.atob.bind(window) || function(r) {
  var t = String(r).replace(/=+$/, "");
  if (t.length % 4 == 1)
    throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var n, s, c = 0, a = 0, d = ""; s = t.charAt(a++); ~s && (n = c % 4 ? 64 * n + s : s, c++ % 4) ? d += String.fromCharCode(255 & n >> (-2 * c & 6)) : 0)
    s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(s);
  return d;
};
function t$1(r) {
  var t = r.replace(/-/g, "+").replace(/_/g, "/");
  switch (t.length % 4) {
    case 0:
      break;
    case 2:
      t += "==";
      break;
    case 3:
      t += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(n) {
      return decodeURIComponent(r$1(n).replace(/(.)/g, function(s, c) {
        var a = c.charCodeAt(0).toString(16).toUpperCase();
        return a.length < 2 && (a = "0" + a), "%" + a;
      }));
    }(t);
  } catch {
    return r$1(t);
  }
}
function n$1(r) {
  this.message = r;
}
function o(r, t) {
  if (typeof r != "string")
    throw new n$1("Invalid token specified");
  var n = (t = t || {}).header === !0 ? 0 : 1;
  try {
    return JSON.parse(t$1(r.split(".")[n]));
  } catch (s) {
    throw new n$1("Invalid token specified: " + s.message);
  }
}
n$1.prototype = new Error(), n$1.prototype.name = "InvalidTokenError";
class NylasSessions {
  constructor(t) {
    b(this, "clientId");
    b(this, "redirectUri");
    b(this, "accessType", "online");
    b(this, "domain", "http://api.nylas.com");
    b(this, "versioned", !1);
    b(this, "Storage");
    b(this, "hosted", !1);
    b(this, "multiAccount", !1);
    b(this, "loginId", "");
    if (this.clientId = t.clientId, this.redirectUri = t.redirectUri, t.domain && (this.domain = t.domain, this.domain.substring(this.domain.length - 3).includes("/v") && (this.versioned = !0)), t.multiAccount && (this.multiAccount = t.multiAccount), t.sw) {
      const n = new IndexedDBStorage();
      this.Storage = new Storage(n);
    } else
      this.Storage = new Storage();
    t.accessType && (this.accessType = t.accessType), t.loginId && (this.loginId = t.loginId), t.hosted && (this.hosted = t.hosted), t.disableInitCodeExchange !== !0 && this.codeExchange(null);
  }
  // Validates access token
  async validateAccessToken(t = "") {
    const n = await this.Storage.getGrant(t, this.multiAccount);
    if (!n)
      return !1;
    const { access_token: s } = n;
    try {
      return !!(await (await fetch(`${this.domain}/connect/tokeninfo?access_token=${s}`, {
        method: "GET"
      })).json()).data;
    } catch {
      return !1;
    }
  }
  // Validates id token
  async validateIDToken(t = "") {
    const n = await this.Storage.getGrant(t, this.multiAccount);
    if (!n)
      return !1;
    const { id_token: s } = n;
    try {
      const c = await fetch(`${this.domain}/connect/tokeninfo?id_token=${s}`, {
        method: "GET"
      });
      return !(c.status !== 200 || !(await c.json()).data);
    } catch {
      return !1;
    }
  }
  // Gets domain of UAS
  getDomain() {
    return this.domain;
  }
  // Gets auth link
  async auth(t) {
    this.hosted && (this.domain === window.location.origin || this.versioned && this.domain.includes(window.location.origin)) && await this.hostedSetCodeChallenge();
    const n = await this.generateAuthURL(t);
    if (t.popup) {
      this.popUp(n);
      return;
    }
    return n;
  }
  // Generates auth URL
  async generateAuthURL(t) {
    const n = await this.getCodeChallege();
    let s = `${this.domain}/connect/auth?client_id=${this.clientId}&redirect_uri=${this.redirectUri}&access_type=${this.accessType}&response_type=code`;
    return n && (s += `&code_challenge=${n}&code_challenge_method=S256&options=rotate_refresh_token`), t.provider && (s += `&provider=${t.provider}`), t.loginHint && (s += `&login_hint=${t.loginHint}`, t.includeGrantScopes && (s += `&include_grant_scopes=${t.includeGrantScopes}`)), t.scope && (s += `&scope=${t.scope.join(" ")}`), t.prompt && (s += `&prompt=${t.prompt}`), t.metadata && (s += `&metadata=${t.metadata}`), (t.state || this.loginId) && (s += `&state=${this.loginId ? this.loginId : t.state}`), s;
  }
  // Generates auth URL
  async generateReauthURL(t, n) {
    if (!t)
      throw new Error("Grant ID is required");
    const s = await this.Storage.getUserToken(t), c = await this.getCodeChallege();
    let a = `${this.domain}/connect/auth?client_id=${this.clientId}&redirect_uri=${this.redirectUri}&access_type=${this.accessType}&response_type=code`;
    return c && (a += `&code_challenge=${c}&code_challenge_method=S256&options=rotate_refresh_token`), s != null && s.provider && (a += `&provider=${s.provider}`), s != null && s.email && (a += `&login_hint=${s.email}`), n && (a += `&scope=${n.join(" ")}`), a;
  }
  // Generates UUID code challenge
  async generateCodeChallenge() {
    if (await this.Storage.getPKCE())
      return;
    const n = v4();
    this.Storage.setPKCE(n);
  }
  // Gets code challenge from URL query params
  async hostedSetCodeChallenge() {
    if (!this.hosted)
      throw console.error("Method only used with hosted flag enabled");
    const n = new URLSearchParams(window.location.search).get("code_challenge");
    if (!n) {
      if (await this.Storage.getPKCE())
        return;
      console.warn("Code challenge is recomended");
      return;
    }
    this.Storage.setPKCE(n);
  }
  // Gets code challenge from store
  async getCodeChallege() {
    if (this.hosted && (this.domain === window.location.origin || this.versioned && this.domain.includes(window.location.origin))) {
      const s = new URLSearchParams(window.location.search).get("code_challenge");
      return s || (console.warn("Code challenge is recomended"), "");
    }
    const t = await this.Storage.getPKCE();
    if (t) {
      const n = sha256.exports.sha256(t);
      let s = Buffer.from(n).toString("base64");
      return s = Base64EncodeUrl(s), s;
    }
    return "";
  }
  // checks if user is logged in
  async isLoggedIn() {
    if (this.hosted && (this.domain === window.location.origin || this.versioned && this.domain.includes(window.location.origin)))
      return !1;
    const t = await this.Storage.getUserTokens();
    return t && t.length > 0 ? (this.multiAccount && await this.generateCodeChallenge(), !0) : (await this.generateCodeChallenge(), !1);
  }
  // Checks if user is multi account
  isMultiAccount() {
    return this.multiAccount;
  }
  // Logs user out
  async logout() {
    const t = await this.getProfile();
    await this.Storage.clearSession();
    const n = { detail: t };
    window.dispatchEvent(new CustomEvent("onLogoutSuccess", n));
  }
  // Gets profile info from ID token
  async getProfile(t = "") {
    let n;
    return t ? n = await this.Storage.getUserToken(t) : n = await this.Storage.getUserToken(), n || null;
  }
  // Gets profile info from ID tokens
  async getProfiles() {
    const t = await this.Storage.getUserTokens();
    return t || null;
  }
  // Remove a specific profile
  async removeProfile(t) {
    return await this.Storage.removeUserToken(t), await this.Storage.removeGrant(t), null;
  }
  // IMAP authentication
  async authIMAP(t) {
    const n = await this.getCodeChallege(), s = {
      imap_username: t.imap_username,
      imap_password: t.imap_password,
      imap_host: t.imap_host,
      imap_port: t.imap_port,
      type: t.type,
      smtp_host: t.smtp_host,
      smtp_port: t.smtp_port,
      provider: t.provider,
      redirect_uri: this.redirectUri,
      state: t.state,
      public_application_id: this.clientId,
      access_type: this.accessType
    };
    return this.loginId && (s.id = this.loginId), t.smtp_username && t.smtp_password && (s.smtp_username = t.smtp_username, s.smtp_password = t.smtp_password), n != "" && (s.code_challenge = n, s.code_challenge_method = "S256"), await (await fetch(`${this.domain}/connect/login/imap`, {
      method: "POST",
      headers: new Headers({ "content-type": "application/json" }),
      body: JSON.stringify(s)
    })).json();
  }
  // EWS authentication
  async authEWS(t) {
    const n = await this.getCodeChallege(), s = {
      ...t,
      provider: "ews",
      redirect_uri: this.redirectUri,
      public_application_id: this.clientId,
      access_type: this.accessType
    };
    return this.loginId && (s.id = this.loginId), n != "" && (s.code_challenge = n, s.code_challenge_method = "S256"), await (await fetch(`${this.domain}/connect/login/ews`, {
      method: "POST",
      headers: new Headers({ "content-type": "application/json" }),
      body: JSON.stringify(s)
    })).json();
  }
  // Detects email
  async detectEmail(t) {
    return await (await fetch(`${this.versioned ? this.domain : this.domain + "/connect"}/providers/detect?client_id=${this.clientId}&email=${t}`, {
      method: "POST",
      headers: new Headers({ "content-type": "application/json" })
    })).json();
  }
  // Gets app info from UAS
  async applicationInfo() {
    return (await (await fetch(`${this.versioned ? this.domain : this.domain + "/connect"}/applications?client_id=${this.clientId}`, {
      method: "GET",
      headers: new Headers({ "content-type": "application/json" })
    })).json()).data;
  }
  // Gets providers form UAS
  async getAvailableProviders() {
    const t = await fetch(`${this.domain}/connect/providers/find?client_id=${this.clientId}`, {
      method: "GET",
      headers: new Headers({ "content-type": "application/json" })
    });
    return t ? (await t.json()).data : null;
  }
  // EVENT HOOKS
  onLoginSuccess(t) {
    window.addEventListener("onLoginSuccess", (n) => t(n));
  }
  onLogoutSuccess(t) {
    window.addEventListener("onLogoutSuccess", (n) => t(n));
  }
  onLoginFail(t) {
    window.addEventListener("onLoginFail", (n) => t(n));
  }
  onTokenRefreshSuccess(t) {
    window.addEventListener("onTokenRefreshSuccess", (n) => t(n));
  }
  onTokenRefreshFail(t) {
    window.addEventListener("onTokenRefreshFail", (n) => t(n));
  }
  onSessionExpired(t) {
    window.addEventListener("onSessionExpired", (n) => t(n));
  }
  // Exchanges code for ID token and refresh and access tokens
  async codeExchange(t) {
    let n = new URLSearchParams(window.location.search);
    t && (n = new URLSearchParams(t));
    const s = n.get("code"), c = n.get("state"), a = n.get("error"), d = n.get("error_description"), l = n.get("error_code");
    if (a && d && l) {
      const f = {
        detail: { error: a, error_description: d, error_code: l }
      };
      return window.dispatchEvent(new CustomEvent("onLoginFail", f)), window.history.pushState({}, document.title, window.location.pathname), !1;
    }
    if (!s)
      return console.warn("No code found"), !1;
    if (window.opener && window.name === "uas-popup")
      return console.warn("Popup window detected"), !1;
    const u = await this.Storage.getPKCE();
    if (!u)
      return console.warn("No code verifier found"), !1;
    try {
      const f = {
        client_id: this.clientId,
        redirect_uri: this.redirectUri,
        code: s,
        grant_type: "authorization_code",
        code_verifier: u
      }, g = await (await fetch(`${this.domain}/connect/token`, {
        method: "POST",
        headers: new Headers({ "content-type": "application/json" }),
        body: JSON.stringify(f)
      })).json();
      if (g) {
        if (g.error) {
          const p = { detail: g };
          return window.dispatchEvent(new CustomEvent("onLoginFail", p)), !0;
        }
        const m = await this.handleCodeExchangeResponse(g);
        if (m.valid) {
          c && (m.data.state = c);
          const p = { detail: m.data };
          window.dispatchEvent(new CustomEvent("onLoginSuccess", p)), window.history.pushState({}, document.title, window.location.pathname);
        } else {
          const p = { detail: m.data };
          return window.dispatchEvent(new CustomEvent("onLoginFail", p)), !0;
        }
      }
      return this.Storage.removePKCE(), !0;
    } catch (f) {
      const y = { detail: f };
      return window.dispatchEvent(new CustomEvent("onLoginFail", y)), window.history.pushState({}, document.title, window.location.pathname), !1;
    }
  }
  // Token Exchange for session  maintenece
  async tokenExchange(t = "") {
    const n = await this.Storage.getGrant(t, this.multiAccount);
    if (!n)
      return !1;
    const s = n.refresh_token;
    try {
      const c = {
        client_id: this.clientId,
        redirect_uri: this.redirectUri,
        refresh_token: s,
        grant_type: "refresh_token"
      }, d = await (await fetch(`${this.domain}/connect/token`, {
        method: "POST",
        headers: new Headers({ "content-type": "application/json" }),
        body: JSON.stringify(c)
      })).json();
      if (d) {
        if (d.error) {
          const y = { detail: d };
          return window.dispatchEvent(new CustomEvent("onTokenRefreshFail", y)), !0;
        }
        const l = getTimestamp();
        if (d.expires_in = l + d.expires_in, this.Storage.setGrant(d, this.multiAccount), !await this.validateIDToken(t)) {
          const y = { detail: d };
          return window.dispatchEvent(new CustomEvent("onTokenRefreshFail", y)), !0;
        }
        const f = { detail: d };
        return window.dispatchEvent(new CustomEvent("onTokenRefreshSuccess", f)), !0;
      }
      this.Storage.removePKCE();
    } catch (c) {
      const a = { detail: c };
      return window.dispatchEvent(new CustomEvent("onTokenRefreshFail", a)), !1;
    }
  }
  // Handles the response of code exchange
  async handleCodeExchangeResponse(t) {
    if (t.error)
      return {
        data: t,
        valid: !1
      };
    const s = getTimestamp();
    t.expires_in = s + t.expires_in, this.Storage.setGrant(t, this.multiAccount);
    const c = o(t.id_token);
    return c.status = "authenticated", this.Storage.setUserToken(c), await this.validateIDToken(c.sub) ? {
      data: t,
      valid: !0
    } : {
      data: t,
      valid: !1
    };
  }
  // Regulates POPUP behaivior
  async popUp(t) {
    const c = window.screenX + (window.outerWidth - 500) / 2, a = window.screenY + (window.outerHeight - 600) / 2.5, d = "uas-popup", l = t, u = window.open(l, d, `width=500,height=600,left=${c},top=${a}`);
    if (!u)
      return;
    const f = setInterval(async () => {
      if (u.closed) {
        const y = {
          detail: { error_description: "OAuth provider window closed" }
        };
        window.dispatchEvent(new CustomEvent("onLoginFail", y)), f && clearInterval(f);
        return;
      }
      try {
        const y = u.location.href.split("?");
        if (!y[0])
          return;
        const g = u.location.search;
        if (u.history.pushState({}, document.title, window.location.pathname), y[0] === this.redirectUri && y.length > 1) {
          const m = await this.codeExchange(g);
          u.close(), m && location.reload(), f && clearInterval(f);
          return;
        }
      } catch {
        return;
      }
    }, 1e3);
  }
  // Returns access token
  async getAccessToken(t = "") {
    const n = getTimestamp(), s = await this.Storage.getGrant(t, this.multiAccount);
    if (!s)
      return null;
    const { access_token: c, expires_in: a } = s, d = c;
    return d && a && a > getTimestamp() && a - n > 30 ? d : (await this.tokenExchange(t), (await this.Storage.getGrant(t, this.multiAccount)).access_token);
  }
  async sse(t, n) {
    const s = n.headers || {}, c = s["Grant-ID"];
    let a = "";
    if (this.multiAccount) {
      if (!c)
        throw this.logout(), new Error("Grant ID is required for multi account calls");
      a = await this.getAccessToken(c);
    } else
      a = await this.getAccessToken();
    return delete s["Grant-ID"], s.Authorization = `Bearer ${a}`, s["content-type"] || (s["content-type"] = "application/json"), fetchEventSource(`${this.domain}/${t}`, {
      ...n,
      headers: s
    });
  }
  // Used to call Nylas API endpoints
  async fetch(t, n, s = !0, c) {
    let a = "", d = 1;
    if (this.multiAccount) {
      if (!n.grant_id)
        throw this.logout(), new Error("Grant ID is required for multi account calls");
      const u = await this.getProfiles();
      d = u ? u.length : 1, a = await this.getAccessToken(n.grant_id);
    } else
      a = await this.getAccessToken();
    if (!a)
      throw new Error("Access token not found");
    let l = n.headers;
    Headers.prototype.isPrototypeOf(l) ? (l.append("Authorization", `Bearer ${a}`), l.has("content-type") || l.append("content-type", "application/json")) : l = new Headers({
      Authorization: `Bearer ${a}`,
      "content-type": "application/json"
    });
    try {
      n != null && n.body && (n.body = JSON.stringify(n == null ? void 0 : n.body));
      const u = await fetch(`${c || this.domain}/${t}`, {
        ...n,
        headers: l
      });
      if (!s)
        return u;
      const f = await (u == null ? void 0 : u.json());
      if (!await this.isAuthenticatedResponse(u.status, f)) {
        if (d > 1) {
          const g = await this.getProfile(n.grant_id);
          if (g) {
            g.status = "unauthorized", await this.Storage.setUserToken(g);
            const m = {
              detail: { user: g }
            };
            window.dispatchEvent(new CustomEvent("onSessionExpired", m));
          }
        } else {
          const m = {
            detail: { user: await this.Storage.getUserToken() }
          };
          window.dispatchEvent(new CustomEvent("onSessionExpired", m));
        }
        this.logout();
        return;
      }
      return f;
    } catch (u) {
      throw u;
    }
  }
  async fetchRequest(t, n, s, c = !0, a, d) {
    const l = await this.isLoggedIn(), u = new URL(t, a ?? this.domain), f = new Headers();
    if (f.append("Accept", "application/json"), f.append("Content-Type", "application/json"), f.append("User-Agent", "nylas-identity"), l) {
      const m = await this.getAccessToken();
      f.append("Authorization", `Bearer ${m}`);
    }
    const y = await fetch(u.toString(), {
      method: n || "GET",
      headers: f,
      mode: "cors",
      referrer: location.origin,
      body: s ? JSON.stringify(s) : void 0,
      ...d || {}
    });
    return c ? await y.json() : y.body;
  }
  // Checks if the response is not 401
  async isAuthenticatedResponse(t, n) {
    var s;
    return !(t == 401 && ((s = n == null ? void 0 : n.error) == null ? void 0 : s.type) == "token.unauthorized_access");
  }
  addAPIKey(t, n, s) {
    this.Storage.setUserToken({
      aud: "https://api-staging.us.nylas.com/",
      exp: 2e9,
      email_verified: !0,
      iat: getTimestamp(),
      iss: "",
      email: n,
      provider: "virtual-calendar",
      status: "authenticated",
      name: n,
      sub: t
    }), this.Storage.setGrant({
      grant_id: t,
      access_token: s,
      expires_in: 2e9
    }, this.multiAccount);
  }
}
var B = { isMounted: function() {
  return !1;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C = Object.assign, D = {};
function E(r, t, n) {
  this.props = r, this.context = t, this.refs = D, this.updater = n || B;
}
E.prototype.isReactComponent = {};
E.prototype.setState = function(r, t) {
  if (typeof r != "object" && typeof r != "function" && r != null)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, r, t, "setState");
};
E.prototype.forceUpdate = function(r) {
  this.updater.enqueueForceUpdate(this, r, "forceUpdate");
};
function F() {
}
F.prototype = E.prototype;
function G(r, t, n) {
  this.props = r, this.context = t, this.refs = D, this.updater = n || B;
}
var H = G.prototype = new F();
H.constructor = G;
C(H, E.prototype);
H.isPureReactComponent = !0;
const LoginRequired = ({ authenticationUrl: r }) => h(
  "div",
  { class: "login-required", part: "nse__login-required login-component" },
  h(
    "div",
    { class: "card", part: "nse__login-required-card" },
    h("p", { part: "nse__login-required-text" }, "Log into your account to use the Scheduler Editor."),
    h(
      "button",
      { class: "google-button", part: "nse__login-required-google-button", onClick: async (t) => {
        t.preventDefault();
        const n = await r("google");
        n ? window.location.href = n : console.error("[nylas-scheduler-editor] Unable to get authentication URL.");
      } },
      h(
        "span",
        { class: "icon" },
        h("google-logo-icon", { width: "15", height: "15" })
      ),
      "Continue with Google"
    ),
    h(
      "button",
      { class: "microsoft-button", part: "nse__login-required-microsoft-button", onClick: async (t) => {
        t.preventDefault();
        const n = await r("microsoft");
        n ? window.location.href = n : console.error("[nylas-scheduler-editor] Unable to get authentication URL.");
      } },
      h(
        "span",
        { class: "icon" },
        h("microsoft-logo-icon", { width: "15", height: "15" })
      ),
      "Continue with Microsoft"
    ),
    h(
      "button",
      { class: "other-provider-button", part: "nse__login-required-other-provider-button", onClick: async (t) => {
        t.preventDefault();
        const n = await r();
        n ? window.location.href = n : console.error("[nylas-scheduler-editor] Unable to get authentication URL.");
      } },
      "View all providers ",
      h("chevron-icon", { width: "17", height: "17" })
    ),
    h("small", { class: "disclaimer-text", part: "nse__login-required-disclaimer-text" }, "* You will be redirected to authenticate your account.")
  )
);
function ExpressFlow({ currentUser: r, calendars: t }) {
  const n = (t == null ? void 0 : t.find((s) => s.is_primary)) || (t == null ? void 0 : t[0]);
  return h(
    Fragment,
    null,
    h(
      "nylas-event-info",
      null,
      h(
        "div",
        { slot: "inputs" },
        h("nylas-event-title", null),
        h("nylas-event-duration", null),
        h("nylas-event-location", { userProvider: r.provider })
      )
    ),
    h("nylas-booking-calendar-picker", { expressFlow: !0, calendars: t, currentUser: r, defaultBookingCalendar: n == null ? void 0 : n.id }),
    h("nylas-scheduling-method", { exportparts: "nsm, nsm__header, nsm__input-label, nsm__dropdown, nsm__dropdown-button, nsm__dropdown-content" }),
    h("nylas-custom-event-slug", { name: "custom-event-slug", exportparts: "nces, nces__body, nces__header, nces__drawer-toggle--container, nces__input-textfield" })
  );
}
const nylasSchedulerEditorCss = ':host{display:flex;flex-direction:column;overflow:visible;border-radius:var(--nylas-border-radius-2x);width:fit-content;background:var(--nylas-base-0);position:relative;box-shadow:0px 0px 6px -2px rgba(0, 0, 0, 0.05), 0px 5px 15px -3px rgba(0, 0, 0, 0.1);--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:"Inter", sans-serif}@media screen and (max-width: 768px){:host{width:-moz-available;width:-webkit-fill-available;width:fill-available;min-width:325px}}div.scheduler-editor-content{height:610px}@media screen and (max-width: 768px){div.scheduler-editor-content{height:auto}}div.scheduler-editor-header{display:grid;grid-template-columns:1fr auto auto;align-items:center;justify-content:space-between;padding:1rem;border-bottom:1px solid var(--nylas-base-200);color:var(--nylas-base-900);width:924px}@media screen and (max-width: 768px){div.scheduler-editor-header{width:auto;min-width:calc(325px - 1rem)}}div.scheduler-editor-header h1.scheduler-editor-title{display:flex;align-items:center;gap:0.5rem;margin:0;font-size:18px;line-height:24px;font-weight:600}div.scheduler-editor-header button{background:transparent;border:none;cursor:pointer}div.scheduler-editor-header button:hover,div.scheduler-editor-header button:active{color:var(--nylas-primary)}div.scheduler-editor-header button:disabled{cursor:not-allowed}div.scheduler-editor-header div.language select-dropdown::part(sd_dropdown-button){border:none;padding:4px;margin-right:8px}div.scheduler-editor-header div.language select-dropdown::part(sd_dropdown-button):hover{outline:none;color:var(--nylas-primary)}@media screen and (max-width: 768px){div.scheduler-editor-header div.language select-dropdown::part(sd_dropdown-content){width:-webkit-fill-available;width:fill-available;width:-moz-available}}nylas-editor-tabs{width:auto;height:inherit}nylas-editor-tabs .composable{height:inherit;overflow:auto}nylas-editor-tabs nylas-event-info div[slot=inputs],nylas-editor-tabs nylas-event-limits div[slot=inputs]{display:flex;flex-direction:column;gap:1rem}.card{display:flex;flex-direction:column;padding:2rem;background-color:var(--nylas-base-0);border:1px solid var(--nylas-base-200);border-radius:5px;max-width:fit-content;align-self:center}.login-required{height:inherit;overflow-y:auto;display:flex;flex-direction:column;justify-content:center;padding:2rem 1rem;background-color:var(--nylas-base-25);border-radius:var(--nylas-border-radius-2x)}@media screen and (max-width: 768px){.login-required{height:auto}}.login-required p{margin:0 0 1rem}.login-required .microsoft-button,.login-required .google-button{height:48px;border:1px solid var(--nylas-base-300);border-radius:var(--nylas-border-radius-2x);font-size:16px;line-height:24px;padding:0 1rem;background-color:var(--nylas-base-0);font-weight:600;cursor:pointer;display:flex;margin-bottom:1rem;background-color:var(--nylas-base-0);border:1px solid var(--nylas-base-200);border-radius:5px;justify-content:center;gap:0.5rem;align-items:center}.login-required .microsoft-button:hover,.login-required .google-button:hover{background-color:var(--nylas-base-25)}.login-required .microsoft-button:hover,.login-required .google-button:hover{background-color:var(--nylas-base-25)}.login-required .other-provider-button{height:48px;border:1px solid var(--nylas-base-300);border-radius:var(--nylas-border-radius-2x);font-size:16px;line-height:24px;padding:0 1rem;background-color:var(--nylas-base-0);font-weight:600;cursor:pointer;display:flex;border:0;background-color:var(--nylas-base-0);height:48px;margin-bottom:1rem;font-size:0.95rem;justify-content:center;gap:0.25rem;align-items:center}.login-required .other-provider-button:hover{background-color:var(--nylas-base-25)}.login-required .other-provider-button svg{transform:rotate(180deg)}.login-required .other-provider-button:hover{background-color:var(--nylas-base-25)}.login-required .disclaimer-text{font-size:0.75rem;color:var(--nylas-base-600);align-self:center}.list-configurations{padding:2rem;height:inherit;background:var(--nylas-base-25);border-radius:var(--nylas-border-radius-2x)}@media screen and (max-width: 768px){.list-configurations{height:auto;padding:2rem 1rem}}.list-configurations nylas-list-configurations{height:inherit;display:flex;flex-direction:column}', NylasSchedulerEditorStyle0 = nylasSchedulerEditorCss, NylasSchedulerEditor = class {
  constructor(r) {
    registerInstance(this, r), this.init = createEvent(this, "init", 7), this.loggedIn = createEvent(this, "loggedIn", 7), this.loggedOut = createEvent(this, "loggedOut", 7), this.schedulerConfigCloseClicked = createEvent(this, "schedulerConfigCloseClicked", 7), this.handleSchedulerConfigCloseClicked = (t) => {
      const n = this.schedulerConfigCloseClicked.emit(this.host);
      "schedulerConfigCloseClicked" in this.eventOverrides && this.eventOverrides.schedulerConfigCloseClicked(n, this.nylasSchedulerConfigConnector), n.defaultPrevented || (localStorage.removeItem("grant"), localStorage.removeItem("user"), window.location.reload());
    }, this.authenticationUrl = async (t) => this.nylasApiRequest ? await this.nylasApiRequest.authenticationUrl({ provider: t }) || "" : (console.error("[nylas-scheduler-editor] Nylas API Request is not initialized."), ""), this.configurationId = void 0, this.nylasApiRequest = void 0, this.nylasSessionsConfig = void 0, this.defaultAuthArgs = void 0, this.eventOverrides = {}, this.schedulerPreviewLink = "", this.defaultSchedulerConfigState = void 0, this.mode = "app", this.additionalParticipants = void 0, this.hideEditorTabs = [], this.conferenceProviders = void 0, this.requiresSlug = !1, this.enableUserFeedback = !0, this.defaultLanguage = void 0, this.localization = void 0, this.automaticComponentRegistration = !0, this.selectedLanguage = this.defaultLanguage || LANGUAGE_CODE.en;
  }
  connectedCallback() {
    debug("[nylas-scheduler-editor] connectedCallback");
  }
  async componentWillLoad() {
    var s, c, a, d, l, u, f, y;
    debug("[nylas-scheduler-editor] componentWillLoad");
    const r = (s = this.additionalParticipants) == null ? void 0 : s.filter((g) => {
      var p;
      const m = ((p = g.calendars) == null ? void 0 : p.length) > 0 ? g.calendars.filter((w) => w.id && w.name) : [];
      if (g.name && g.email && m.length > 0)
        return {
          name: g.name,
          email: g.email,
          calendars: m
        };
    });
    if (this.stores = {
      schedulerConfig: CreateNylasSchedulerConfigStore({
        ...this.defaultSchedulerConfigState,
        additionalParticipants: r,
        conferenceProviders: this.conferenceProviders,
        requiresSlug: this.requiresSlug,
        selectedLanguage: this.defaultLanguage || LANGUAGE_CODE.en
      })
    }, !this.nylasApiRequest && this.nylasSessionsConfig) {
      const g = new NylasSessions(this.nylasSessionsConfig);
      await g.isLoggedIn(), g.onLoginSuccess(async () => {
        var p, w;
        const m = await ((w = (p = this.nylasSchedulerConfigConnector) == null ? void 0 : p.schedulerConfig) == null ? void 0 : w.currentUser());
        if (m) {
          const S = this.loggedIn.emit(this.host);
          "loggedIn" in this.eventOverrides && await this.eventOverrides.loggedIn(S, this.nylasSchedulerConfigConnector), S.defaultPrevented || await this.loggedInHandler(m);
        }
      }), g.onLoginFail(async () => {
        var p, w;
        (w = (p = this.stores) == null ? void 0 : p.schedulerConfig) == null || w.set("currentUser", null);
        const m = this.loggedOut.emit(this.host);
        "loggedOut" in this.eventOverrides && (await this.eventOverrides.loggedOut(m, this.nylasSchedulerConfigConnector), m.defaultPrevented);
      }), this.nylasApiRequest = new NylasIdentityRequestWrapper(g);
    }
    this.nylasApiRequest && this.defaultAuthArgs && this.nylasApiRequest.setDefaultAuthArgs(this.defaultAuthArgs), this.baseProvider = new NylasBaseProvider(this.host, this.stores, this.automaticComponentRegistration, this.eventOverrides);
    const t = this.baseProvider.getStore("schedulerConfig");
    this.nylasSchedulerConfigConnector = new NylasSchedulerConfigConnector({
      nylasApiRequest: this.nylasApiRequest,
      nylasSchedulerConfigStore: t
    });
    const n = this.init.emit(this.host);
    if ("init" in this.eventOverrides && await this.eventOverrides.init(n, this.nylasSchedulerConfigConnector), !n.defaultPrevented) {
      const g = await ((a = (c = this.nylasSchedulerConfigConnector) == null ? void 0 : c.schedulerConfig) == null ? void 0 : a.currentUser());
      if (g) {
        const m = this.loggedIn.emit(this.host);
        "loggedIn" in this.eventOverrides && await this.eventOverrides.loggedIn(m, this.nylasSchedulerConfigConnector), m.defaultPrevented || await this.loggedInHandler(g);
      } else {
        (l = (d = this.stores) == null ? void 0 : d.schedulerConfig) == null || l.set("currentUser", null);
        const m = this.loggedOut.emit(this.host);
        if ("loggedOut" in this.eventOverrides && (await this.eventOverrides.loggedOut(m, this.nylasSchedulerConfigConnector), m.defaultPrevented))
          return;
      }
    }
    (f = (u = this.stores) == null ? void 0 : u.schedulerConfig) == null || f.onChange("selectedConfiguration", async (g) => {
      g && g.id && (this.configurationId = g.id);
    }), (y = this.baseProvider) == null || y.componentWillLoad(this.nylasSchedulerConfigConnector);
  }
  async componentDidLoad() {
    var r;
    debug("[nylas-scheduler-editor] componentDidLoad"), await ((r = this.baseProvider) == null ? void 0 : r.componentDidLoad()), this.updateLocalization(this.localization);
  }
  async componentDisconnected() {
    var r;
    await ((r = this.baseProvider) == null ? void 0 : r.componentDisconnected());
  }
  async configurationIdChanged(r) {
    var t, n, s, c, a, d, l, u;
    r ? (await ((n = (t = this.nylasSchedulerConfigConnector) == null ? void 0 : t.schedulerConfig) == null ? void 0 : n.getConfigurationById(r)), (c = (s = this.stores) == null ? void 0 : s.schedulerConfig) == null || c.set("action", "edit")) : ((d = (a = this.stores) == null ? void 0 : a.schedulerConfig) == null || d.set("selectedConfiguration", {}), (u = (l = this.stores) == null ? void 0 : l.schedulerConfig) == null || u.set("action", null));
  }
  updateLocalization(r) {
    r && Object.keys(r).forEach((t) => {
      t in LANGUAGE_CODE && instance.addResourceBundle(t, "translation", r[t], !1, !0);
    });
  }
  async store() {
    var r;
    return (r = this.stores) == null ? void 0 : r.schedulerConfig;
  }
  async schedulerConnector() {
    return this.nylasSchedulerConfigConnector;
  }
  async registerComponentHandler(r) {
    var t;
    (t = this.baseProvider) == null || t.registerComponent(r.detail);
  }
  async unregisterComponentHandler(r) {
    var t;
    (t = this.baseProvider) == null || t.unregisterComponent(r.detail);
  }
  nylasFormDropdownChangedHandler(r) {
    var s, c;
    const { name: t, value: n } = r.detail;
    t === "language" && (this.selectedLanguage = LANGUAGE_CODE[n], instance.changeLanguage(this.selectedLanguage), (c = (s = this.stores) == null ? void 0 : s.schedulerConfig) == null || c.set("selectedLanguage", this.selectedLanguage));
  }
  async loggedInHandler(r) {
    var t, n, s, c, a, d, l;
    if ((n = (t = this.stores) == null ? void 0 : t.schedulerConfig) == null || n.set("currentUser", r), !!this.nylasSchedulerConfigConnector && (await ((s = this.nylasSchedulerConfigConnector.schedulerConfig) == null ? void 0 : s.getCalendars()), this.configurationId)) {
      const u = await ((c = this.nylasSchedulerConfigConnector.schedulerConfig) == null ? void 0 : c.getConfigurationById(this.configurationId));
      u && ((a = u[0]) != null && a.id) && ((l = (d = this.stores) == null ? void 0 : d.schedulerConfig) == null || l.set("action", "edit"));
    }
  }
  render() {
    var s, c, a, d, l, u, f, y, g, m, p, w, S, v, x, _, A, U, T;
    const r = this.host.querySelector('[slot="custom-page-style-inputs"]'), t = (a = (c = (s = this.stores) == null ? void 0 : s.schedulerConfig) == null ? void 0 : c.state.selectedConfiguration) == null ? void 0 : a.id, n = Object.keys(LANGUAGE_MAP).map((R) => ({
      label: LANGUAGE_MAP[R],
      value: R
    }));
    return h(Host, { key: "75f05f7ea3eb41f3610cd9a1d60196ee52f9e5ca" }, h("div", { key: "096bb8dbd32a0fc7ee3d37e7967d94d478410999", class: "scheduler-editor-header", part: "nse__header" }, h("h1", { key: "560bcc4419cafde8d07f49f9533ab45faaf4a8e0", class: "scheduler-editor-title", part: "nse__title" }, h("calendar-icon", { key: "f4f6ae5e32f30199a5b8db1094fb1fcfb19c3a53", width: "18", height: "18" }), instance.t("schedulerEditorTitle")), h("div", { key: "6150a5c179ebc92f8f076ed2cf9810d9c0ec301d", class: {
      language: !0
    }, part: "nse__language" }, h("select-dropdown", { key: "2aaf54341c6f44a605428d5c15ed6931d6623d2e", name: "language", options: n, withChevron: !1, defaultSelectedOption: n.find((R) => R.value == this.selectedLanguage), exportparts: "sd_dropdown: nse__language-dropdown, sd_dropdown-button: nse__language-drop-button, sd_dropdown-content: nse__language-drop-content, sd_dropdown_label: nse__language-drop-label" }, h("span", { key: "4299e684efc7a2024457cfa3ae0ec9ed1312dd6b", slot: "select-icon" }, h("translate-icon", { key: "c6fd888c7c9b2e15b21f7693d8fe17ebe0f511d5", width: "20", height: "20" })))), h("button", { key: "dc1ef92010c142ecdd6c1748c3fe669044af7d61", class: "scheduler-editor-close", title: "logout", onClick: (R) => this.handleSchedulerConfigCloseClicked(R), part: "nse__close-button" }, h("close-icon", { key: "ae4dce679cbcfe0281337407d5303e7378b83669", width: "18", height: "18" }))), h("div", { key: "18dac5e2484e313ba211748be61c17138d31ebf0", class: "scheduler-editor-content", part: "nse__content" }, ((l = (d = this.stores) == null ? void 0 : d.schedulerConfig) == null ? void 0 : l.state.currentUser) && this.stores.schedulerConfig.state.action === null && h("div", { class: "list-configurations", part: "nse__list-configurations" }, h("nylas-list-configurations", { exportparts: "nlc__create-new-cta" })), ((f = (u = this.stores) == null ? void 0 : u.schedulerConfig) == null ? void 0 : f.state.currentUser) && this.stores.schedulerConfig.state.action === "create" && h("nylas-editor-tabs", { mode: "composable" }, h(ExpressFlow, { currentUser: (g = (y = this.stores) == null ? void 0 : y.schedulerConfig) == null ? void 0 : g.state.currentUser, calendars: (w = (p = (m = this.stores) == null ? void 0 : m.schedulerConfig) == null ? void 0 : p.state) == null ? void 0 : w.calendars, selectedConfiguration: (x = (v = (S = this.stores) == null ? void 0 : S.schedulerConfig) == null ? void 0 : v.state) == null ? void 0 : x.selectedConfiguration })), ((A = (_ = this.stores) == null ? void 0 : _.schedulerConfig) == null ? void 0 : A.state.currentUser) && this.stores.schedulerConfig.state.action === "edit" && h("nylas-editor-tabs", { key: t, mode: this.mode }, this.mode === "composable" && h("slot", null), this.mode === "app" && r && h("div", { style: { display: "none" }, slot: "custom-page-style-inputs", key: t }, h("slot", { name: "custom-page-style-inputs" }))), !((T = (U = this.stores) == null ? void 0 : U.schedulerConfig) != null && T.state.currentUser) && h("slot", { name: "login-required" }, h(LoginRequired, { authenticationUrl: this.authenticationUrl }))));
  }
  get host() {
    return getElement(this);
  }
  static get watchers() {
    return {
      configurationId: ["configurationIdChanged"],
      localization: ["updateLocalization"]
    };
  }
};
NylasSchedulerEditor.style = NylasSchedulerEditorStyle0;
export {
  NylasSchedulerEditor as nylas_scheduler_editor
};
