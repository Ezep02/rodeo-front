import { d, P as m, g as P } from "./index-cd93b584.js";
function b(e, o, c = "registerComponent") {
  return new CustomEvent(c, {
    bubbles: !0,
    composed: !0,
    detail: o
  });
}
function T(e, o, c = "unregisterComponent") {
  return new CustomEvent(c, {
    bubbles: !0,
    composed: !0,
    detail: o
  });
}
function v(e) {
  return (o, c) => {
    const r = e.name;
    d(`[${r}] Registering component ${r} being called on ${c}`);
    const u = o.componentWillLoad;
    if (!u) {
      m(`[${r}] componentWillLoad lifecycle method in ${r} missing. Required for RegisterComponent decorator.`);
      return;
    }
    const p = o.connectedCallback;
    if (!p) {
      m(`[${r}] connectedCallback lifecycle method in ${r} missing. Required for RegisterComponent decorator.`);
      return;
    }
    const l = o.disconnectedCallback;
    if (!l) {
      m(`[${r}] disconnectedCallback lifecycle method in ${r} missing. Required for RegisterComponent decorator.`);
      return;
    }
    if (e.storeToProps && e.stateToProps) {
      const n = Array.from(e.storeToProps.values()), t = Array.from(e.stateToProps.values()), s = n.filter((i) => t.includes(i));
      if (s.length > 0) {
        m(`[${r}] Overlapping prop keys detected in ${r} for storeToProps and stateToProps. Make sure to only define them once. Overlapping keys: ${s.join(", ")}`);
        return;
      }
    }
    const a = /* @__PURE__ */ new Map();
    e.eventToProps && Object.keys(e.eventToProps).forEach((n) => {
      var t;
      a.set(n, (t = e.eventToProps) == null ? void 0 : t[n]);
    }), o.connectedCallback = function() {
      d(`[~${r}] connectedCallback called`);
      const n = p == null ? void 0 : p.call(this), t = P(this);
      return t.dataset.nylasId || (Object.defineProperty(t, "registerNylasComponent", {
        get() {
          return !0;
        },
        enumerable: !0
      }), Object.defineProperty(t, "stateToProps", {
        get() {
          return e.stateToProps;
        },
        enumerable: !0
      }), Object.defineProperty(t, "getStoresToProp", {
        get() {
          return e.getStoresToProp;
        },
        enumerable: !0
      }), Object.defineProperty(t, "storeToProps", {
        get() {
          return e.storeToProps;
        },
        enumerable: !0
      }), Object.defineProperty(t, "eventToProps", {
        get() {
          return a;
        },
        enumerable: !0
      }), Object.defineProperty(t, "authToProp", {
        get() {
          return e.authToProp;
        },
        enumerable: !0
      }), Object.defineProperty(t, "connectorToProp", {
        get() {
          return e.connectorToProp;
        },
        enumerable: !0
      }), Object.defineProperty(t, "localPropsToProp", {
        get() {
          return e.localPropsToProp;
        },
        enumerable: !0
      })), n;
    }, e.fireRegisterEvent && (o.componentWillLoad = function() {
      const n = u == null ? void 0 : u.call(this), t = P(this), s = {
        element: t,
        ...e,
        eventToProps: a
      }, i = b(o, s, e.registrationEventName);
      return t.dispatchEvent(i) && d(`[${r}] Component ${r} successfully fired registration event`), n;
    }, o.disconnectedCallback = function() {
      const n = l == null ? void 0 : l.call(this), t = P(this), s = {
        element: t,
        ...e,
        eventToProps: a
      }, i = T(o, s, e.unregistrationEventName);
      return t.dispatchEvent(i) && d(`[${r}] Component ${r} successfully fired unregistration event`), n;
    });
  };
}
export {
  v as R
};
