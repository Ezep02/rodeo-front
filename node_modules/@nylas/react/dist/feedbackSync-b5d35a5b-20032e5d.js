import { p as Fn, l as Pn } from "./index-cd93b584.js";
const Ur = Object.prototype.toString;
function pn(e) {
  switch (Ur.call(e)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return !0;
    default:
      return xe(e, Error);
  }
}
function Xe(e, t) {
  return Ur.call(e) === `[object ${t}]`;
}
function Hr(e) {
  return Xe(e, "ErrorEvent");
}
function An(e) {
  return Xe(e, "DOMError");
}
function Ro(e) {
  return Xe(e, "DOMException");
}
function fe(e) {
  return Xe(e, "String");
}
function hn(e) {
  return typeof e == "object" && e !== null && "__sentry_template_string__" in e && "__sentry_template_values__" in e;
}
function mn(e) {
  return e === null || hn(e) || typeof e != "object" && typeof e != "function";
}
function He(e) {
  return Xe(e, "Object");
}
function Lt(e) {
  return typeof Event < "u" && xe(e, Event);
}
function Lo(e) {
  return typeof Element < "u" && xe(e, Element);
}
function Mo(e) {
  return Xe(e, "RegExp");
}
function Mt(e) {
  return !!(e && e.then && typeof e.then == "function");
}
function Oo(e) {
  return He(e) && "nativeEvent" in e && "preventDefault" in e && "stopPropagation" in e;
}
function xe(e, t) {
  try {
    return e instanceof t;
  } catch {
    return !1;
  }
}
function jr(e) {
  return !!(typeof e == "object" && e !== null && (e.__isVue || e._isVue));
}
function Pe(e, t = 0) {
  return typeof e != "string" || t === 0 || e.length <= t ? e : `${e.slice(0, t)}...`;
}
function Un(e, t) {
  if (!Array.isArray(e))
    return "";
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const o = e[r];
    try {
      jr(o) ? n.push("[VueViewModel]") : n.push(String(o));
    } catch {
      n.push("[value cannot be serialized]");
    }
  }
  return n.join(t);
}
function $o(e, t, n = !1) {
  return fe(e) ? Mo(t) ? t.test(e) : fe(t) ? n ? e === t : e.includes(t) : !1 : !1;
}
function Ot(e, t = [], n = !1) {
  return t.some((r) => $o(e, r, n));
}
function Fo(e, t, n = 250, r, o, i, s) {
  if (!i.exception || !i.exception.values || !s || !xe(s.originalException, Error))
    return;
  const a = i.exception.values.length > 0 ? i.exception.values[i.exception.values.length - 1] : void 0;
  a && (i.exception.values = Po(
    Wt(
      e,
      t,
      o,
      s.originalException,
      r,
      i.exception.values,
      a,
      0
    ),
    n
  ));
}
function Wt(e, t, n, r, o, i, s, a) {
  if (i.length >= n + 1)
    return i;
  let c = [...i];
  if (xe(r[o], Error)) {
    Hn(s, a);
    const l = e(t, r[o]), d = c.length;
    jn(l, o, d, a), c = Wt(
      e,
      t,
      n,
      r[o],
      o,
      [l, ...c],
      l,
      d
    );
  }
  return Array.isArray(r.errors) && r.errors.forEach((l, d) => {
    if (xe(l, Error)) {
      Hn(s, a);
      const u = e(t, l), _ = c.length;
      jn(u, `errors[${d}]`, _, a), c = Wt(
        e,
        t,
        n,
        l,
        o,
        [u, ...c],
        u,
        _
      );
    }
  }), c;
}
function Hn(e, t) {
  e.mechanism = e.mechanism || { type: "generic", handled: !0 }, e.mechanism = {
    ...e.mechanism,
    ...e.type === "AggregateError" && { is_exception_group: !0 },
    exception_id: t
  };
}
function jn(e, t, n, r) {
  e.mechanism = e.mechanism || { type: "generic", handled: !0 }, e.mechanism = {
    ...e.mechanism,
    type: "chained",
    source: t,
    exception_id: n,
    parent_id: r
  };
}
function Po(e, t) {
  return e.map((n) => (n.value && (n.value = Pe(n.value, t)), n));
}
const Se = "8.28.0", w = globalThis;
function gn(e, t, n) {
  const r = n || w, o = r.__SENTRY__ = r.__SENTRY__ || {}, i = o[Se] = o[Se] || {};
  return i[e] || (i[e] = t());
}
const yn = w, Ao = 80;
function Br(e, t = {}) {
  if (!e)
    return "<unknown>";
  try {
    let n = e;
    const r = 5, o = [];
    let i = 0, s = 0;
    const a = " > ", c = a.length;
    let l;
    const d = Array.isArray(t) ? t : t.keyAttrs, u = !Array.isArray(t) && t.maxStringLength || Ao;
    for (; n && i++ < r && (l = Uo(n, d), !(l === "html" || i > 1 && s + o.length * c + l.length >= u)); )
      o.push(l), s += l.length, n = n.parentNode;
    return o.reverse().join(a);
  } catch {
    return "<unknown>";
  }
}
function Uo(e, t) {
  const n = e, r = [];
  if (!n || !n.tagName)
    return "";
  if (yn.HTMLElement && n instanceof HTMLElement && n.dataset) {
    if (n.dataset.sentryComponent)
      return n.dataset.sentryComponent;
    if (n.dataset.sentryElement)
      return n.dataset.sentryElement;
  }
  r.push(n.tagName.toLowerCase());
  const o = t && t.length ? t.filter((s) => n.getAttribute(s)).map((s) => [s, n.getAttribute(s)]) : null;
  if (o && o.length)
    o.forEach((s) => {
      r.push(`[${s[0]}="${s[1]}"]`);
    });
  else {
    n.id && r.push(`#${n.id}`);
    const s = n.className;
    if (s && fe(s)) {
      const a = s.split(/\s+/);
      for (const c of a)
        r.push(`.${c}`);
    }
  }
  const i = ["aria-label", "type", "name", "title", "alt"];
  for (const s of i) {
    const a = n.getAttribute(s);
    a && r.push(`[${s}="${a}"]`);
  }
  return r.join("");
}
function Yr() {
  try {
    return yn.document.location.href;
  } catch {
    return "";
  }
}
function Ho(e) {
  if (!yn.HTMLElement)
    return null;
  let t = e;
  const n = 5;
  for (let r = 0; r < n; r++) {
    if (!t)
      return null;
    if (t instanceof HTMLElement) {
      if (t.dataset.sentryComponent)
        return t.dataset.sentryComponent;
      if (t.dataset.sentryElement)
        return t.dataset.sentryElement;
    }
    t = t.parentNode;
  }
  return null;
}
const ot = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, jo = "Sentry Logger ", zt = [
  "debug",
  "info",
  "warn",
  "error",
  "log",
  "assert",
  "trace"
], Nt = {};
function it(e) {
  if (!("console" in w))
    return e();
  const t = w.console, n = {}, r = Object.keys(Nt);
  r.forEach((o) => {
    const i = Nt[o];
    n[o] = t[o], t[o] = i;
  });
  try {
    return e();
  } finally {
    r.forEach((o) => {
      t[o] = n[o];
    });
  }
}
function Bo() {
  let e = !1;
  const t = {
    enable: () => {
      e = !0;
    },
    disable: () => {
      e = !1;
    },
    isEnabled: () => e
  };
  return ot ? zt.forEach((n) => {
    t[n] = (...r) => {
      e && it(() => {
        w.console[n](`${jo}[${n}]:`, ...r);
      });
    };
  }) : zt.forEach((n) => {
    t[n] = () => {
    };
  }), t;
}
const g = Bo(), Yo = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function Go(e) {
  return e === "http" || e === "https";
}
function $t(e, t = !1) {
  const { host: n, path: r, pass: o, port: i, projectId: s, protocol: a, publicKey: c } = e;
  return `${a}://${c}${t && o ? `:${o}` : ""}@${n}${i ? `:${i}` : ""}/${r && `${r}/`}${s}`;
}
function qo(e) {
  const t = Yo.exec(e);
  if (!t) {
    it(() => {
      console.error(`Invalid Sentry Dsn: ${e}`);
    });
    return;
  }
  const [n, r, o = "", i = "", s = "", a = ""] = t.slice(1);
  let c = "", l = a;
  const d = l.split("/");
  if (d.length > 1 && (c = d.slice(0, -1).join("/"), l = d.pop()), l) {
    const u = l.match(/^\d+/);
    u && (l = u[0]);
  }
  return Gr({ host: i, pass: o, path: c, projectId: l, port: s, protocol: n, publicKey: r });
}
function Gr(e) {
  return {
    protocol: e.protocol,
    publicKey: e.publicKey || "",
    pass: e.pass || "",
    host: e.host,
    port: e.port || "",
    path: e.path || "",
    projectId: e.projectId
  };
}
function Xo(e) {
  if (!ot)
    return !0;
  const { port: t, projectId: n, protocol: r } = e;
  return ["protocol", "publicKey", "host", "projectId"].find((s) => e[s] ? !1 : (g.error(`Invalid Sentry Dsn: ${s} missing`), !0)) ? !1 : n.match(/^\d+$/) ? Go(r) ? t && isNaN(parseInt(t, 10)) ? (g.error(`Invalid Sentry Dsn: Invalid port ${t}`), !1) : !0 : (g.error(`Invalid Sentry Dsn: Invalid protocol ${r}`), !1) : (g.error(`Invalid Sentry Dsn: Invalid projectId ${n}`), !1);
}
function Wo(e) {
  const t = typeof e == "string" ? qo(e) : Gr(e);
  if (!(!t || !Xo(t)))
    return t;
}
class ae extends Error {
  /** Display name of this error instance. */
  constructor(t, n = "warn") {
    super(t), this.message = t, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = n;
  }
}
function W(e, t, n) {
  if (!(t in e))
    return;
  const r = e[t], o = n(r);
  typeof o == "function" && qr(o, r), e[t] = o;
}
function Ce(e, t, n) {
  try {
    Object.defineProperty(e, t, {
      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
      value: n,
      writable: !0,
      configurable: !0
    });
  } catch {
    ot && g.log(`Failed to add non-enumerable property "${t}" to object`, e);
  }
}
function qr(e, t) {
  try {
    const n = t.prototype || {};
    e.prototype = t.prototype = n, Ce(e, "__sentry_original__", t);
  } catch {
  }
}
function bn(e) {
  return e.__sentry_original__;
}
function zo(e) {
  return Object.keys(e).map((t) => `${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`).join("&");
}
function Xr(e) {
  if (pn(e))
    return {
      message: e.message,
      name: e.name,
      stack: e.stack,
      ...Yn(e)
    };
  if (Lt(e)) {
    const t = {
      type: e.type,
      target: Bn(e.target),
      currentTarget: Bn(e.currentTarget),
      ...Yn(e)
    };
    return typeof CustomEvent < "u" && xe(e, CustomEvent) && (t.detail = e.detail), t;
  } else
    return e;
}
function Bn(e) {
  try {
    return Lo(e) ? Br(e) : Object.prototype.toString.call(e);
  } catch {
    return "<unknown>";
  }
}
function Yn(e) {
  if (typeof e == "object" && e !== null) {
    const t = {};
    for (const n in e)
      Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
    return t;
  } else
    return {};
}
function Vo(e, t = 40) {
  const n = Object.keys(Xr(e));
  n.sort();
  const r = n[0];
  if (!r)
    return "[object has no keys]";
  if (r.length >= t)
    return Pe(r, t);
  for (let o = n.length; o > 0; o--) {
    const i = n.slice(0, o).join(", ");
    if (!(i.length > t))
      return o === n.length ? i : Pe(i, t);
  }
  return "";
}
function z(e) {
  return Vt(e, /* @__PURE__ */ new Map());
}
function Vt(e, t) {
  if (Ko(e)) {
    const n = t.get(e);
    if (n !== void 0)
      return n;
    const r = {};
    t.set(e, r);
    for (const o of Object.keys(e))
      typeof e[o] < "u" && (r[o] = Vt(e[o], t));
    return r;
  }
  if (Array.isArray(e)) {
    const n = t.get(e);
    if (n !== void 0)
      return n;
    const r = [];
    return t.set(e, r), e.forEach((o) => {
      r.push(Vt(o, t));
    }), r;
  }
  return e;
}
function Ko(e) {
  if (!He(e))
    return !1;
  try {
    const t = Object.getPrototypeOf(e).constructor.name;
    return !t || t === "Object";
  } catch {
    return !0;
  }
}
const Wr = 50, Ne = "?", Gn = /\(error: (.*)\)/, qn = /captureMessage|captureException/;
function zr(...e) {
  const t = e.sort((n, r) => n[0] - r[0]).map((n) => n[1]);
  return (n, r = 0, o = 0) => {
    const i = [], s = n.split(`
`);
    for (let a = r; a < s.length; a++) {
      const c = s[a];
      if (c.length > 1024)
        continue;
      const l = Gn.test(c) ? c.replace(Gn, "$1") : c;
      if (!l.match(/\S*Error: /)) {
        for (const d of t) {
          const u = d(l);
          if (u) {
            i.push(u);
            break;
          }
        }
        if (i.length >= Wr + o)
          break;
      }
    }
    return Zo(i.slice(o));
  };
}
function Jo(e) {
  return Array.isArray(e) ? zr(...e) : e;
}
function Zo(e) {
  if (!e.length)
    return [];
  const t = Array.from(e);
  return /sentryWrapped/.test(dt(t).function || "") && t.pop(), t.reverse(), qn.test(dt(t).function || "") && (t.pop(), qn.test(dt(t).function || "") && t.pop()), t.slice(0, Wr).map((n) => ({
    ...n,
    filename: n.filename || dt(t).filename,
    function: n.function || Ne
  }));
}
function dt(e) {
  return e[e.length - 1] || {};
}
const Ht = "<anonymous>";
function ve(e) {
  try {
    return !e || typeof e != "function" ? Ht : e.name || Ht;
  } catch {
    return Ht;
  }
}
function Xn(e) {
  const t = e.exception;
  if (t) {
    const n = [];
    try {
      return t.values.forEach((r) => {
        r.stacktrace.frames && n.push(...r.stacktrace.frames);
      }), n;
    } catch {
      return;
    }
  }
}
const Et = {}, Wn = {};
function De(e, t) {
  Et[e] = Et[e] || [], Et[e].push(t);
}
function Re(e, t) {
  Wn[e] || (t(), Wn[e] = !0);
}
function oe(e, t) {
  const n = e && Et[e];
  if (n)
    for (const r of n)
      try {
        r(t);
      } catch (o) {
        ot && g.error(
          `Error while triggering instrumentation handler.
Type: ${e}
Name: ${ve(r)}
Error:`,
          o
        );
      }
}
function Qo(e) {
  const t = "console";
  De(t, e), Re(t, ei);
}
function ei() {
  "console" in w && zt.forEach(function(e) {
    e in w.console && W(w.console, e, function(t) {
      return Nt[e] = t, function(...n) {
        oe("console", { args: n, level: e });
        const o = Nt[e];
        o && o.apply(w.console, n);
      };
    });
  });
}
const Kt = w;
function Vr() {
  if (!("fetch" in Kt))
    return !1;
  try {
    return new Headers(), new Request("http://www.example.com"), new Response(), !0;
  } catch {
    return !1;
  }
}
function Jt(e) {
  return e && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(e.toString());
}
function ti() {
  if (typeof EdgeRuntime == "string")
    return !0;
  if (!Vr())
    return !1;
  if (Jt(Kt.fetch))
    return !0;
  let e = !1;
  const t = Kt.document;
  if (t && typeof t.createElement == "function")
    try {
      const n = t.createElement("iframe");
      n.hidden = !0, t.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (e = Jt(n.contentWindow.fetch)), t.head.removeChild(n);
    } catch (n) {
      ot && g.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n);
    }
  return e;
}
const Kr = 1e3;
function st() {
  return Date.now() / Kr;
}
function ni() {
  const { performance: e } = w;
  if (!e || !e.now)
    return st;
  const t = Date.now() - e.now(), n = e.timeOrigin == null ? t : e.timeOrigin;
  return () => (n + e.now()) / Kr;
}
const _e = ni();
(() => {
  const { performance: e } = w;
  if (!e || !e.now)
    return;
  const t = 3600 * 1e3, n = e.now(), r = Date.now(), o = e.timeOrigin ? Math.abs(e.timeOrigin + n - r) : t, i = o < t, s = e.timing && e.timing.navigationStart, c = typeof s == "number" ? Math.abs(s + n - r) : t, l = c < t;
  return i || l ? o <= c ? e.timeOrigin : s : r;
})();
function ri(e, t) {
  const n = "fetch";
  De(n, e), Re(n, () => oi(void 0, t));
}
function oi(e, t = !1) {
  t && !ti() || W(w, "fetch", function(n) {
    return function(...r) {
      const { method: o, url: i } = ii(r), s = {
        args: r,
        fetchData: {
          method: o,
          url: i
        },
        startTimestamp: _e() * 1e3
      };
      e || oe("fetch", {
        ...s
      });
      const a = new Error().stack;
      return n.apply(w, r).then(
        async (c) => (e ? e(c) : oe("fetch", {
          ...s,
          endTimestamp: _e() * 1e3,
          response: c
        }), c),
        (c) => {
          throw oe("fetch", {
            ...s,
            endTimestamp: _e() * 1e3,
            error: c
          }), pn(c) && c.stack === void 0 && (c.stack = a, Ce(c, "framesToPop", 1)), c;
        }
      );
    };
  });
}
function Zt(e, t) {
  return !!e && typeof e == "object" && !!e[t];
}
function zn(e) {
  return typeof e == "string" ? e : e ? Zt(e, "url") ? e.url : e.toString ? e.toString() : "" : "";
}
function ii(e) {
  if (e.length === 0)
    return { method: "GET", url: "" };
  if (e.length === 2) {
    const [n, r] = e;
    return {
      url: zn(n),
      method: Zt(r, "method") ? String(r.method).toUpperCase() : "GET"
    };
  }
  const t = e[0];
  return {
    url: zn(t),
    method: Zt(t, "method") ? String(t.method).toUpperCase() : "GET"
  };
}
let ft = null;
function si(e) {
  const t = "error";
  De(t, e), Re(t, ai);
}
function ai() {
  ft = w.onerror, w.onerror = function(e, t, n, r, o) {
    return oe("error", {
      column: r,
      error: o,
      line: n,
      msg: e,
      url: t
    }), ft && !ft.__SENTRY_LOADER__ ? ft.apply(this, arguments) : !1;
  }, w.onerror.__SENTRY_INSTRUMENTED__ = !0;
}
let _t = null;
function ci(e) {
  const t = "unhandledrejection";
  De(t, e), Re(t, ui);
}
function ui() {
  _t = w.onunhandledrejection, w.onunhandledrejection = function(e) {
    return oe("unhandledrejection", e), _t && !_t.__SENTRY_LOADER__ ? _t.apply(this, arguments) : !0;
  }, w.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0;
}
function li() {
  return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__;
}
function di() {
  return "npm";
}
function fi() {
  return !li() && Object.prototype.toString.call(typeof Fn < "u" ? Fn : 0) === "[object process]";
}
function _i() {
  return typeof window < "u" && (!fi() || pi());
}
function pi() {
  return (
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
    w.process !== void 0 && w.process.type === "renderer"
  );
}
function hi() {
  const e = typeof WeakSet == "function", t = e ? /* @__PURE__ */ new WeakSet() : [];
  function n(o) {
    if (e)
      return t.has(o) ? !0 : (t.add(o), !1);
    for (let i = 0; i < t.length; i++)
      if (t[i] === o)
        return !0;
    return t.push(o), !1;
  }
  function r(o) {
    if (e)
      t.delete(o);
    else
      for (let i = 0; i < t.length; i++)
        if (t[i] === o) {
          t.splice(i, 1);
          break;
        }
  }
  return [n, r];
}
function ee() {
  const e = w, t = e.crypto || e.msCrypto;
  let n = () => Math.random() * 16;
  try {
    if (t && t.randomUUID)
      return t.randomUUID().replace(/-/g, "");
    t && t.getRandomValues && (n = () => {
      const r = new Uint8Array(1);
      return t.getRandomValues(r), r[0];
    });
  } catch {
  }
  return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(
    /[018]/g,
    (r) => (
      // eslint-disable-next-line no-bitwise
      (r ^ (n() & 15) >> r / 4).toString(16)
    )
  );
}
function Jr(e) {
  return e.exception && e.exception.values ? e.exception.values[0] : void 0;
}
function ye(e) {
  const { message: t, event_id: n } = e;
  if (t)
    return t;
  const r = Jr(e);
  return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>";
}
function Qt(e, t, n) {
  const r = e.exception = e.exception || {}, o = r.values = r.values || [], i = o[0] = o[0] || {};
  i.value || (i.value = t || ""), i.type || (i.type = n || "Error");
}
function nt(e, t) {
  const n = Jr(e);
  if (!n)
    return;
  const r = { type: "generic", handled: !0 }, o = n.mechanism;
  if (n.mechanism = { ...r, ...o, ...t }, t && "data" in t) {
    const i = { ...o && o.data, ...t.data };
    n.mechanism.data = i;
  }
}
function Vn(e) {
  if (e && e.__sentry_captured__)
    return !0;
  try {
    Ce(e, "__sentry_captured__", !0);
  } catch {
  }
  return !1;
}
function Zr(e) {
  return Array.isArray(e) ? e : [e];
}
function be(e, t = 100, n = 1 / 0) {
  try {
    return en("", e, t, n);
  } catch (r) {
    return { ERROR: `**non-serializable** (${r})` };
  }
}
function Qr(e, t = 3, n = 100 * 1024) {
  const r = be(e, t);
  return bi(r) > n ? Qr(e, t - 1, n) : r;
}
function en(e, t, n = 1 / 0, r = 1 / 0, o = hi()) {
  const [i, s] = o;
  if (t == null || // this matches null and undefined -> eqeq not eqeqeq
  ["number", "boolean", "string"].includes(typeof t) && !Number.isNaN(t))
    return t;
  const a = mi(e, t);
  if (!a.startsWith("[object "))
    return a;
  if (t.__sentry_skip_normalization__)
    return t;
  const c = typeof t.__sentry_override_normalization_depth__ == "number" ? t.__sentry_override_normalization_depth__ : n;
  if (c === 0)
    return a.replace("object ", "");
  if (i(t))
    return "[Circular ~]";
  const l = t;
  if (l && typeof l.toJSON == "function")
    try {
      const f = l.toJSON();
      return en("", f, c - 1, r, o);
    } catch {
    }
  const d = Array.isArray(t) ? [] : {};
  let u = 0;
  const _ = Xr(t);
  for (const f in _) {
    if (!Object.prototype.hasOwnProperty.call(_, f))
      continue;
    if (u >= r) {
      d[f] = "[MaxProperties ~]";
      break;
    }
    const p = _[f];
    d[f] = en(f, p, c - 1, r, o), u++;
  }
  return s(t), d;
}
function mi(e, t) {
  try {
    if (e === "domain" && t && typeof t == "object" && t._events)
      return "[Domain]";
    if (e === "domainEmitter")
      return "[DomainEmitter]";
    if (typeof Pn < "u" && t === Pn)
      return "[Global]";
    if (typeof window < "u" && t === window)
      return "[Window]";
    if (typeof document < "u" && t === document)
      return "[Document]";
    if (jr(t))
      return "[VueViewModel]";
    if (Oo(t))
      return "[SyntheticEvent]";
    if (typeof t == "number" && t !== t)
      return "[NaN]";
    if (typeof t == "function")
      return `[Function: ${ve(t)}]`;
    if (typeof t == "symbol")
      return `[${String(t)}]`;
    if (typeof t == "bigint")
      return `[BigInt: ${String(t)}]`;
    const n = gi(t);
    return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`;
  } catch (n) {
    return `**non-serializable** (${n})`;
  }
}
function gi(e) {
  const t = Object.getPrototypeOf(e);
  return t ? t.constructor.name : "null prototype";
}
function yi(e) {
  return ~-encodeURI(e).split(/%..|./).length;
}
function bi(e) {
  return yi(JSON.stringify(e));
}
var de;
(function(e) {
  e[e.PENDING = 0] = "PENDING";
  const n = 1;
  e[e.RESOLVED = n] = "RESOLVED";
  const r = 2;
  e[e.REJECTED = r] = "REJECTED";
})(de || (de = {}));
function Ie(e) {
  return new Q((t) => {
    t(e);
  });
}
function It(e) {
  return new Q((t, n) => {
    n(e);
  });
}
class Q {
  constructor(t) {
    Q.prototype.__init.call(this), Q.prototype.__init2.call(this), Q.prototype.__init3.call(this), Q.prototype.__init4.call(this), this._state = de.PENDING, this._handlers = [];
    try {
      t(this._resolve, this._reject);
    } catch (n) {
      this._reject(n);
    }
  }
  /** JSDoc */
  then(t, n) {
    return new Q((r, o) => {
      this._handlers.push([
        !1,
        (i) => {
          if (!t)
            r(i);
          else
            try {
              r(t(i));
            } catch (s) {
              o(s);
            }
        },
        (i) => {
          if (!n)
            o(i);
          else
            try {
              r(n(i));
            } catch (s) {
              o(s);
            }
        }
      ]), this._executeHandlers();
    });
  }
  /** JSDoc */
  catch(t) {
    return this.then((n) => n, t);
  }
  /** JSDoc */
  finally(t) {
    return new Q((n, r) => {
      let o, i;
      return this.then(
        (s) => {
          i = !1, o = s, t && t();
        },
        (s) => {
          i = !0, o = s, t && t();
        }
      ).then(() => {
        if (i) {
          r(o);
          return;
        }
        n(o);
      });
    });
  }
  /** JSDoc */
  __init() {
    this._resolve = (t) => {
      this._setResult(de.RESOLVED, t);
    };
  }
  /** JSDoc */
  __init2() {
    this._reject = (t) => {
      this._setResult(de.REJECTED, t);
    };
  }
  /** JSDoc */
  __init3() {
    this._setResult = (t, n) => {
      if (this._state === de.PENDING) {
        if (Mt(n)) {
          n.then(this._resolve, this._reject);
          return;
        }
        this._state = t, this._value = n, this._executeHandlers();
      }
    };
  }
  /** JSDoc */
  __init4() {
    this._executeHandlers = () => {
      if (this._state === de.PENDING)
        return;
      const t = this._handlers.slice();
      this._handlers = [], t.forEach((n) => {
        n[0] || (this._state === de.RESOLVED && n[1](this._value), this._state === de.REJECTED && n[2](this._value), n[0] = !0);
      });
    };
  }
}
function Ei(e) {
  const t = [];
  function n() {
    return e === void 0 || t.length < e;
  }
  function r(s) {
    return t.splice(t.indexOf(s), 1)[0] || Promise.resolve(void 0);
  }
  function o(s) {
    if (!n())
      return It(new ae("Not adding Promise because buffer limit was reached."));
    const a = s();
    return t.indexOf(a) === -1 && t.push(a), a.then(() => r(a)).then(
      null,
      () => r(a).then(null, () => {
      })
    ), a;
  }
  function i(s) {
    return new Q((a, c) => {
      let l = t.length;
      if (!l)
        return a(!0);
      const d = setTimeout(() => {
        s && s > 0 && a(!1);
      }, s);
      t.forEach((u) => {
        Ie(u).then(() => {
          --l || (clearTimeout(d), a(!0));
        }, c);
      });
    });
  }
  return {
    $: t,
    add: o,
    drain: i
  };
}
function jt(e) {
  if (!e)
    return {};
  const t = e.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!t)
    return {};
  const n = t[6] || "", r = t[8] || "";
  return {
    host: t[4],
    path: t[5],
    protocol: t[2],
    search: n,
    hash: r,
    relative: t[5] + n + r
    // everything minus origin
  };
}
const Si = ["fatal", "error", "warning", "log", "info", "debug"];
function vi(e) {
  return e === "warn" ? "warning" : Si.includes(e) ? e : "log";
}
const wi = "sentry-", ki = /^sentry-/;
function xi(e) {
  const t = Ci(e);
  if (!t)
    return;
  const n = Object.entries(t).reduce((r, [o, i]) => {
    if (o.match(ki)) {
      const s = o.slice(wi.length);
      r[s] = i;
    }
    return r;
  }, {});
  if (Object.keys(n).length > 0)
    return n;
}
function Ci(e) {
  if (!(!e || !fe(e) && !Array.isArray(e)))
    return Array.isArray(e) ? e.reduce((t, n) => {
      const r = Kn(n);
      return Object.entries(r).forEach(([o, i]) => {
        t[o] = i;
      }), t;
    }, {}) : Kn(e);
}
function Kn(e) {
  return e.split(",").map((t) => t.split("=").map((n) => decodeURIComponent(n.trim()))).reduce((t, [n, r]) => (n && r && (t[n] = r), t), {});
}
function at(e, t = []) {
  return [e, t];
}
function Ni(e, t) {
  const [n, r] = e;
  return [n, [...r, t]];
}
function Jn(e, t) {
  const n = e[1];
  for (const r of n) {
    const o = r[0].type;
    if (t(r, o))
      return !0;
  }
  return !1;
}
function tn(e) {
  return w.__SENTRY__ && w.__SENTRY__.encodePolyfill ? w.__SENTRY__.encodePolyfill(e) : new TextEncoder().encode(e);
}
function Ii(e) {
  const [t, n] = e;
  let r = JSON.stringify(t);
  function o(i) {
    typeof r == "string" ? r = typeof i == "string" ? r + i : [tn(r), i] : r.push(typeof i == "string" ? tn(i) : i);
  }
  for (const i of n) {
    const [s, a] = i;
    if (o(`
${JSON.stringify(s)}
`), typeof a == "string" || a instanceof Uint8Array)
      o(a);
    else {
      let c;
      try {
        c = JSON.stringify(a);
      } catch {
        c = JSON.stringify(be(a));
      }
      o(c);
    }
  }
  return typeof r == "string" ? r : Ti(r);
}
function Ti(e) {
  const t = e.reduce((o, i) => o + i.length, 0), n = new Uint8Array(t);
  let r = 0;
  for (const o of e)
    n.set(o, r), r += o.length;
  return n;
}
function Di(e) {
  const t = typeof e.data == "string" ? tn(e.data) : e.data;
  return [
    z({
      type: "attachment",
      length: t.length,
      filename: e.filename,
      content_type: e.contentType,
      attachment_type: e.attachmentType
    }),
    t
  ];
}
const Ri = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  profile_chunk: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  statsd: "metric_bucket"
};
function Zn(e) {
  return Ri[e];
}
function eo(e) {
  if (!e || !e.sdk)
    return;
  const { name: t, version: n } = e.sdk;
  return { name: t, version: n };
}
function Li(e, t, n, r) {
  const o = e.sdkProcessingMetadata && e.sdkProcessingMetadata.dynamicSamplingContext;
  return {
    event_id: e.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...t && { sdk: t },
    ...!!n && r && { dsn: $t(r) },
    ...o && {
      trace: z({ ...o })
    }
  };
}
function Mi(e, t, n) {
  const r = [
    { type: "client_report" },
    {
      timestamp: n || st(),
      discarded_events: e
    }
  ];
  return at(t ? { dsn: t } : {}, [r]);
}
const Oi = 60 * 1e3;
function $i(e, t = Date.now()) {
  const n = parseInt(`${e}`, 10);
  if (!isNaN(n))
    return n * 1e3;
  const r = Date.parse(`${e}`);
  return isNaN(r) ? Oi : r - t;
}
function Fi(e, t) {
  return e[t] || e.all || 0;
}
function Pi(e, t, n = Date.now()) {
  return Fi(e, t) > n;
}
function Ai(e, { statusCode: t, headers: n }, r = Date.now()) {
  const o = {
    ...e
  }, i = n && n["x-sentry-rate-limits"], s = n && n["retry-after"];
  if (i)
    for (const a of i.trim().split(",")) {
      const [c, l, , , d] = a.split(":", 5), u = parseInt(c, 10), _ = (isNaN(u) ? 60 : u) * 1e3;
      if (!l)
        o.all = r + _;
      else
        for (const f of l.split(";"))
          f === "metric_bucket" ? (!d || d.split(";").includes("custom")) && (o[f] = r + _) : o[f] = r + _;
    }
  else
    s ? o.all = r + $i(s, r) : t === 429 && (o.all = r + 60 * 1e3);
  return o;
}
function Qn() {
  return {
    traceId: ee(),
    spanId: ee().substring(16)
  };
}
const pt = w;
function Ui() {
  const e = pt.chrome, t = e && e.app && e.app.runtime, n = "history" in pt && !!pt.history.pushState && !!pt.history.replaceState;
  return !t && n;
}
const N = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function Ft() {
  return En(w), w;
}
function En(e) {
  const t = e.__SENTRY__ = e.__SENTRY__ || {};
  return t.version = t.version || Se, t[Se] = t[Se] || {};
}
function Hi(e) {
  const t = _e(), n = {
    sid: ee(),
    init: !0,
    timestamp: t,
    started: t,
    duration: 0,
    status: "ok",
    errors: 0,
    ignoreDuration: !1,
    toJSON: () => Bi(n)
  };
  return e && je(n, e), n;
}
function je(e, t = {}) {
  if (t.user && (!e.ipAddress && t.user.ip_address && (e.ipAddress = t.user.ip_address), !e.did && !t.did && (e.did = t.user.id || t.user.email || t.user.username)), e.timestamp = t.timestamp || _e(), t.abnormal_mechanism && (e.abnormal_mechanism = t.abnormal_mechanism), t.ignoreDuration && (e.ignoreDuration = t.ignoreDuration), t.sid && (e.sid = t.sid.length === 32 ? t.sid : ee()), t.init !== void 0 && (e.init = t.init), !e.did && t.did && (e.did = `${t.did}`), typeof t.started == "number" && (e.started = t.started), e.ignoreDuration)
    e.duration = void 0;
  else if (typeof t.duration == "number")
    e.duration = t.duration;
  else {
    const n = e.timestamp - e.started;
    e.duration = n >= 0 ? n : 0;
  }
  t.release && (e.release = t.release), t.environment && (e.environment = t.environment), !e.ipAddress && t.ipAddress && (e.ipAddress = t.ipAddress), !e.userAgent && t.userAgent && (e.userAgent = t.userAgent), typeof t.errors == "number" && (e.errors = t.errors), t.status && (e.status = t.status);
}
function ji(e, t) {
  let n = {};
  t ? n = { status: t } : e.status === "ok" && (n = { status: "exited" }), je(e, n);
}
function Bi(e) {
  return z({
    sid: `${e.sid}`,
    init: e.init,
    // Make sure that sec is converted to ms for date constructor
    started: new Date(e.started * 1e3).toISOString(),
    timestamp: new Date(e.timestamp * 1e3).toISOString(),
    status: e.status,
    errors: e.errors,
    did: typeof e.did == "number" || typeof e.did == "string" ? `${e.did}` : void 0,
    duration: e.duration,
    abnormal_mechanism: e.abnormal_mechanism,
    attrs: {
      release: e.release,
      environment: e.environment,
      ip_address: e.ipAddress,
      user_agent: e.userAgent
    }
  });
}
const nn = "_sentrySpan";
function er(e, t) {
  t ? Ce(e, nn, t) : delete e[nn];
}
function tr(e) {
  return e[nn];
}
const Yi = 100;
class Sn {
  /** Flag if notifying is happening. */
  /** Callback for client to receive scope changes. */
  /** Callback list that will be called during event processing. */
  /** Array of breadcrumbs. */
  /** User */
  /** Tags */
  /** Extra */
  /** Contexts */
  /** Attachments */
  /** Propagation Context for distributed tracing */
  /**
   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
   * sent to Sentry
   */
  /** Fingerprint */
  /** Severity */
  /**
   * Transaction Name
   *
   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.
   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.
   */
  /** Session */
  /** Request Mode Session Status */
  /** The client on this scope */
  /** Contains the last event id of a captured event.  */
  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
  constructor() {
    this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = Qn();
  }
  /**
   * @inheritDoc
   */
  clone() {
    const t = new Sn();
    return t._breadcrumbs = [...this._breadcrumbs], t._tags = { ...this._tags }, t._extra = { ...this._extra }, t._contexts = { ...this._contexts }, t._user = this._user, t._level = this._level, t._session = this._session, t._transactionName = this._transactionName, t._fingerprint = this._fingerprint, t._eventProcessors = [...this._eventProcessors], t._requestSession = this._requestSession, t._attachments = [...this._attachments], t._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, t._propagationContext = { ...this._propagationContext }, t._client = this._client, t._lastEventId = this._lastEventId, er(t, tr(this)), t;
  }
  /**
   * @inheritDoc
   */
  setClient(t) {
    this._client = t;
  }
  /**
   * @inheritDoc
   */
  setLastEventId(t) {
    this._lastEventId = t;
  }
  /**
   * @inheritDoc
   */
  getClient() {
    return this._client;
  }
  /**
   * @inheritDoc
   */
  lastEventId() {
    return this._lastEventId;
  }
  /**
   * @inheritDoc
   */
  addScopeListener(t) {
    this._scopeListeners.push(t);
  }
  /**
   * @inheritDoc
   */
  addEventProcessor(t) {
    return this._eventProcessors.push(t), this;
  }
  /**
   * @inheritDoc
   */
  setUser(t) {
    return this._user = t || {
      email: void 0,
      id: void 0,
      ip_address: void 0,
      username: void 0
    }, this._session && je(this._session, { user: t }), this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getUser() {
    return this._user;
  }
  /**
   * @inheritDoc
   */
  getRequestSession() {
    return this._requestSession;
  }
  /**
   * @inheritDoc
   */
  setRequestSession(t) {
    return this._requestSession = t, this;
  }
  /**
   * @inheritDoc
   */
  setTags(t) {
    return this._tags = {
      ...this._tags,
      ...t
    }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setTag(t, n) {
    return this._tags = { ...this._tags, [t]: n }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setExtras(t) {
    return this._extra = {
      ...this._extra,
      ...t
    }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setExtra(t, n) {
    return this._extra = { ...this._extra, [t]: n }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setFingerprint(t) {
    return this._fingerprint = t, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setLevel(t) {
    return this._level = t, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setTransactionName(t) {
    return this._transactionName = t, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setContext(t, n) {
    return n === null ? delete this._contexts[t] : this._contexts[t] = n, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setSession(t) {
    return t ? this._session = t : delete this._session, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getSession() {
    return this._session;
  }
  /**
   * @inheritDoc
   */
  update(t) {
    if (!t)
      return this;
    const n = typeof t == "function" ? t(this) : t, [r, o] = n instanceof we ? [n.getScopeData(), n.getRequestSession()] : He(n) ? [t, t.requestSession] : [], { tags: i, extra: s, user: a, contexts: c, level: l, fingerprint: d = [], propagationContext: u } = r || {};
    return this._tags = { ...this._tags, ...i }, this._extra = { ...this._extra, ...s }, this._contexts = { ...this._contexts, ...c }, a && Object.keys(a).length && (this._user = a), l && (this._level = l), d.length && (this._fingerprint = d), u && (this._propagationContext = u), o && (this._requestSession = o), this;
  }
  /**
   * @inheritDoc
   */
  clear() {
    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, er(this, void 0), this._attachments = [], this._propagationContext = Qn(), this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  addBreadcrumb(t, n) {
    const r = typeof n == "number" ? n : Yi;
    if (r <= 0)
      return this;
    const o = {
      timestamp: st(),
      ...t
    }, i = this._breadcrumbs;
    return i.push(o), this._breadcrumbs = i.length > r ? i.slice(-r) : i, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  /**
   * @inheritDoc
   */
  clearBreadcrumbs() {
    return this._breadcrumbs = [], this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  addAttachment(t) {
    return this._attachments.push(t), this;
  }
  /**
   * @inheritDoc
   */
  clearAttachments() {
    return this._attachments = [], this;
  }
  /** @inheritDoc */
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: tr(this)
    };
  }
  /**
   * @inheritDoc
   */
  setSDKProcessingMetadata(t) {
    return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...t }, this;
  }
  /**
   * @inheritDoc
   */
  setPropagationContext(t) {
    return this._propagationContext = t, this;
  }
  /**
   * @inheritDoc
   */
  getPropagationContext() {
    return this._propagationContext;
  }
  /**
   * @inheritDoc
   */
  captureException(t, n) {
    const r = n && n.event_id ? n.event_id : ee();
    if (!this._client)
      return g.warn("No client configured on scope - will not capture exception!"), r;
    const o = new Error("Sentry syntheticException");
    return this._client.captureException(
      t,
      {
        originalException: t,
        syntheticException: o,
        ...n,
        event_id: r
      },
      this
    ), r;
  }
  /**
   * @inheritDoc
   */
  captureMessage(t, n, r) {
    const o = r && r.event_id ? r.event_id : ee();
    if (!this._client)
      return g.warn("No client configured on scope - will not capture message!"), o;
    const i = new Error(t);
    return this._client.captureMessage(
      t,
      n,
      {
        originalException: t,
        syntheticException: i,
        ...r,
        event_id: o
      },
      this
    ), o;
  }
  /**
   * @inheritDoc
   */
  captureEvent(t, n) {
    const r = n && n.event_id ? n.event_id : ee();
    return this._client ? (this._client.captureEvent(t, { ...n, event_id: r }, this), r) : (g.warn("No client configured on scope - will not capture event!"), r);
  }
  /**
   * This will be called on every set call.
   */
  _notifyScopeListeners() {
    this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((t) => {
      t(this);
    }), this._notifyingListeners = !1);
  }
}
const we = Sn;
function Gi() {
  return gn("defaultCurrentScope", () => new we());
}
function qi() {
  return gn("defaultIsolationScope", () => new we());
}
class Xi {
  constructor(t, n) {
    let r;
    t ? r = t : r = new we();
    let o;
    n ? o = n : o = new we(), this._stack = [{ scope: r }], this._isolationScope = o;
  }
  /**
   * Fork a scope for the stack.
   */
  withScope(t) {
    const n = this._pushScope();
    let r;
    try {
      r = t(n);
    } catch (o) {
      throw this._popScope(), o;
    }
    return Mt(r) ? r.then(
      (o) => (this._popScope(), o),
      (o) => {
        throw this._popScope(), o;
      }
    ) : (this._popScope(), r);
  }
  /**
   * Get the client of the stack.
   */
  getClient() {
    return this.getStackTop().client;
  }
  /**
   * Returns the scope of the top stack.
   */
  getScope() {
    return this.getStackTop().scope;
  }
  /**
   * Get the isolation scope for the stack.
   */
  getIsolationScope() {
    return this._isolationScope;
  }
  /**
   * Returns the topmost scope layer in the order domain > local > process.
   */
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  /**
   * Push a scope to the stack.
   */
  _pushScope() {
    const t = this.getScope().clone();
    return this._stack.push({
      client: this.getClient(),
      scope: t
    }), t;
  }
  /**
   * Pop a scope from the stack.
   */
  _popScope() {
    return this._stack.length <= 1 ? !1 : !!this._stack.pop();
  }
}
function Be() {
  const e = Ft(), t = En(e);
  return t.stack = t.stack || new Xi(Gi(), qi());
}
function Wi(e) {
  return Be().withScope(e);
}
function zi(e, t) {
  const n = Be();
  return n.withScope(() => (n.getStackTop().scope = e, t(e)));
}
function nr(e) {
  return Be().withScope(() => e(Be().getIsolationScope()));
}
function Vi() {
  return {
    withIsolationScope: nr,
    withScope: Wi,
    withSetScope: zi,
    withSetIsolationScope: (e, t) => nr(t),
    getCurrentScope: () => Be().getScope(),
    getIsolationScope: () => Be().getIsolationScope()
  };
}
function vn(e) {
  const t = En(e);
  return t.acs ? t.acs : Vi();
}
function te() {
  const e = Ft();
  return vn(e).getCurrentScope();
}
function We() {
  const e = Ft();
  return vn(e).getIsolationScope();
}
function to() {
  return gn("globalScope", () => new we());
}
function Ki(...e) {
  const t = Ft(), n = vn(t);
  if (e.length === 2) {
    const [r, o] = e;
    return r ? n.withSetScope(r, o) : n.withScope(o);
  }
  return n.withScope(e[0]);
}
function F() {
  return te().getClient();
}
const Ji = "_sentryMetrics";
function Zi(e) {
  const t = e[Ji];
  if (!t)
    return;
  const n = {};
  for (const [, [r, o]] of t)
    (n[r] || (n[r] = [])).push(z(o));
  return n;
}
const Qi = "sentry.source", es = "sentry.sample_rate", ts = "sentry.op", ns = "sentry.origin", rs = 0, os = 1, is = 1;
function ss(e) {
  const { spanId: t, traceId: n } = e.spanContext(), { parent_span_id: r } = Tt(e);
  return z({ parent_span_id: r, span_id: t, trace_id: n });
}
function rr(e) {
  return typeof e == "number" ? or(e) : Array.isArray(e) ? e[0] + e[1] / 1e9 : e instanceof Date ? or(e.getTime()) : _e();
}
function or(e) {
  return e > 9999999999 ? e / 1e3 : e;
}
function Tt(e) {
  if (cs(e))
    return e.getSpanJSON();
  try {
    const { spanId: t, traceId: n } = e.spanContext();
    if (as(e)) {
      const { attributes: r, startTime: o, name: i, endTime: s, parentSpanId: a, status: c } = e;
      return z({
        span_id: t,
        trace_id: n,
        data: r,
        description: i,
        parent_span_id: a,
        start_timestamp: rr(o),
        // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time
        timestamp: rr(s) || void 0,
        status: ls(c),
        op: r[ts],
        origin: r[ns],
        _metrics_summary: Zi(e)
      });
    }
    return {
      span_id: t,
      trace_id: n
    };
  } catch {
    return {};
  }
}
function as(e) {
  const t = e;
  return !!t.attributes && !!t.startTime && !!t.name && !!t.endTime && !!t.status;
}
function cs(e) {
  return typeof e.getSpanJSON == "function";
}
function us(e) {
  const { traceFlags: t } = e.spanContext();
  return t === is;
}
function ls(e) {
  if (!(!e || e.code === rs))
    return e.code === os ? "ok" : e.message || "unknown_error";
}
const ds = "_sentryRootSpan";
function no(e) {
  return e[ds] || e;
}
const wn = "production", fs = "_frozenDsc";
function ro(e, t) {
  const n = t.getOptions(), { publicKey: r } = t.getDsn() || {}, o = z({
    environment: n.environment || wn,
    release: n.release,
    public_key: r,
    trace_id: e
  });
  return t.emit("createDsc", o), o;
}
function _s(e) {
  const t = F();
  if (!t)
    return {};
  const n = ro(Tt(e).trace_id || "", t), r = no(e), o = r[fs];
  if (o)
    return o;
  const i = r.spanContext().traceState, s = i && i.get("sentry.dsc"), a = s && xi(s);
  if (a)
    return a;
  const c = Tt(r), l = c.data || {}, d = l[es];
  d != null && (n.sample_rate = `${d}`);
  const u = l[Qi], _ = c.description;
  return u !== "url" && _ && (n.transaction = _), n.sampled = String(us(r)), t.emit("createDsc", n, r), n;
}
function ps(e) {
  if (typeof e == "boolean")
    return Number(e);
  const t = typeof e == "string" ? parseFloat(e) : e;
  if (typeof t != "number" || isNaN(t) || t < 0 || t > 1) {
    N && g.warn(
      `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
        e
      )} of type ${JSON.stringify(typeof e)}.`
    );
    return;
  }
  return t;
}
function hs(e, t) {
  return t && (e.sdk = e.sdk || {}, e.sdk.name = e.sdk.name || t.name, e.sdk.version = e.sdk.version || t.version, e.sdk.integrations = [...e.sdk.integrations || [], ...t.integrations || []], e.sdk.packages = [...e.sdk.packages || [], ...t.packages || []]), e;
}
function ms(e, t, n, r) {
  const o = eo(n), i = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...o && { sdk: o },
    ...!!r && t && { dsn: $t(t) }
  }, s = "aggregates" in e ? [{ type: "sessions" }, e] : [{ type: "session" }, e.toJSON()];
  return at(i, [s]);
}
function gs(e, t, n, r) {
  const o = eo(n), i = e.type && e.type !== "replay_event" ? e.type : "event";
  hs(e, n && n.sdk);
  const s = Li(e, o, r, t);
  return delete e.sdkProcessingMetadata, at(s, [[{ type: i }, e]]);
}
function rn(e, t, n, r = 0) {
  return new Q((o, i) => {
    const s = e[r];
    if (t === null || typeof s != "function")
      o(t);
    else {
      const a = s({ ...t }, n);
      N && s.id && a === null && g.log(`Event processor "${s.id}" dropped event`), Mt(a) ? a.then((c) => rn(e, c, n, r + 1).then(o)).then(null, i) : rn(e, a, n, r + 1).then(o).then(null, i);
    }
  });
}
function ys(e, t) {
  const { fingerprint: n, span: r, breadcrumbs: o, sdkProcessingMetadata: i } = t;
  bs(e, t), r && vs(e, r), ws(e, n), Es(e, o), Ss(e, i);
}
function ir(e, t) {
  const {
    extra: n,
    tags: r,
    user: o,
    contexts: i,
    level: s,
    sdkProcessingMetadata: a,
    breadcrumbs: c,
    fingerprint: l,
    eventProcessors: d,
    attachments: u,
    propagationContext: _,
    transactionName: f,
    span: p
  } = t;
  Je(e, "extra", n), Je(e, "tags", r), Je(e, "user", o), Je(e, "contexts", i), Je(e, "sdkProcessingMetadata", a), s && (e.level = s), f && (e.transactionName = f), p && (e.span = p), c.length && (e.breadcrumbs = [...e.breadcrumbs, ...c]), l.length && (e.fingerprint = [...e.fingerprint, ...l]), d.length && (e.eventProcessors = [...e.eventProcessors, ...d]), u.length && (e.attachments = [...e.attachments, ...u]), e.propagationContext = { ...e.propagationContext, ..._ };
}
function Je(e, t, n) {
  if (n && Object.keys(n).length) {
    e[t] = { ...e[t] };
    for (const r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[t][r] = n[r]);
  }
}
function bs(e, t) {
  const { extra: n, tags: r, user: o, contexts: i, level: s, transactionName: a } = t, c = z(n);
  c && Object.keys(c).length && (e.extra = { ...c, ...e.extra });
  const l = z(r);
  l && Object.keys(l).length && (e.tags = { ...l, ...e.tags });
  const d = z(o);
  d && Object.keys(d).length && (e.user = { ...d, ...e.user });
  const u = z(i);
  u && Object.keys(u).length && (e.contexts = { ...u, ...e.contexts }), s && (e.level = s), a && e.type !== "transaction" && (e.transaction = a);
}
function Es(e, t) {
  const n = [...e.breadcrumbs || [], ...t];
  e.breadcrumbs = n.length ? n : void 0;
}
function Ss(e, t) {
  e.sdkProcessingMetadata = {
    ...e.sdkProcessingMetadata,
    ...t
  };
}
function vs(e, t) {
  e.contexts = {
    trace: ss(t),
    ...e.contexts
  }, e.sdkProcessingMetadata = {
    dynamicSamplingContext: _s(t),
    ...e.sdkProcessingMetadata
  };
  const n = no(t), r = Tt(n).description;
  r && !e.transaction && e.type === "transaction" && (e.transaction = r);
}
function ws(e, t) {
  e.fingerprint = e.fingerprint ? Zr(e.fingerprint) : [], t && (e.fingerprint = e.fingerprint.concat(t)), e.fingerprint && !e.fingerprint.length && delete e.fingerprint;
}
function ks(e, t, n, r, o, i) {
  const { normalizeDepth: s = 3, normalizeMaxBreadth: a = 1e3 } = e, c = {
    ...t,
    event_id: t.event_id || n.event_id || ee(),
    timestamp: t.timestamp || st()
  }, l = n.integrations || e.integrations.map((y) => y.name);
  xs(c, e), Is(c, l), o && o.emit("applyFrameMetadata", t), t.type === void 0 && Cs(c, e.stackParser);
  const d = Ds(r, n.captureContext);
  n.mechanism && nt(c, n.mechanism);
  const u = o ? o.getEventProcessors() : [], _ = to().getScopeData();
  if (i) {
    const y = i.getScopeData();
    ir(_, y);
  }
  if (d) {
    const y = d.getScopeData();
    ir(_, y);
  }
  const f = [...n.attachments || [], ..._.attachments];
  f.length && (n.attachments = f), ys(c, _);
  const p = [
    ...u,
    // Run scope event processors _after_ all other processors
    ..._.eventProcessors
  ];
  return rn(p, c, n).then((y) => (y && Ns(y), typeof s == "number" && s > 0 ? Ts(y, s, a) : y));
}
function xs(e, t) {
  const { environment: n, release: r, dist: o, maxValueLength: i = 250 } = t;
  "environment" in e || (e.environment = "environment" in t ? n : wn), e.release === void 0 && r !== void 0 && (e.release = r), e.dist === void 0 && o !== void 0 && (e.dist = o), e.message && (e.message = Pe(e.message, i));
  const s = e.exception && e.exception.values && e.exception.values[0];
  s && s.value && (s.value = Pe(s.value, i));
  const a = e.request;
  a && a.url && (a.url = Pe(a.url, i));
}
const sr = /* @__PURE__ */ new WeakMap();
function Cs(e, t) {
  const n = w._sentryDebugIds;
  if (!n)
    return;
  let r;
  const o = sr.get(t);
  o ? r = o : (r = /* @__PURE__ */ new Map(), sr.set(t, r));
  const i = Object.entries(n).reduce(
    (s, [a, c]) => {
      let l;
      const d = r.get(a);
      d ? l = d : (l = t(a), r.set(a, l));
      for (let u = l.length - 1; u >= 0; u--) {
        const _ = l[u];
        if (_.filename) {
          s[_.filename] = c;
          break;
        }
      }
      return s;
    },
    {}
  );
  try {
    e.exception.values.forEach((s) => {
      s.stacktrace.frames.forEach((a) => {
        a.filename && (a.debug_id = i[a.filename]);
      });
    });
  } catch {
  }
}
function Ns(e) {
  const t = {};
  try {
    e.exception.values.forEach((r) => {
      r.stacktrace.frames.forEach((o) => {
        o.debug_id && (o.abs_path ? t[o.abs_path] = o.debug_id : o.filename && (t[o.filename] = o.debug_id), delete o.debug_id);
      });
    });
  } catch {
  }
  if (Object.keys(t).length === 0)
    return;
  e.debug_meta = e.debug_meta || {}, e.debug_meta.images = e.debug_meta.images || [];
  const n = e.debug_meta.images;
  Object.entries(t).forEach(([r, o]) => {
    n.push({
      type: "sourcemap",
      code_file: r,
      debug_id: o
    });
  });
}
function Is(e, t) {
  t.length > 0 && (e.sdk = e.sdk || {}, e.sdk.integrations = [...e.sdk.integrations || [], ...t]);
}
function Ts(e, t, n) {
  if (!e)
    return null;
  const r = {
    ...e,
    ...e.breadcrumbs && {
      breadcrumbs: e.breadcrumbs.map((o) => ({
        ...o,
        ...o.data && {
          data: be(o.data, t, n)
        }
      }))
    },
    ...e.user && {
      user: be(e.user, t, n)
    },
    ...e.contexts && {
      contexts: be(e.contexts, t, n)
    },
    ...e.extra && {
      extra: be(e.extra, t, n)
    }
  };
  return e.contexts && e.contexts.trace && r.contexts && (r.contexts.trace = e.contexts.trace, e.contexts.trace.data && (r.contexts.trace.data = be(e.contexts.trace.data, t, n))), e.spans && (r.spans = e.spans.map((o) => ({
    ...o,
    ...o.data && {
      data: be(o.data, t, n)
    }
  }))), r;
}
function Ds(e, t) {
  if (!t)
    return e;
  const n = e ? e.clone() : new we();
  return n.update(t), n;
}
function Rs(e) {
  if (e)
    return Ls(e) ? { captureContext: e } : Os(e) ? {
      captureContext: e
    } : e;
}
function Ls(e) {
  return e instanceof we || typeof e == "function";
}
const Ms = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "requestSession",
  "propagationContext"
];
function Os(e) {
  return Object.keys(e).some((t) => Ms.includes(t));
}
function $s(e, t) {
  return te().captureException(e, Rs(t));
}
function sl(e, t) {
  const n = typeof t == "string" ? t : void 0, r = typeof t != "string" ? { captureContext: t } : void 0;
  return te().captureMessage(e, n, r);
}
function oo(e, t) {
  return te().captureEvent(e, t);
}
function al() {
  return !!F();
}
function ar(e) {
  const t = F(), n = We(), r = te(), { release: o, environment: i = wn } = t && t.getOptions() || {}, { userAgent: s } = w.navigator || {}, a = Hi({
    release: o,
    environment: i,
    user: r.getUser() || n.getUser(),
    ...s && { userAgent: s },
    ...e
  }), c = n.getSession();
  return c && c.status === "ok" && je(c, { status: "exited" }), io(), n.setSession(a), r.setSession(a), a;
}
function io() {
  const e = We(), t = te(), n = t.getSession() || e.getSession();
  n && ji(n), so(), e.setSession(), t.setSession();
}
function so() {
  const e = We(), t = te(), n = F(), r = t.getSession() || e.getSession();
  r && n && n.captureSession(r);
}
function cr(e = !1) {
  if (e) {
    io();
    return;
  }
  so();
}
const Fs = "7";
function Ps(e) {
  const t = e.protocol ? `${e.protocol}:` : "", n = e.port ? `:${e.port}` : "";
  return `${t}//${e.host}${n}${e.path ? `/${e.path}` : ""}/api/`;
}
function As(e) {
  return `${Ps(e)}${e.projectId}/envelope/`;
}
function Us(e, t) {
  return zo({
    // We send only the minimum set of required information. See
    // https://github.com/getsentry/sentry-javascript/issues/2572.
    sentry_key: e.publicKey,
    sentry_version: Fs,
    ...t && { sentry_client: `${t.name}/${t.version}` }
  });
}
function Hs(e, t, n) {
  return t || `${As(e)}?${Us(e, n)}`;
}
const ur = [];
function js(e) {
  const t = {};
  return e.forEach((n) => {
    const { name: r } = n, o = t[r];
    o && !o.isDefaultInstance && n.isDefaultInstance || (t[r] = n);
  }), Object.values(t);
}
function Bs(e) {
  const t = e.defaultIntegrations || [], n = e.integrations;
  t.forEach((s) => {
    s.isDefaultInstance = !0;
  });
  let r;
  Array.isArray(n) ? r = [...t, ...n] : typeof n == "function" ? r = Zr(n(t)) : r = t;
  const o = js(r), i = o.findIndex((s) => s.name === "Debug");
  if (i > -1) {
    const [s] = o.splice(i, 1);
    o.push(s);
  }
  return o;
}
function Ys(e, t) {
  const n = {};
  return t.forEach((r) => {
    r && ao(e, r, n);
  }), n;
}
function lr(e, t) {
  for (const n of t)
    n && n.afterAllSetup && n.afterAllSetup(e);
}
function ao(e, t, n) {
  if (n[t.name]) {
    N && g.log(`Integration skipped because it was already installed: ${t.name}`);
    return;
  }
  if (n[t.name] = t, ur.indexOf(t.name) === -1 && typeof t.setupOnce == "function" && (t.setupOnce(), ur.push(t.name)), t.setup && typeof t.setup == "function" && t.setup(e), typeof t.preprocessEvent == "function") {
    const r = t.preprocessEvent.bind(t);
    e.on("preprocessEvent", (o, i) => r(o, i, e));
  }
  if (typeof t.processEvent == "function") {
    const r = t.processEvent.bind(t), o = Object.assign((i, s) => r(i, s, e), {
      id: t.name
    });
    e.addEventProcessor(o);
  }
  N && g.log(`Integration installed: ${t.name}`);
}
const dr = "Not capturing exception because it's already been captured.";
class Gs {
  /** Options passed to the SDK. */
  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
  /** Array of set up integrations. */
  /** Number of calls being processed */
  /** Holds flushable  */
  // eslint-disable-next-line @typescript-eslint/ban-types
  /**
   * Initializes this client instance.
   *
   * @param options Options for the client.
   */
  constructor(t) {
    if (this._options = t, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], t.dsn ? this._dsn = Wo(t.dsn) : N && g.warn("No DSN provided, client will not send events."), this._dsn) {
      const n = Hs(
        this._dsn,
        t.tunnel,
        t._metadata ? t._metadata.sdk : void 0
      );
      this._transport = t.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...t.transportOptions,
        url: n
      });
    }
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  captureException(t, n, r) {
    const o = ee();
    if (Vn(t))
      return N && g.log(dr), o;
    const i = {
      event_id: o,
      ...n
    };
    return this._process(
      this.eventFromException(t, i).then(
        (s) => this._captureEvent(s, i, r)
      )
    ), i.event_id;
  }
  /**
   * @inheritDoc
   */
  captureMessage(t, n, r, o) {
    const i = {
      event_id: ee(),
      ...r
    }, s = hn(t) ? t : String(t), a = mn(t) ? this.eventFromMessage(s, n, i) : this.eventFromException(t, i);
    return this._process(a.then((c) => this._captureEvent(c, i, o))), i.event_id;
  }
  /**
   * @inheritDoc
   */
  captureEvent(t, n, r) {
    const o = ee();
    if (n && n.originalException && Vn(n.originalException))
      return N && g.log(dr), o;
    const i = {
      event_id: o,
      ...n
    }, a = (t.sdkProcessingMetadata || {}).capturedSpanScope;
    return this._process(this._captureEvent(t, i, a || r)), i.event_id;
  }
  /**
   * @inheritDoc
   */
  captureSession(t) {
    typeof t.release != "string" ? N && g.warn("Discarded session because of missing or non-string release") : (this.sendSession(t), je(t, { init: !1 }));
  }
  /**
   * @inheritDoc
   */
  getDsn() {
    return this._dsn;
  }
  /**
   * @inheritDoc
   */
  getOptions() {
    return this._options;
  }
  /**
   * @see SdkMetadata in @sentry/types
   *
   * @return The metadata of the SDK
   */
  getSdkMetadata() {
    return this._options._metadata;
  }
  /**
   * @inheritDoc
   */
  getTransport() {
    return this._transport;
  }
  /**
   * @inheritDoc
   */
  flush(t) {
    const n = this._transport;
    return n ? (this.emit("flush"), this._isClientDoneProcessing(t).then((r) => n.flush(t).then((o) => r && o))) : Ie(!0);
  }
  /**
   * @inheritDoc
   */
  close(t) {
    return this.flush(t).then((n) => (this.getOptions().enabled = !1, this.emit("close"), n));
  }
  /** Get all installed event processors. */
  getEventProcessors() {
    return this._eventProcessors;
  }
  /** @inheritDoc */
  addEventProcessor(t) {
    this._eventProcessors.push(t);
  }
  /** @inheritdoc */
  init() {
    (this._isEnabled() || // Force integrations to be setup even if no DSN was set when we have
    // Spotlight enabled. This is particularly important for browser as we
    // don't support the `spotlight` option there and rely on the users
    // adding the `spotlightBrowserIntegration()` to their integrations which
    // wouldn't get initialized with the check below when there's no DSN set.
    this._options.integrations.some(({ name: t }) => t.startsWith("Spotlight"))) && this._setupIntegrations();
  }
  /**
   * Gets an installed integration by its name.
   *
   * @returns The installed integration or `undefined` if no integration with that `name` was installed.
   */
  getIntegrationByName(t) {
    return this._integrations[t];
  }
  /**
   * @inheritDoc
   */
  addIntegration(t) {
    const n = this._integrations[t.name];
    ao(this, t, this._integrations), n || lr(this, [t]);
  }
  /**
   * @inheritDoc
   */
  sendEvent(t, n = {}) {
    this.emit("beforeSendEvent", t, n);
    let r = gs(t, this._dsn, this._options._metadata, this._options.tunnel);
    for (const i of n.attachments || [])
      r = Ni(r, Di(i));
    const o = this.sendEnvelope(r);
    o && o.then((i) => this.emit("afterSendEvent", t, i), null);
  }
  /**
   * @inheritDoc
   */
  sendSession(t) {
    const n = ms(t, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(n);
  }
  /**
   * @inheritDoc
   */
  recordDroppedEvent(t, n, r) {
    if (this._options.sendClientReports) {
      const o = typeof r == "number" ? r : 1, i = `${t}:${n}`;
      N && g.log(`Recording outcome: "${i}"${o > 1 ? ` (${o} times)` : ""}`), this._outcomes[i] = (this._outcomes[i] || 0) + o;
    }
  }
  // Keep on() & emit() signatures in sync with types' client.ts interface
  /* eslint-disable @typescript-eslint/unified-signatures */
  /** @inheritdoc */
  /** @inheritdoc */
  on(t, n) {
    const r = this._hooks[t] = this._hooks[t] || [];
    return r.push(n), () => {
      const o = r.indexOf(n);
      o > -1 && r.splice(o, 1);
    };
  }
  /** @inheritdoc */
  /** @inheritdoc */
  emit(t, ...n) {
    const r = this._hooks[t];
    r && r.forEach((o) => o(...n));
  }
  /**
   * @inheritdoc
   */
  sendEnvelope(t) {
    return this.emit("beforeEnvelope", t), this._isEnabled() && this._transport ? this._transport.send(t).then(null, (n) => (N && g.error("Error while sending event:", n), n)) : (N && g.error("Transport disabled"), Ie({}));
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  /** Setup integrations for this client. */
  _setupIntegrations() {
    const { integrations: t } = this._options;
    this._integrations = Ys(this, t), lr(this, t);
  }
  /** Updates existing session based on the provided event */
  _updateSessionFromEvent(t, n) {
    let r = !1, o = !1;
    const i = n.exception && n.exception.values;
    if (i) {
      o = !0;
      for (const c of i) {
        const l = c.mechanism;
        if (l && l.handled === !1) {
          r = !0;
          break;
        }
      }
    }
    const s = t.status === "ok";
    (s && t.errors === 0 || s && r) && (je(t, {
      ...r && { status: "crashed" },
      errors: t.errors || Number(o || r)
    }), this.captureSession(t));
  }
  /**
   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
   * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
   * `false` otherwise
   */
  _isClientDoneProcessing(t) {
    return new Q((n) => {
      let r = 0;
      const o = 1, i = setInterval(() => {
        this._numProcessing == 0 ? (clearInterval(i), n(!0)) : (r += o, t && r >= t && (clearInterval(i), n(!1)));
      }, o);
    });
  }
  /** Determines whether this SDK is enabled and a transport is present. */
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0;
  }
  /**
   * Adds common information to events.
   *
   * The information includes release and environment from `options`,
   * breadcrumbs and context (extra, tags and user) from the scope.
   *
   * Information that is already present in the event is never overwritten. For
   * nested objects, such as the context, keys are merged.
   *
   * @param event The original event.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A new event with more information.
   */
  _prepareEvent(t, n, r, o = We()) {
    const i = this.getOptions(), s = Object.keys(this._integrations);
    return !n.integrations && s.length > 0 && (n.integrations = s), this.emit("preprocessEvent", t, n), t.type || o.setLastEventId(t.event_id || n.event_id), ks(i, t, n, r, this, o).then((a) => {
      if (a === null)
        return a;
      const c = {
        ...o.getPropagationContext(),
        ...r ? r.getPropagationContext() : void 0
      };
      if (!(a.contexts && a.contexts.trace) && c) {
        const { traceId: d, spanId: u, parentSpanId: _, dsc: f } = c;
        a.contexts = {
          trace: z({
            trace_id: d,
            span_id: u,
            parent_span_id: _
          }),
          ...a.contexts
        };
        const p = f || ro(d, this);
        a.sdkProcessingMetadata = {
          dynamicSamplingContext: p,
          ...a.sdkProcessingMetadata
        };
      }
      return a;
    });
  }
  /**
   * Processes the event and logs an error in case of rejection
   * @param event
   * @param hint
   * @param scope
   */
  _captureEvent(t, n = {}, r) {
    return this._processEvent(t, n, r).then(
      (o) => o.event_id,
      (o) => {
        if (N) {
          const i = o;
          i.logLevel === "log" ? g.log(i.message) : g.warn(i);
        }
      }
    );
  }
  /**
   * Processes an event (either error or message) and sends it to Sentry.
   *
   * This also adds breadcrumbs and context information to the event. However,
   * platform specific meta data (such as the User's IP address) must be added
   * by the SDK implementor.
   *
   *
   * @param event The event to send to Sentry.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
   */
  _processEvent(t, n, r) {
    const o = this.getOptions(), { sampleRate: i } = o, s = uo(t), a = co(t), c = t.type || "error", l = `before send for type \`${c}\``, d = typeof i > "u" ? void 0 : ps(i);
    if (a && typeof d == "number" && Math.random() > d)
      return this.recordDroppedEvent("sample_rate", "error", t), It(
        new ae(
          `Discarding event because it's not included in the random sample (sampling rate = ${i})`,
          "log"
        )
      );
    const u = c === "replay_event" ? "replay" : c, f = (t.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
    return this._prepareEvent(t, n, r, f).then((p) => {
      if (p === null)
        throw this.recordDroppedEvent("event_processor", u, t), new ae("An event processor returned `null`, will not send event.", "log");
      if (n.data && n.data.__sentry__ === !0)
        return p;
      const y = Xs(this, o, p, n);
      return qs(y, l);
    }).then((p) => {
      if (p === null) {
        if (this.recordDroppedEvent("before_send", u, t), s) {
          const k = 1 + (t.spans || []).length;
          this.recordDroppedEvent("before_send", "span", k);
        }
        throw new ae(`${l} returned \`null\`, will not send event.`, "log");
      }
      const R = r && r.getSession();
      if (!s && R && this._updateSessionFromEvent(R, p), s) {
        const E = p.sdkProcessingMetadata && p.sdkProcessingMetadata.spanCountBeforeProcessing || 0, k = p.spans ? p.spans.length : 0, P = E - k;
        P > 0 && this.recordDroppedEvent("before_send", "span", P);
      }
      const y = p.transaction_info;
      if (s && y && p.transaction !== t.transaction) {
        const E = "custom";
        p.transaction_info = {
          ...y,
          source: E
        };
      }
      return this.sendEvent(p, n), p;
    }).then(null, (p) => {
      throw p instanceof ae ? p : (this.captureException(p, {
        data: {
          __sentry__: !0
        },
        originalException: p
      }), new ae(
        `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${p}`
      ));
    });
  }
  /**
   * Occupies the client with processing and event
   */
  _process(t) {
    this._numProcessing++, t.then(
      (n) => (this._numProcessing--, n),
      (n) => (this._numProcessing--, n)
    );
  }
  /**
   * Clears outcomes on this client and returns them.
   */
  _clearOutcomes() {
    const t = this._outcomes;
    return this._outcomes = {}, Object.entries(t).map(([n, r]) => {
      const [o, i] = n.split(":");
      return {
        reason: o,
        category: i,
        quantity: r
      };
    });
  }
  /**
   * Sends client reports as an envelope.
   */
  _flushOutcomes() {
    N && g.log("Flushing outcomes...");
    const t = this._clearOutcomes();
    if (t.length === 0) {
      N && g.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      N && g.log("No dsn provided, will not send outcomes");
      return;
    }
    N && g.log("Sending outcomes:", t);
    const n = Mi(t, this._options.tunnel && $t(this._dsn));
    this.sendEnvelope(n);
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
}
function qs(e, t) {
  const n = `${t} must return \`null\` or a valid event.`;
  if (Mt(e))
    return e.then(
      (r) => {
        if (!He(r) && r !== null)
          throw new ae(n);
        return r;
      },
      (r) => {
        throw new ae(`${t} rejected with ${r}`);
      }
    );
  if (!He(e) && e !== null)
    throw new ae(n);
  return e;
}
function Xs(e, t, n, r) {
  const { beforeSend: o, beforeSendTransaction: i, beforeSendSpan: s } = t;
  if (co(n) && o)
    return o(n, r);
  if (uo(n)) {
    if (n.spans && s) {
      const a = [];
      for (const c of n.spans) {
        const l = s(c);
        l ? a.push(l) : e.recordDroppedEvent("before_send", "span");
      }
      n.spans = a;
    }
    if (i) {
      if (n.spans) {
        const a = n.spans.length;
        n.sdkProcessingMetadata = {
          ...n.sdkProcessingMetadata,
          spanCountBeforeProcessing: a
        };
      }
      return i(n, r);
    }
  }
  return n;
}
function co(e) {
  return e.type === void 0;
}
function uo(e) {
  return e.type === "transaction";
}
function Ws(e, t) {
  t.debug === !0 && (N ? g.enable() : it(() => {
    console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
  })), te().update(t.initialScope);
  const r = new e(t);
  return zs(r), r.init(), r;
}
function zs(e) {
  te().setClient(e);
}
const Vs = 64;
function Ks(e, t, n = Ei(
  e.bufferSize || Vs
)) {
  let r = {};
  const o = (s) => n.drain(s);
  function i(s) {
    const a = [];
    if (Jn(s, (u, _) => {
      const f = Zn(_);
      if (Pi(r, f)) {
        const p = fr(u, _);
        e.recordDroppedEvent("ratelimit_backoff", f, p);
      } else
        a.push(u);
    }), a.length === 0)
      return Ie({});
    const c = at(s[0], a), l = (u) => {
      Jn(c, (_, f) => {
        const p = fr(_, f);
        e.recordDroppedEvent(u, Zn(f), p);
      });
    }, d = () => t({ body: Ii(c) }).then(
      (u) => (u.statusCode !== void 0 && (u.statusCode < 200 || u.statusCode >= 300) && N && g.warn(`Sentry responded with status code ${u.statusCode} to sent event.`), r = Ai(r, u), u),
      (u) => {
        throw l("network_error"), u;
      }
    );
    return n.add(d).then(
      (u) => u,
      (u) => {
        if (u instanceof ae)
          return N && g.error("Skipped sending event because buffer is full."), l("queue_overflow"), Ie({});
        throw u;
      }
    );
  }
  return {
    send: i,
    flush: o
  };
}
function fr(e, t) {
  if (!(t !== "event" && t !== "transaction"))
    return Array.isArray(e) ? e[1] : void 0;
}
function Js(e, t, n = [t], r = "npm") {
  const o = e._metadata || {};
  o.sdk || (o.sdk = {
    name: `sentry.javascript.${t}`,
    packages: n.map((i) => ({
      name: `${r}:@sentry/${i}`,
      version: Se
    })),
    version: Se
  }), e._metadata = o;
}
const Zs = 100;
function Te(e, t) {
  const n = F(), r = We();
  if (!n)
    return;
  const { beforeBreadcrumb: o = null, maxBreadcrumbs: i = Zs } = n.getOptions();
  if (i <= 0)
    return;
  const a = { timestamp: st(), ...e }, c = o ? it(() => o(a, t)) : a;
  c !== null && (n.emit && n.emit("beforeAddBreadcrumb", c, t), r.addBreadcrumb(c, i));
}
let _r;
const Qs = "FunctionToString", pr = /* @__PURE__ */ new WeakMap(), ea = () => ({
  name: Qs,
  setupOnce() {
    _r = Function.prototype.toString;
    try {
      Function.prototype.toString = function(...e) {
        const t = bn(this), n = pr.has(F()) && t !== void 0 ? t : this;
        return _r.apply(n, e);
      };
    } catch {
    }
  },
  setup(e) {
    pr.set(e, !0);
  }
}), ta = ea, na = [
  /^Script error\.?$/,
  /^Javascript error: Script error\.? on line 0$/,
  /^ResizeObserver loop completed with undelivered notifications.$/,
  // The browser logs this when a ResizeObserver handler takes a bit longer. Usually this is not an actual issue though. It indicates slowness.
  /^Cannot redefine property: googletag$/,
  // This is thrown when google tag manager is used in combination with an ad blocker
  "undefined is not an object (evaluating 'a.L')",
  // Random error that happens but not actionable or noticeable to end-users.
  `can't redefine non-configurable property "solana"`,
  // Probably a browser extension or custom browser (Brave) throwing this error
  "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
  // Error thrown by GTM, seemingly not affecting end-users
  "Can't find variable: _AutofillCallbackHandler"
  // Unactionable error in instagram webview https://developers.facebook.com/community/threads/320013549791141/
], ra = "InboundFilters", oa = (e = {}) => ({
  name: ra,
  processEvent(t, n, r) {
    const o = r.getOptions(), i = sa(e, o);
    return aa(t, i) ? null : t;
  }
}), ia = oa;
function sa(e = {}, t = {}) {
  return {
    allowUrls: [...e.allowUrls || [], ...t.allowUrls || []],
    denyUrls: [...e.denyUrls || [], ...t.denyUrls || []],
    ignoreErrors: [
      ...e.ignoreErrors || [],
      ...t.ignoreErrors || [],
      ...e.disableErrorDefaults ? [] : na
    ],
    ignoreTransactions: [...e.ignoreTransactions || [], ...t.ignoreTransactions || []],
    ignoreInternal: e.ignoreInternal !== void 0 ? e.ignoreInternal : !0
  };
}
function aa(e, t) {
  return t.ignoreInternal && _a(e) ? (N && g.warn(`Event dropped due to being internal Sentry Error.
Event: ${ye(e)}`), !0) : ca(e, t.ignoreErrors) ? (N && g.warn(
    `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${ye(e)}`
  ), !0) : ha(e) ? (N && g.warn(
    `Event dropped due to not having an error message, error type or stacktrace.
Event: ${ye(
      e
    )}`
  ), !0) : ua(e, t.ignoreTransactions) ? (N && g.warn(
    `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${ye(e)}`
  ), !0) : la(e, t.denyUrls) ? (N && g.warn(
    `Event dropped due to being matched by \`denyUrls\` option.
Event: ${ye(
      e
    )}.
Url: ${Dt(e)}`
  ), !0) : da(e, t.allowUrls) ? !1 : (N && g.warn(
    `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${ye(
      e
    )}.
Url: ${Dt(e)}`
  ), !0);
}
function ca(e, t) {
  return e.type || !t || !t.length ? !1 : fa(e).some((n) => Ot(n, t));
}
function ua(e, t) {
  if (e.type !== "transaction" || !t || !t.length)
    return !1;
  const n = e.transaction;
  return n ? Ot(n, t) : !1;
}
function la(e, t) {
  if (!t || !t.length)
    return !1;
  const n = Dt(e);
  return n ? Ot(n, t) : !1;
}
function da(e, t) {
  if (!t || !t.length)
    return !0;
  const n = Dt(e);
  return n ? Ot(n, t) : !0;
}
function fa(e) {
  const t = [];
  e.message && t.push(e.message);
  let n;
  try {
    n = e.exception.values[e.exception.values.length - 1];
  } catch {
  }
  return n && n.value && (t.push(n.value), n.type && t.push(`${n.type}: ${n.value}`)), t;
}
function _a(e) {
  try {
    return e.exception.values[0].type === "SentryError";
  } catch {
  }
  return !1;
}
function pa(e = []) {
  for (let t = e.length - 1; t >= 0; t--) {
    const n = e[t];
    if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]")
      return n.filename || null;
  }
  return null;
}
function Dt(e) {
  try {
    let t;
    try {
      t = e.exception.values[0].stacktrace.frames;
    } catch {
    }
    return t ? pa(t) : null;
  } catch {
    return N && g.error(`Cannot extract url for event ${ye(e)}`), null;
  }
}
function ha(e) {
  return e.type || !e.exception || !e.exception.values || e.exception.values.length === 0 ? !1 : (
    // No top-level message
    !e.message && // There are no exception values that have a stacktrace, a non-generic-Error type or value
    !e.exception.values.some((t) => t.stacktrace || t.type && t.type !== "Error" || t.value)
  );
}
const ma = "Dedupe", ga = () => {
  let e;
  return {
    name: ma,
    processEvent(t) {
      if (t.type)
        return t;
      try {
        if (ba(t, e))
          return N && g.warn("Event dropped due to being a duplicate of previously captured event."), null;
      } catch {
      }
      return e = t;
    }
  };
}, ya = ga;
function ba(e, t) {
  return t ? !!(Ea(e, t) || Sa(e, t)) : !1;
}
function Ea(e, t) {
  const n = e.message, r = t.message;
  return !(!n && !r || n && !r || !n && r || n !== r || !fo(e, t) || !lo(e, t));
}
function Sa(e, t) {
  const n = hr(t), r = hr(e);
  return !(!n || !r || n.type !== r.type || n.value !== r.value || !fo(e, t) || !lo(e, t));
}
function lo(e, t) {
  let n = Xn(e), r = Xn(t);
  if (!n && !r)
    return !0;
  if (n && !r || !n && r || (n = n, r = r, r.length !== n.length))
    return !1;
  for (let o = 0; o < r.length; o++) {
    const i = r[o], s = n[o];
    if (i.filename !== s.filename || i.lineno !== s.lineno || i.colno !== s.colno || i.function !== s.function)
      return !1;
  }
  return !0;
}
function fo(e, t) {
  let n = e.fingerprint, r = t.fingerprint;
  if (!n && !r)
    return !0;
  if (n && !r || !n && r)
    return !1;
  n = n, r = r;
  try {
    return n.join("") === r.join("");
  } catch {
    return !1;
  }
}
function hr(e) {
  return e.exception && e.exception.values && e.exception.values[0];
}
function va(e, t = {}, n = te()) {
  const { message: r, name: o, email: i, url: s, source: a, associatedEventId: c, tags: l } = e, d = {
    contexts: {
      feedback: z({
        contact_email: i,
        name: o,
        message: r,
        url: s,
        source: a,
        associated_event_id: c
      })
    },
    type: "feedback",
    level: "info",
    tags: l
  }, u = n && n.getClient() || F();
  return u && u.emit("beforeSendFeedback", d, t), n.captureEvent(d, t);
}
const x = w;
let on = 0;
function _o() {
  return on > 0;
}
function wa() {
  on++, setTimeout(() => {
    on--;
  });
}
function Ye(e, t = {}, n) {
  if (typeof e != "function")
    return e;
  try {
    const o = e.__sentry_wrapped__;
    if (o)
      return o;
    if (bn(e))
      return e;
  } catch {
    return e;
  }
  const r = function() {
    const o = Array.prototype.slice.call(arguments);
    try {
      n && typeof n == "function" && n.apply(this, arguments);
      const i = o.map((s) => Ye(s, t));
      return e.apply(this, i);
    } catch (i) {
      throw wa(), Ki((s) => {
        s.addEventProcessor((a) => (t.mechanism && (Qt(a, void 0, void 0), nt(a, t.mechanism)), a.extra = {
          ...a.extra,
          arguments: o
        }, a)), $s(i);
      }), i;
    }
  };
  try {
    for (const o in e)
      Object.prototype.hasOwnProperty.call(e, o) && (r[o] = e[o]);
  } catch {
  }
  qr(r, e), Ce(e, "__sentry_wrapped__", r);
  try {
    Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
      get() {
        return e.name;
      }
    });
  } catch {
  }
  return r;
}
const ct = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function kn(e, t) {
  const n = xn(e, t), r = {
    type: t && t.name,
    value: Ia(t)
  };
  return n.length && (r.stacktrace = { frames: n }), r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"), r;
}
function ka(e, t, n, r) {
  const o = F(), i = o && o.getOptions().normalizeDepth, s = Ma(t), a = {
    __serialized__: Qr(t, i)
  };
  if (s)
    return {
      exception: {
        values: [kn(e, s)]
      },
      extra: a
    };
  const c = {
    exception: {
      values: [
        {
          type: Lt(t) ? t.constructor.name : r ? "UnhandledRejection" : "Error",
          value: Ra(t, { isUnhandledRejection: r })
        }
      ]
    },
    extra: a
  };
  if (n) {
    const l = xn(e, n);
    l.length && (c.exception.values[0].stacktrace = { frames: l });
  }
  return c;
}
function Bt(e, t) {
  return {
    exception: {
      values: [kn(e, t)]
    }
  };
}
function xn(e, t) {
  const n = t.stacktrace || t.stack || "", r = Ca(t), o = Na(t);
  try {
    return e(n, r, o);
  } catch {
  }
  return [];
}
const xa = /Minified React error #\d+;/i;
function Ca(e) {
  return e && xa.test(e.message) ? 1 : 0;
}
function Na(e) {
  return typeof e.framesToPop == "number" ? e.framesToPop : 0;
}
function Ia(e) {
  const t = e && e.message;
  return t ? t.error && typeof t.error.message == "string" ? t.error.message : t : "No error message";
}
function Ta(e, t, n, r) {
  const o = n && n.syntheticException || void 0, i = Cn(e, t, o, r);
  return nt(i), i.level = "error", n && n.event_id && (i.event_id = n.event_id), Ie(i);
}
function Da(e, t, n = "info", r, o) {
  const i = r && r.syntheticException || void 0, s = sn(e, t, i, o);
  return s.level = n, r && r.event_id && (s.event_id = r.event_id), Ie(s);
}
function Cn(e, t, n, r, o) {
  let i;
  if (Hr(t) && t.error)
    return Bt(e, t.error);
  if (An(t) || Ro(t)) {
    const s = t;
    if ("stack" in t)
      i = Bt(e, t);
    else {
      const a = s.name || (An(s) ? "DOMError" : "DOMException"), c = s.message ? `${a}: ${s.message}` : a;
      i = sn(e, c, n, r), Qt(i, c);
    }
    return "code" in s && (i.tags = { ...i.tags, "DOMException.code": `${s.code}` }), i;
  }
  return pn(t) ? Bt(e, t) : He(t) || Lt(t) ? (i = ka(e, t, n, o), nt(i, {
    synthetic: !0
  }), i) : (i = sn(e, t, n, r), Qt(i, `${t}`, void 0), nt(i, {
    synthetic: !0
  }), i);
}
function sn(e, t, n, r) {
  const o = {};
  if (r && n) {
    const i = xn(e, n);
    i.length && (o.exception = {
      values: [{ value: t, stacktrace: { frames: i } }]
    });
  }
  if (hn(t)) {
    const { __sentry_template_string__: i, __sentry_template_values__: s } = t;
    return o.logentry = {
      message: i,
      params: s
    }, o;
  }
  return o.message = t, o;
}
function Ra(e, { isUnhandledRejection: t }) {
  const n = Vo(e), r = t ? "promise rejection" : "exception";
  return Hr(e) ? `Event \`ErrorEvent\` captured as ${r} with message \`${e.message}\`` : Lt(e) ? `Event \`${La(e)}\` (type=${e.type}) captured as ${r}` : `Object captured as ${r} with keys: ${n}`;
}
function La(e) {
  try {
    const t = Object.getPrototypeOf(e);
    return t ? t.constructor.name : void 0;
  } catch {
  }
}
function Ma(e) {
  for (const t in e)
    if (Object.prototype.hasOwnProperty.call(e, t)) {
      const n = e[t];
      if (n instanceof Error)
        return n;
    }
}
function Oa(e, {
  metadata: t,
  tunnel: n,
  dsn: r
}) {
  const o = {
    event_id: e.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...t && t.sdk && {
      sdk: {
        name: t.sdk.name,
        version: t.sdk.version
      }
    },
    ...!!n && !!r && { dsn: $t(r) }
  }, i = $a(e);
  return at(o, [i]);
}
function $a(e) {
  return [{
    type: "user_report"
  }, e];
}
class Fa extends Gs {
  /**
   * Creates a new Browser SDK instance.
   *
   * @param options Configuration options for this SDK.
   */
  constructor(t) {
    const n = {
      // We default this to true, as it is the safer scenario
      parentSpanIsAlwaysRootSpan: !0,
      ...t
    }, r = x.SENTRY_SDK_SOURCE || di();
    Js(n, "browser", ["browser"], r), super(n), n.sendClientReports && x.document && x.document.addEventListener("visibilitychange", () => {
      x.document.visibilityState === "hidden" && this._flushOutcomes();
    });
  }
  /**
   * @inheritDoc
   */
  eventFromException(t, n) {
    return Ta(this._options.stackParser, t, n, this._options.attachStacktrace);
  }
  /**
   * @inheritDoc
   */
  eventFromMessage(t, n = "info", r) {
    return Da(this._options.stackParser, t, n, r, this._options.attachStacktrace);
  }
  /**
   * Sends user feedback to Sentry.
   *
   * @deprecated Use `captureFeedback` instead.
   */
  captureUserFeedback(t) {
    if (!this._isEnabled()) {
      ct && g.warn("SDK not enabled, will not capture user feedback.");
      return;
    }
    const n = Oa(t, {
      metadata: this.getSdkMetadata(),
      dsn: this.getDsn(),
      tunnel: this.getOptions().tunnel
    });
    this.sendEnvelope(n);
  }
  /**
   * @inheritDoc
   */
  _prepareEvent(t, n, r) {
    return t.platform = t.platform || "javascript", super._prepareEvent(t, n, r);
  }
}
const Pa = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, j = w, Aa = 1e3;
let mr, an, cn;
function Ua(e) {
  const t = "dom";
  De(t, e), Re(t, Ha);
}
function Ha() {
  if (!j.document)
    return;
  const e = oe.bind(null, "dom"), t = gr(e, !0);
  j.document.addEventListener("click", t, !1), j.document.addEventListener("keypress", t, !1), ["EventTarget", "Node"].forEach((n) => {
    const r = j[n] && j[n].prototype;
    !r || !r.hasOwnProperty || !r.hasOwnProperty("addEventListener") || (W(r, "addEventListener", function(o) {
      return function(i, s, a) {
        if (i === "click" || i == "keypress")
          try {
            const c = this, l = c.__sentry_instrumentation_handlers__ = c.__sentry_instrumentation_handlers__ || {}, d = l[i] = l[i] || { refCount: 0 };
            if (!d.handler) {
              const u = gr(e);
              d.handler = u, o.call(this, i, u, a);
            }
            d.refCount++;
          } catch {
          }
        return o.call(this, i, s, a);
      };
    }), W(
      r,
      "removeEventListener",
      function(o) {
        return function(i, s, a) {
          if (i === "click" || i == "keypress")
            try {
              const c = this, l = c.__sentry_instrumentation_handlers__ || {}, d = l[i];
              d && (d.refCount--, d.refCount <= 0 && (o.call(this, i, d.handler, a), d.handler = void 0, delete l[i]), Object.keys(l).length === 0 && delete c.__sentry_instrumentation_handlers__);
            } catch {
            }
          return o.call(this, i, s, a);
        };
      }
    ));
  });
}
function ja(e) {
  if (e.type !== an)
    return !1;
  try {
    if (!e.target || e.target._sentryId !== cn)
      return !1;
  } catch {
  }
  return !0;
}
function Ba(e, t) {
  return e !== "keypress" ? !1 : !t || !t.tagName ? !0 : !(t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable);
}
function gr(e, t = !1) {
  return (n) => {
    if (!n || n._sentryCaptured)
      return;
    const r = Ya(n);
    if (Ba(n.type, r))
      return;
    Ce(n, "_sentryCaptured", !0), r && !r._sentryId && Ce(r, "_sentryId", ee());
    const o = n.type === "keypress" ? "input" : n.type;
    ja(n) || (e({ event: n, name: o, global: t }), an = n.type, cn = r ? r._sentryId : void 0), clearTimeout(mr), mr = j.setTimeout(() => {
      cn = void 0, an = void 0;
    }, Aa);
  };
}
function Ya(e) {
  try {
    return e.target;
  } catch {
    return null;
  }
}
let ht;
function po(e) {
  const t = "history";
  De(t, e), Re(t, Ga);
}
function Ga() {
  if (!Ui())
    return;
  const e = j.onpopstate;
  j.onpopstate = function(...n) {
    const r = j.location.href, o = ht;
    if (ht = r, oe("history", { from: o, to: r }), e)
      try {
        return e.apply(this, n);
      } catch {
      }
  };
  function t(n) {
    return function(...r) {
      const o = r.length > 2 ? r[2] : void 0;
      if (o) {
        const i = ht, s = String(o);
        ht = s, oe("history", { from: i, to: s });
      }
      return n.apply(this, r);
    };
  }
  W(j.history, "pushState", t), W(j.history, "replaceState", t);
}
const St = {};
function qa(e) {
  const t = St[e];
  if (t)
    return t;
  let n = j[e];
  if (Jt(n))
    return St[e] = n.bind(j);
  const r = j.document;
  if (r && typeof r.createElement == "function")
    try {
      const o = r.createElement("iframe");
      o.hidden = !0, r.head.appendChild(o);
      const i = o.contentWindow;
      i && i[e] && (n = i[e]), r.head.removeChild(o);
    } catch (o) {
      Pa && g.warn(`Could not create sandbox iframe for ${e} check, bailing to window.${e}: `, o);
    }
  return n && (St[e] = n.bind(j));
}
function yr(e) {
  St[e] = void 0;
}
const Qe = "__sentry_xhr_v3__";
function Xa(e) {
  const t = "xhr";
  De(t, e), Re(t, Wa);
}
function Wa() {
  if (!j.XMLHttpRequest)
    return;
  const e = XMLHttpRequest.prototype;
  e.open = new Proxy(e.open, {
    apply(t, n, r) {
      const o = _e() * 1e3, i = fe(r[0]) ? r[0].toUpperCase() : void 0, s = za(r[1]);
      if (!i || !s)
        return t.apply(n, r);
      n[Qe] = {
        method: i,
        url: s,
        request_headers: {}
      }, i === "POST" && s.match(/sentry_key/) && (n.__sentry_own_request__ = !0);
      const a = () => {
        const c = n[Qe];
        if (c && n.readyState === 4) {
          try {
            c.status_code = n.status;
          } catch {
          }
          const l = {
            endTimestamp: _e() * 1e3,
            startTimestamp: o,
            xhr: n
          };
          oe("xhr", l);
        }
      };
      return "onreadystatechange" in n && typeof n.onreadystatechange == "function" ? n.onreadystatechange = new Proxy(n.onreadystatechange, {
        apply(c, l, d) {
          return a(), c.apply(l, d);
        }
      }) : n.addEventListener("readystatechange", a), n.setRequestHeader = new Proxy(n.setRequestHeader, {
        apply(c, l, d) {
          const [u, _] = d, f = l[Qe];
          return f && fe(u) && fe(_) && (f.request_headers[u.toLowerCase()] = _), c.apply(l, d);
        }
      }), t.apply(n, r);
    }
  }), e.send = new Proxy(e.send, {
    apply(t, n, r) {
      const o = n[Qe];
      if (!o)
        return t.apply(n, r);
      r[0] !== void 0 && (o.body = r[0]);
      const i = {
        startTimestamp: _e() * 1e3,
        xhr: n
      };
      return oe("xhr", i), t.apply(n, r);
    }
  });
}
function za(e) {
  if (fe(e))
    return e;
  try {
    return e.toString();
  } catch {
  }
}
function Va(e, t = qa("fetch")) {
  let n = 0, r = 0;
  function o(i) {
    const s = i.body.length;
    n += s, r++;
    const a = {
      body: i.body,
      method: "POST",
      referrerPolicy: "origin",
      headers: e.headers,
      // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
      // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
      // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).
      // Gotchas:
      // - `keepalive` isn't supported by Firefox
      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
      //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
      //   We will therefore only activate the flag when we're below that limit.
      // There is also a limit of requests that can be open at the same time, so we also limit this to 15
      // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
      keepalive: n <= 6e4 && r < 15,
      ...e.fetchOptions
    };
    if (!t)
      return yr("fetch"), It("No fetch implementation available");
    try {
      return t(e.url, a).then((c) => (n -= s, r--, {
        statusCode: c.status,
        headers: {
          "x-sentry-rate-limits": c.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": c.headers.get("Retry-After")
        }
      }));
    } catch (c) {
      return yr("fetch"), n -= s, r--, It(c);
    }
  }
  return Ks(e, o);
}
const Ka = 30, Ja = 50;
function un(e, t, n, r) {
  const o = {
    filename: e,
    function: t === "<anonymous>" ? Ne : t,
    in_app: !0
    // All browser frames are considered in_app
  };
  return n !== void 0 && (o.lineno = n), r !== void 0 && (o.colno = r), o;
}
const Za = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i, Qa = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, ec = /\((\S*)(?::(\d+))(?::(\d+))\)/, tc = (e) => {
  const t = Za.exec(e);
  if (t) {
    const [, r, o, i] = t;
    return un(r, Ne, +o, +i);
  }
  const n = Qa.exec(e);
  if (n) {
    if (n[2] && n[2].indexOf("eval") === 0) {
      const s = ec.exec(n[2]);
      s && (n[2] = s[1], n[3] = s[2], n[4] = s[3]);
    }
    const [o, i] = ho(n[1] || Ne, n[2]);
    return un(i, o, n[3] ? +n[3] : void 0, n[4] ? +n[4] : void 0);
  }
}, nc = [Ka, tc], rc = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i, oc = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i, ic = (e) => {
  const t = rc.exec(e);
  if (t) {
    if (t[3] && t[3].indexOf(" > eval") > -1) {
      const i = oc.exec(t[3]);
      i && (t[1] = t[1] || "eval", t[3] = i[1], t[4] = i[2], t[5] = "");
    }
    let r = t[3], o = t[1] || Ne;
    return [o, r] = ho(o, r), un(r, o, t[4] ? +t[4] : void 0, t[5] ? +t[5] : void 0);
  }
}, sc = [Ja, ic], ac = [nc, sc], cc = zr(...ac), ho = (e, t) => {
  const n = e.indexOf("safari-extension") !== -1, r = e.indexOf("safari-web-extension") !== -1;
  return n || r ? [
    e.indexOf("@") !== -1 ? e.split("@")[0] : Ne,
    n ? `safari-extension:${t}` : `safari-web-extension:${t}`
  ] : [e, t];
}, mt = 1024, uc = "Breadcrumbs", lc = (e = {}) => {
  const t = {
    console: !0,
    dom: !0,
    fetch: !0,
    history: !0,
    sentry: !0,
    xhr: !0,
    ...e
  };
  return {
    name: uc,
    setup(n) {
      t.console && Qo(pc(n)), t.dom && Ua(_c(n, t.dom)), t.xhr && Xa(hc(n)), t.fetch && ri(mc(n)), t.history && po(gc(n)), t.sentry && n.on("beforeSendEvent", fc(n));
    }
  };
}, dc = lc;
function fc(e) {
  return function(n) {
    F() === e && Te(
      {
        category: `sentry.${n.type === "transaction" ? "transaction" : "event"}`,
        event_id: n.event_id,
        level: n.level,
        message: ye(n)
      },
      {
        event: n
      }
    );
  };
}
function _c(e, t) {
  return function(r) {
    if (F() !== e)
      return;
    let o, i, s = typeof t == "object" ? t.serializeAttribute : void 0, a = typeof t == "object" && typeof t.maxStringLength == "number" ? t.maxStringLength : void 0;
    a && a > mt && (ct && g.warn(
      `\`dom.maxStringLength\` cannot exceed ${mt}, but a value of ${a} was configured. Sentry will use ${mt} instead.`
    ), a = mt), typeof s == "string" && (s = [s]);
    try {
      const l = r.event, d = yc(l) ? l.target : l;
      o = Br(d, { keyAttrs: s, maxStringLength: a }), i = Ho(d);
    } catch {
      o = "<unknown>";
    }
    if (o.length === 0)
      return;
    const c = {
      category: `ui.${r.name}`,
      message: o
    };
    i && (c.data = { "ui.component_name": i }), Te(c, {
      event: r.event,
      name: r.name,
      global: r.global
    });
  };
}
function pc(e) {
  return function(n) {
    if (F() !== e)
      return;
    const r = {
      category: "console",
      data: {
        arguments: n.args,
        logger: "console"
      },
      level: vi(n.level),
      message: Un(n.args, " ")
    };
    if (n.level === "assert")
      if (n.args[0] === !1)
        r.message = `Assertion failed: ${Un(n.args.slice(1), " ") || "console.assert"}`, r.data.arguments = n.args.slice(1);
      else
        return;
    Te(r, {
      input: n.args,
      level: n.level
    });
  };
}
function hc(e) {
  return function(n) {
    if (F() !== e)
      return;
    const { startTimestamp: r, endTimestamp: o } = n, i = n.xhr[Qe];
    if (!r || !o || !i)
      return;
    const { method: s, url: a, status_code: c, body: l } = i, d = {
      method: s,
      url: a,
      status_code: c
    }, u = {
      xhr: n.xhr,
      input: l,
      startTimestamp: r,
      endTimestamp: o
    };
    Te(
      {
        category: "xhr",
        data: d,
        type: "http"
      },
      u
    );
  };
}
function mc(e) {
  return function(n) {
    if (F() !== e)
      return;
    const { startTimestamp: r, endTimestamp: o } = n;
    if (o && !(n.fetchData.url.match(/sentry_key/) && n.fetchData.method === "POST"))
      if (n.error) {
        const i = n.fetchData, s = {
          data: n.error,
          input: n.args,
          startTimestamp: r,
          endTimestamp: o
        };
        Te(
          {
            category: "fetch",
            data: i,
            level: "error",
            type: "http"
          },
          s
        );
      } else {
        const i = n.response, s = {
          ...n.fetchData,
          status_code: i && i.status
        }, a = {
          input: n.args,
          response: i,
          startTimestamp: r,
          endTimestamp: o
        };
        Te(
          {
            category: "fetch",
            data: s,
            type: "http"
          },
          a
        );
      }
  };
}
function gc(e) {
  return function(n) {
    if (F() !== e)
      return;
    let r = n.from, o = n.to;
    const i = jt(x.location.href);
    let s = r ? jt(r) : void 0;
    const a = jt(o);
    (!s || !s.path) && (s = i), i.protocol === a.protocol && i.host === a.host && (o = a.relative), i.protocol === s.protocol && i.host === s.host && (r = s.relative), Te({
      category: "navigation",
      data: {
        from: r,
        to: o
      }
    });
  };
}
function yc(e) {
  return !!e && !!e.target;
}
const bc = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "BroadcastChannel",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "SharedWorker",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload"
], Ec = "BrowserApiErrors", Sc = (e = {}) => {
  const t = {
    XMLHttpRequest: !0,
    eventTarget: !0,
    requestAnimationFrame: !0,
    setInterval: !0,
    setTimeout: !0,
    ...e
  };
  return {
    name: Ec,
    // TODO: This currently only works for the first client this is setup
    // We may want to adjust this to check for client etc.
    setupOnce() {
      t.setTimeout && W(x, "setTimeout", br), t.setInterval && W(x, "setInterval", br), t.requestAnimationFrame && W(x, "requestAnimationFrame", wc), t.XMLHttpRequest && "XMLHttpRequest" in x && W(XMLHttpRequest.prototype, "send", kc);
      const n = t.eventTarget;
      n && (Array.isArray(n) ? n : bc).forEach(xc);
    }
  };
}, vc = Sc;
function br(e) {
  return function(...t) {
    const n = t[0];
    return t[0] = Ye(n, {
      mechanism: {
        data: { function: ve(e) },
        handled: !1,
        type: "instrument"
      }
    }), e.apply(this, t);
  };
}
function wc(e) {
  return function(t) {
    return e.apply(this, [
      Ye(t, {
        mechanism: {
          data: {
            function: "requestAnimationFrame",
            handler: ve(e)
          },
          handled: !1,
          type: "instrument"
        }
      })
    ]);
  };
}
function kc(e) {
  return function(...t) {
    const n = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((o) => {
      o in n && typeof n[o] == "function" && W(n, o, function(i) {
        const s = {
          mechanism: {
            data: {
              function: o,
              handler: ve(i)
            },
            handled: !1,
            type: "instrument"
          }
        }, a = bn(i);
        return a && (s.mechanism.data.handler = ve(a)), Ye(i, s);
      });
    }), e.apply(this, t);
  };
}
function xc(e) {
  const t = x, n = t[e] && t[e].prototype;
  !n || !n.hasOwnProperty || !n.hasOwnProperty("addEventListener") || (W(n, "addEventListener", function(r) {
    return function(o, i, s) {
      try {
        typeof i.handleEvent == "function" && (i.handleEvent = Ye(i.handleEvent, {
          mechanism: {
            data: {
              function: "handleEvent",
              handler: ve(i),
              target: e
            },
            handled: !1,
            type: "instrument"
          }
        }));
      } catch {
      }
      return r.apply(this, [
        o,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Ye(i, {
          mechanism: {
            data: {
              function: "addEventListener",
              handler: ve(i),
              target: e
            },
            handled: !1,
            type: "instrument"
          }
        }),
        s
      ]);
    };
  }), W(
    n,
    "removeEventListener",
    function(r) {
      return function(o, i, s) {
        const a = i;
        try {
          const c = a && a.__sentry_wrapped__;
          c && r.call(this, o, c, s);
        } catch {
        }
        return r.call(this, o, a, s);
      };
    }
  ));
}
const Cc = "GlobalHandlers", Nc = (e = {}) => {
  const t = {
    onerror: !0,
    onunhandledrejection: !0,
    ...e
  };
  return {
    name: Cc,
    setupOnce() {
      Error.stackTraceLimit = 50;
    },
    setup(n) {
      t.onerror && (Tc(n), Er("onerror")), t.onunhandledrejection && (Dc(n), Er("onunhandledrejection"));
    }
  };
}, Ic = Nc;
function Tc(e) {
  si((t) => {
    const { stackParser: n, attachStacktrace: r } = mo();
    if (F() !== e || _o())
      return;
    const { msg: o, url: i, line: s, column: a, error: c } = t, l = Mc(
      Cn(n, c || o, void 0, r, !1),
      i,
      s,
      a
    );
    l.level = "error", oo(l, {
      originalException: c,
      mechanism: {
        handled: !1,
        type: "onerror"
      }
    });
  });
}
function Dc(e) {
  ci((t) => {
    const { stackParser: n, attachStacktrace: r } = mo();
    if (F() !== e || _o())
      return;
    const o = Rc(t), i = mn(o) ? Lc(o) : Cn(n, o, void 0, r, !0);
    i.level = "error", oo(i, {
      originalException: o,
      mechanism: {
        handled: !1,
        type: "onunhandledrejection"
      }
    });
  });
}
function Rc(e) {
  if (mn(e))
    return e;
  try {
    if ("reason" in e)
      return e.reason;
    if ("detail" in e && "reason" in e.detail)
      return e.detail.reason;
  } catch {
  }
  return e;
}
function Lc(e) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
          value: `Non-Error promise rejection captured with value: ${String(e)}`
        }
      ]
    }
  };
}
function Mc(e, t, n, r) {
  const o = e.exception = e.exception || {}, i = o.values = o.values || [], s = i[0] = i[0] || {}, a = s.stacktrace = s.stacktrace || {}, c = a.frames = a.frames || [], l = isNaN(parseInt(r, 10)) ? void 0 : r, d = isNaN(parseInt(n, 10)) ? void 0 : n, u = fe(t) && t.length > 0 ? t : Yr();
  return c.length === 0 && c.push({
    colno: l,
    filename: u,
    function: Ne,
    in_app: !0,
    lineno: d
  }), e;
}
function Er(e) {
  ct && g.log(`Global Handler attached: ${e}`);
}
function mo() {
  const e = F();
  return e && e.getOptions() || {
    stackParser: () => [],
    attachStacktrace: !1
  };
}
const Oc = () => ({
  name: "HttpContext",
  preprocessEvent(e) {
    if (!x.navigator && !x.location && !x.document)
      return;
    const t = e.request && e.request.url || x.location && x.location.href, { referrer: n } = x.document || {}, { userAgent: r } = x.navigator || {}, o = {
      ...e.request && e.request.headers,
      ...n && { Referer: n },
      ...r && { "User-Agent": r }
    }, i = { ...e.request, ...t && { url: t }, headers: o };
    e.request = i;
  }
}), $c = "cause", Fc = 5, Pc = "LinkedErrors", Ac = (e = {}) => {
  const t = e.limit || Fc, n = e.key || $c;
  return {
    name: Pc,
    preprocessEvent(r, o, i) {
      const s = i.getOptions();
      Fo(
        // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
        kn,
        s.stackParser,
        s.maxValueLength,
        n,
        t,
        r,
        o
      );
    }
  };
}, Uc = Ac;
function Hc(e) {
  return [
    ia(),
    ta(),
    vc(),
    dc(),
    Ic(),
    Uc(),
    ya(),
    Oc()
  ];
}
function jc(e = {}) {
  const t = {
    defaultIntegrations: Hc(),
    release: typeof __SENTRY_RELEASE__ == "string" ? __SENTRY_RELEASE__ : x.SENTRY_RELEASE && x.SENTRY_RELEASE.id ? x.SENTRY_RELEASE.id : void 0,
    autoSessionTracking: !0,
    sendClientReports: !0
  };
  return e.defaultIntegrations == null && delete e.defaultIntegrations, { ...t, ...e };
}
function Bc() {
  const e = typeof x.window < "u" && x;
  if (!e)
    return !1;
  const t = e.chrome ? "chrome" : "browser", n = e[t], r = n && n.runtime && n.runtime.id, o = x.location && x.location.href || "", i = ["chrome-extension:", "moz-extension:", "ms-browser-extension:", "safari-web-extension:"], s = !!r && x === x.top && i.some((c) => o.startsWith(`${c}//`)), a = typeof e.nw < "u";
  return !!r && !s && !a;
}
function cl(e = {}) {
  const t = jc(e);
  if (Bc()) {
    it(() => {
      console.error(
        "[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/"
      );
    });
    return;
  }
  ct && (Vr() || g.warn(
    "No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill."
  ));
  const n = {
    ...t,
    stackParser: Jo(t.stackParser || cc),
    integrations: Bs(t),
    transport: t.transport || Va
  }, r = Ws(Fa, n);
  return t.autoSessionTracking && Yc(), r;
}
function Yc() {
  if (typeof x.document > "u") {
    ct && g.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
    return;
  }
  ar({ ignoreDuration: !0 }), cr(), po(({ from: e, to: t }) => {
    e !== void 0 && e !== t && (ar({ ignoreDuration: !0 }), cr());
  });
}
const Gc = {
  replayIntegration: "replay",
  replayCanvasIntegration: "replay-canvas",
  feedbackIntegration: "feedback",
  feedbackModalIntegration: "feedback-modal",
  feedbackScreenshotIntegration: "feedback-screenshot",
  captureConsoleIntegration: "captureconsole",
  contextLinesIntegration: "contextlines",
  linkedErrorsIntegration: "linkederrors",
  debugIntegration: "debug",
  dedupeIntegration: "dedupe",
  extraErrorDataIntegration: "extraerrordata",
  httpClientIntegration: "httpclient",
  reportingObserverIntegration: "reportingobserver",
  rewriteFramesIntegration: "rewriteframes",
  sessionTimingIntegration: "sessiontiming",
  browserProfilingIntegration: "browserprofiling"
}, Sr = x;
async function qc(e, t) {
  const n = Gc[e], r = Sr.Sentry = Sr.Sentry || {};
  if (!n)
    throw new Error(`Cannot lazy load integration: ${e}`);
  const o = r[e];
  if (typeof o == "function" && !("_isShim" in o))
    return o;
  const i = Xc(n), s = x.document.createElement("script");
  s.src = i, s.crossOrigin = "anonymous", s.referrerPolicy = "origin", t && s.setAttribute("nonce", t);
  const a = new Promise((l, d) => {
    s.addEventListener("load", () => l()), s.addEventListener("error", d);
  });
  x.document.body.appendChild(s);
  try {
    await a;
  } catch {
    throw new Error(`Error when loading integration: ${e}`);
  }
  const c = r[e];
  if (typeof c != "function")
    throw new Error(`Could not load integration: ${e}`);
  return c;
}
function Xc(e) {
  const t = F(), n = t && t.getOptions(), r = n && n.cdnBaseUrl || "https://browser.sentry-cdn.com";
  return new URL(`/${Se}/${e}.min.js`, r).toString();
}
const ce = w, C = ce.document, et = ce.navigator, go = "Report a Bug", Wc = "Cancel", zc = "Send Bug Report", Vc = "Confirm", Kc = "Report a Bug", Jc = "your.email@example.org", Zc = "Email", Qc = "What's the bug? What did you expect?", eu = "Description", tu = "Your Name", nu = "Name", ru = "Thank you for your report!", ou = "(required)", iu = "Add a screenshot", su = "Remove screenshot", au = "widget", cu = "api", uu = 5e3, lu = (e, t = { includeReplay: !0 }) => {
  if (!e.message)
    throw new Error("Unable to submit feedback with empty message");
  const n = F();
  if (!n)
    throw new Error("No client setup, cannot send feedback.");
  e.tags && Object.keys(e.tags).length && te().setTags(e.tags);
  const r = va(
    {
      source: cu,
      url: Yr(),
      ...e
    },
    t
  );
  return new Promise((o, i) => {
    const s = setTimeout(() => i("Unable to determine if Feedback was correctly sent."), 5e3), a = n.on("afterSendEvent", (c, l) => {
      if (c.event_id === r)
        return clearTimeout(s), a(), l && typeof l.statusCode == "number" && l.statusCode >= 200 && l.statusCode < 300 && o(r), l && typeof l.statusCode == "number" && l.statusCode === 0 ? i(
          "Unable to send Feedback. This is because of network issues, or because you are using an ad-blocker."
        ) : l && typeof l.statusCode == "number" && l.statusCode === 403 ? i(
          "Unable to send Feedback. This could be because this domain is not in your list of allowed domains."
        ) : i(
          "Unable to send Feedback. This could be because of network issues, or because you are using an ad-blocker"
        );
    });
  });
}, vt = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function du() {
  return !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(et.userAgent) || /Macintosh/i.test(et.userAgent) && et.maxTouchPoints && et.maxTouchPoints > 1 || !isSecureContext);
}
function gt(e, t) {
  return {
    ...e,
    ...t,
    tags: {
      ...e.tags,
      ...t.tags
    },
    onFormOpen: () => {
      t.onFormOpen && t.onFormOpen(), e.onFormOpen && e.onFormOpen();
    },
    onFormClose: () => {
      t.onFormClose && t.onFormClose(), e.onFormClose && e.onFormClose();
    },
    onSubmitSuccess: (n) => {
      t.onSubmitSuccess && t.onSubmitSuccess(n), e.onSubmitSuccess && e.onSubmitSuccess(n);
    },
    onSubmitError: (n) => {
      t.onSubmitError && t.onSubmitError(n), e.onSubmitError && e.onSubmitError(n);
    },
    onFormSubmitted: () => {
      t.onFormSubmitted && t.onFormSubmitted(), e.onFormSubmitted && e.onFormSubmitted();
    },
    themeDark: {
      ...e.themeDark,
      ...t.themeDark
    },
    themeLight: {
      ...e.themeLight,
      ...t.themeLight
    }
  };
}
function fu(e) {
  const t = C.createElement("style");
  return t.textContent = `
.widget__actor {
  position: fixed;
  z-index: var(--z-index);
  margin: var(--page-margin);
  inset: var(--actor-inset);

  display: flex;
  align-items: center;
  gap: 8px;
  padding: 16px;

  font-family: inherit;
  font-size: var(--font-size);
  font-weight: 600;
  line-height: 1.14em;
  text-decoration: none;

  background: var(--actor-background, var(--background));
  border-radius: var(--actor-border-radius, 1.7em/50%);
  border: var(--actor-border, var(--border));
  box-shadow: var(--actor-box-shadow, var(--box-shadow));
  color: var(--actor-color, var(--foreground));
  fill: var(--actor-color, var(--foreground));
  cursor: pointer;
  opacity: 1;
  transition: transform 0.2s ease-in-out;
  transform: translate(0, 0) scale(1);
}
.widget__actor[aria-hidden="true"] {
  opacity: 0;
  pointer-events: none;
  visibility: hidden;
  transform: translate(0, 16px) scale(0.98);
}

.widget__actor:hover {
  background: var(--actor-hover-background, var(--background));
  filter: var(--interactive-filter);
}

.widget__actor svg {
  width: 1.14em;
  height: 1.14em;
}

@media (max-width: 600px) {
  .widget__actor span {
    display: none;
  }
}
`, e && t.setAttribute("nonce", e), t;
}
function X(e, t) {
  return Object.entries(t).forEach(([n, r]) => {
    e.setAttributeNS(null, n, r);
  }), e;
}
const Fe = 20, _u = "http://www.w3.org/2000/svg";
function pu() {
  const e = (a) => ce.document.createElementNS(_u, a), t = X(e("svg"), {
    width: `${Fe}`,
    height: `${Fe}`,
    viewBox: `0 0 ${Fe} ${Fe}`,
    fill: "var(--foreground)"
  }), n = X(e("g"), {
    clipPath: "url(#clip0_57_80)"
  }), r = X(e("path"), {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M15.6622 15H12.3997C12.2129 14.9959 12.031 14.9396 11.8747 14.8375L8.04965 12.2H7.49956V19.1C7.4875 19.3348 7.3888 19.5568 7.22256 19.723C7.05632 19.8892 6.83435 19.9879 6.59956 20H2.04956C1.80193 19.9968 1.56535 19.8969 1.39023 19.7218C1.21511 19.5467 1.1153 19.3101 1.11206 19.0625V12.2H0.949652C0.824431 12.2017 0.700142 12.1783 0.584123 12.1311C0.468104 12.084 0.362708 12.014 0.274155 11.9255C0.185602 11.8369 0.115689 11.7315 0.0685419 11.6155C0.0213952 11.4995 -0.00202913 11.3752 -0.00034808 11.25V3.75C-0.00900498 3.62067 0.0092504 3.49095 0.0532651 3.36904C0.0972798 3.24712 0.166097 3.13566 0.255372 3.04168C0.344646 2.94771 0.452437 2.87327 0.571937 2.82307C0.691437 2.77286 0.82005 2.74798 0.949652 2.75H8.04965L11.8747 0.1625C12.031 0.0603649 12.2129 0.00407221 12.3997 0H15.6622C15.9098 0.00323746 16.1464 0.103049 16.3215 0.278167C16.4966 0.453286 16.5964 0.689866 16.5997 0.9375V3.25269C17.3969 3.42959 18.1345 3.83026 18.7211 4.41679C19.5322 5.22788 19.9878 6.32796 19.9878 7.47502C19.9878 8.62209 19.5322 9.72217 18.7211 10.5333C18.1345 11.1198 17.3969 11.5205 16.5997 11.6974V14.0125C16.6047 14.1393 16.5842 14.2659 16.5395 14.3847C16.4948 14.5035 16.4268 14.6121 16.3394 14.7042C16.252 14.7962 16.147 14.8698 16.0307 14.9206C15.9144 14.9714 15.7891 14.9984 15.6622 15ZM1.89695 10.325H1.88715V4.625H8.33715C8.52423 4.62301 8.70666 4.56654 8.86215 4.4625L12.6872 1.875H14.7247V13.125H12.6872L8.86215 10.4875C8.70666 10.3835 8.52423 10.327 8.33715 10.325H2.20217C2.15205 10.3167 2.10102 10.3125 2.04956 10.3125C1.9981 10.3125 1.94708 10.3167 1.89695 10.325ZM2.98706 12.2V18.1625H5.66206V12.2H2.98706ZM16.5997 9.93612V5.01393C16.6536 5.02355 16.7072 5.03495 16.7605 5.04814C17.1202 5.13709 17.4556 5.30487 17.7425 5.53934C18.0293 5.77381 18.2605 6.06912 18.4192 6.40389C18.578 6.73866 18.6603 7.10452 18.6603 7.47502C18.6603 7.84552 18.578 8.21139 18.4192 8.54616C18.2605 8.88093 18.0293 9.17624 17.7425 9.41071C17.4556 9.64518 17.1202 9.81296 16.7605 9.90191C16.7072 9.91509 16.6536 9.9265 16.5997 9.93612Z"
  });
  t.appendChild(n).appendChild(r);
  const o = e("defs"), i = X(e("clipPath"), {
    id: "clip0_57_80"
  }), s = X(e("rect"), {
    width: `${Fe}`,
    height: `${Fe}`,
    fill: "white"
  });
  return i.appendChild(s), o.appendChild(i), t.appendChild(o).appendChild(i).appendChild(s), t;
}
function hu({ triggerLabel: e, triggerAriaLabel: t, shadow: n, styleNonce: r }) {
  const o = C.createElement("button");
  if (o.type = "button", o.className = "widget__actor", o.ariaHidden = "false", o.ariaLabel = t || e || go, o.appendChild(pu()), e) {
    const s = C.createElement("span");
    s.appendChild(C.createTextNode(e)), o.appendChild(s);
  }
  const i = fu(r);
  return {
    el: o,
    appendToDom() {
      n.appendChild(i), n.appendChild(o);
    },
    removeFromDom() {
      n.removeChild(o), n.removeChild(i);
    },
    show() {
      o.ariaHidden = "false";
    },
    hide() {
      o.ariaHidden = "true";
    }
  };
}
const yo = "rgba(88, 74, 192, 1)", mu = {
  foreground: "#2b2233",
  background: "#ffffff",
  accentForeground: "white",
  accentBackground: yo,
  successColor: "#268d75",
  errorColor: "#df3338",
  border: "1.5px solid rgba(41, 35, 47, 0.13)",
  boxShadow: "0px 4px 24px 0px rgba(43, 34, 51, 0.12)",
  outline: "1px auto var(--accent-background)",
  interactiveFilter: "brightness(95%)"
}, vr = {
  foreground: "#ebe6ef",
  background: "#29232f",
  accentForeground: "white",
  accentBackground: yo,
  successColor: "#2da98c",
  errorColor: "#f55459",
  border: "1.5px solid rgba(235, 230, 239, 0.15)",
  boxShadow: "0px 4px 24px 0px rgba(43, 34, 51, 0.12)",
  outline: "1px auto var(--accent-background)",
  interactiveFilter: "brightness(150%)"
};
function wr(e) {
  return `
  --foreground: ${e.foreground};
  --background: ${e.background};
  --accent-foreground: ${e.accentForeground};
  --accent-background: ${e.accentBackground};
  --success-color: ${e.successColor};
  --error-color: ${e.errorColor};
  --border: ${e.border};
  --box-shadow: ${e.boxShadow};
  --outline: ${e.outline};
  --interactive-filter: ${e.interactiveFilter};
  `;
}
function gu({
  colorScheme: e,
  themeDark: t,
  themeLight: n,
  styleNonce: r
}) {
  const o = C.createElement("style");
  return o.textContent = `
:host {
  --font-family: system-ui, 'Helvetica Neue', Arial, sans-serif;
  --font-size: 14px;
  --z-index: 100000;

  --page-margin: 16px;
  --inset: auto 0 0 auto;
  --actor-inset: var(--inset);

  font-family: var(--font-family);
  font-size: var(--font-size);

  ${e !== "system" ? "color-scheme: only light;" : ""}

  ${wr(
    e === "dark" ? { ...vr, ...t } : { ...mu, ...n }
  )}
}

${e === "system" ? `
@media (prefers-color-scheme: dark) {
  :host {
    ${wr({ ...vr, ...t })}
  }
}` : ""}
}
`, r && o.setAttribute("nonce", r), o;
}
const yu = ({
  lazyLoadIntegration: e,
  getModalIntegration: t,
  getScreenshotIntegration: n
}) => ({
  // FeedbackGeneralConfiguration
  id: o = "sentry-feedback",
  autoInject: i = !0,
  showBranding: s = !0,
  isEmailRequired: a = !1,
  isNameRequired: c = !1,
  showEmail: l = !0,
  showName: d = !0,
  enableScreenshot: u = !0,
  useSentryUser: _ = {
    email: "email",
    name: "username"
  },
  tags: f,
  styleNonce: p,
  scriptNonce: R,
  // FeedbackThemeConfiguration
  colorScheme: y = "system",
  themeLight: E = {},
  themeDark: k = {},
  // FeedbackTextConfiguration
  addScreenshotButtonLabel: P = iu,
  cancelButtonLabel: B = Wc,
  confirmButtonLabel: ne = Vc,
  emailLabel: V = Zc,
  emailPlaceholder: K = Jc,
  formTitle: ie = Kc,
  isRequiredLabel: h = ou,
  messageLabel: m = eu,
  messagePlaceholder: v = Qc,
  nameLabel: S = nu,
  namePlaceholder: U = tu,
  removeScreenshotButtonLabel: re = su,
  submitButtonLabel: O = zc,
  successMessageText: Y = ru,
  triggerLabel: Me = go,
  triggerAriaLabel: G = "",
  // FeedbackCallbacks
  onFormOpen: J,
  onFormClose: Oe,
  onSubmitSuccess: he,
  onSubmitError: ze,
  onFormSubmitted: To
} = {}) => {
  const Ve = {
    id: o,
    autoInject: i,
    showBranding: s,
    isEmailRequired: a,
    isNameRequired: c,
    showEmail: l,
    showName: d,
    enableScreenshot: u,
    useSentryUser: _,
    tags: f,
    styleNonce: p,
    scriptNonce: R,
    colorScheme: y,
    themeDark: k,
    themeLight: E,
    triggerLabel: Me,
    triggerAriaLabel: G,
    cancelButtonLabel: B,
    submitButtonLabel: O,
    confirmButtonLabel: ne,
    formTitle: ie,
    emailLabel: V,
    emailPlaceholder: K,
    messageLabel: m,
    messagePlaceholder: v,
    nameLabel: S,
    namePlaceholder: U,
    successMessageText: Y,
    isRequiredLabel: h,
    addScreenshotButtonLabel: P,
    removeScreenshotButtonLabel: re,
    onFormClose: Oe,
    onFormOpen: J,
    onSubmitError: ze,
    onSubmitSuccess: he,
    onFormSubmitted: To
  };
  let me = null, Ke = [];
  const Ln = (D) => {
    if (!me) {
      const $ = C.createElement("div");
      $.id = String(D.id), C.body.appendChild($), me = $.attachShadow({ mode: "open" }), me.appendChild(gu(D));
    }
    return me;
  }, Mn = async (D, $, se) => {
    const H = F(), A = H && H.getIntegrationByName(D);
    if (A)
      return A;
    const $e = ($ && $() || await e(se, R))();
    return H && H.addIntegration($e), $e;
  }, On = async (D) => {
    const $ = D.enableScreenshot && du(), [se, H] = await Promise.all([
      Mn("FeedbackModal", t, "feedbackModalIntegration"),
      $ ? Mn(
        "FeedbackScreenshot",
        n,
        "feedbackScreenshotIntegration"
      ) : void 0
    ]);
    if (!se)
      throw vt && g.error(
        "[Feedback] Missing feedback modal integration. Try using `feedbackSyncIntegration` in your `Sentry.init`."
      ), new Error("[Feedback] Missing feedback modal integration!");
    $ && !H && vt && g.error("[Feedback] Missing feedback screenshot integration. Proceeding without screenshots.");
    const A = se.createDialog({
      options: {
        ...D,
        onFormClose: () => {
          A && A.close(), D.onFormClose && D.onFormClose();
        },
        onFormSubmitted: () => {
          A && A.close(), D.onFormSubmitted && D.onFormSubmitted();
        }
      },
      screenshotIntegration: $ ? H : void 0,
      sendFeedback: lu,
      shadow: Ln(D)
    });
    return A;
  }, $n = (D, $ = {}) => {
    const se = gt(Ve, $), H = typeof D == "string" ? C.querySelector(D) : typeof D.addEventListener == "function" ? D : null;
    if (!H)
      throw vt && g.error("[Feedback] Unable to attach to target element"), new Error("Unable to attach to target element");
    let A = null;
    const Ut = async () => {
      A || (A = await On({
        ...se,
        onFormSubmitted: () => {
          A && A.removeFromDom(), se.onFormSubmitted && se.onFormSubmitted();
        }
      })), A.appendToDom(), A.open();
    };
    H.addEventListener("click", Ut);
    const $e = () => {
      Ke = Ke.filter((Do) => Do !== $e), A && A.removeFromDom(), A = null, H.removeEventListener("click", Ut);
    };
    return Ke.push($e), $e;
  }, At = (D = {}) => {
    const $ = gt(Ve, D), se = Ln($), H = hu({
      triggerLabel: $.triggerLabel,
      triggerAriaLabel: $.triggerAriaLabel,
      shadow: se,
      styleNonce: p
    });
    return $n(H.el, {
      ...$,
      onFormOpen() {
        H.hide();
      },
      onFormClose() {
        H.show();
      },
      onFormSubmitted() {
        H.show();
      }
    }), H;
  };
  return {
    name: "Feedback",
    setupOnce() {
      !_i() || !Ve.autoInject || (C.readyState === "loading" ? C.addEventListener("DOMContentLoaded", () => At().appendToDom()) : At().appendToDom());
    },
    /**
     * Adds click listener to the element to open a feedback dialog
     *
     * The returned function can be used to remove the click listener
     */
    attachTo: $n,
    /**
     * Creates a new widget which is composed of a Button which triggers a Dialog.
     * Accepts partial options to override any options passed to constructor.
     */
    createWidget(D = {}) {
      const $ = At(gt(Ve, D));
      return $.appendToDom(), $;
    },
    /**
     * Creates a new Form which you can
     * Accepts partial options to override any options passed to constructor.
     */
    async createForm(D = {}) {
      return On(gt(Ve, D));
    },
    /**
     * Removes the Feedback integration (including host, shadow DOM, and all widgets)
     */
    remove() {
      me && (me.parentElement && me.parentElement.remove(), me = null), Ke.forEach((D) => D()), Ke = [];
    }
  };
};
var Pt, T, bo, ke, kr, Eo, ln, rt = {}, Nn = [], bu = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, In = Array.isArray;
function Ee(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}
function So(e) {
  var t = e.parentNode;
  t && t.removeChild(e);
}
function b(e, t, n) {
  var r, o, i, s = {};
  for (i in t)
    i == "key" ? r = t[i] : i == "ref" ? o = t[i] : s[i] = t[i];
  if (arguments.length > 2 && (s.children = arguments.length > 3 ? Pt.call(arguments, 2) : n), typeof e == "function" && e.defaultProps != null)
    for (i in e.defaultProps)
      s[i] === void 0 && (s[i] = e.defaultProps[i]);
  return wt(e, s, r, o, null);
}
function wt(e, t, n, r, o) {
  var i = { type: e, props: t, key: n, ref: r, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: o ?? ++bo, __i: -1, __u: 0 };
  return o == null && T.vnode != null && T.vnode(i), i;
}
function ut(e) {
  return e.children;
}
function kt(e, t) {
  this.props = e, this.context = t;
}
function Ge(e, t) {
  if (t == null)
    return e.__ ? Ge(e.__, e.__i + 1) : null;
  for (var n; t < e.__k.length; t++)
    if ((n = e.__k[t]) != null && n.__e != null)
      return n.__e;
  return typeof e.type == "function" ? Ge(e) : null;
}
function Eu(e, t, n) {
  var r, o = e.__v, i = o.__e, s = e.__P;
  if (s)
    return (r = Ee({}, o)).__v = o.__v + 1, T.vnode && T.vnode(r), Tn(s, r, o, e.__n, s.ownerSVGElement !== void 0, 32 & o.__u ? [i] : null, t, i ?? Ge(o), !!(32 & o.__u), n), r.__.__k[r.__i] = r, r.__d = void 0, r.__e != i && vo(r), r;
}
function vo(e) {
  var t, n;
  if ((e = e.__) != null && e.__c != null) {
    for (e.__e = e.__c.base = null, t = 0; t < e.__k.length; t++)
      if ((n = e.__k[t]) != null && n.__e != null) {
        e.__e = e.__c.base = n.__e;
        break;
      }
    return vo(e);
  }
}
function xr(e) {
  (!e.__d && (e.__d = !0) && ke.push(e) && !Rt.__r++ || kr !== T.debounceRendering) && ((kr = T.debounceRendering) || Eo)(Rt);
}
function Rt() {
  var e, t, n, r = [], o = [];
  for (ke.sort(ln); e = ke.shift(); )
    e.__d && (n = ke.length, t = Eu(e, r, o) || t, n === 0 || ke.length > n ? (dn(r, t, o), o.length = r.length = 0, t = void 0, ke.sort(ln)) : t && T.__c && T.__c(t, Nn));
  t && dn(r, t, o), Rt.__r = 0;
}
function wo(e, t, n, r, o, i, s, a, c, l, d) {
  var u, _, f, p, R, y = r && r.__k || Nn, E = t.length;
  for (n.__d = c, Su(n, t, y), c = n.__d, u = 0; u < E; u++)
    (f = n.__k[u]) != null && typeof f != "boolean" && typeof f != "function" && (_ = f.__i === -1 ? rt : y[f.__i] || rt, f.__i = u, Tn(e, f, _, o, i, s, a, c, l, d), p = f.__e, f.ref && _.ref != f.ref && (_.ref && Dn(_.ref, null, f), d.push(f.ref, f.__c || p, f)), R == null && p != null && (R = p), 65536 & f.__u || _.__k === f.__k ? c = ko(f, c, e) : typeof f.type == "function" && f.__d !== void 0 ? c = f.__d : p && (c = p.nextSibling), f.__d = void 0, f.__u &= -196609);
  n.__d = c, n.__e = R;
}
function Su(e, t, n) {
  var r, o, i, s, a, c = t.length, l = n.length, d = l, u = 0;
  for (e.__k = [], r = 0; r < c; r++)
    (o = e.__k[r] = (o = t[r]) == null || typeof o == "boolean" || typeof o == "function" ? null : typeof o == "string" || typeof o == "number" || typeof o == "bigint" || o.constructor == String ? wt(null, o, null, null, o) : In(o) ? wt(ut, { children: o }, null, null, null) : o.constructor === void 0 && o.__b > 0 ? wt(o.type, o.props, o.key, o.ref ? o.ref : null, o.__v) : o) != null ? (o.__ = e, o.__b = e.__b + 1, a = vu(o, n, s = r + u, d), o.__i = a, i = null, a !== -1 && (d--, (i = n[a]) && (i.__u |= 131072)), i == null || i.__v === null ? (a == -1 && u--, typeof o.type != "function" && (o.__u |= 65536)) : a !== s && (a === s + 1 ? u++ : a > s ? d > c - s ? u += a - s : u-- : u = a < s && a == s - 1 ? a - s : 0, a !== r + u && (o.__u |= 65536))) : (i = n[r]) && i.key == null && i.__e && (i.__e == e.__d && (e.__d = Ge(i)), fn(i, i, !1), n[r] = null, d--);
  if (d)
    for (r = 0; r < l; r++)
      (i = n[r]) != null && !(131072 & i.__u) && (i.__e == e.__d && (e.__d = Ge(i)), fn(i, i));
}
function ko(e, t, n) {
  var r, o;
  if (typeof e.type == "function") {
    for (r = e.__k, o = 0; r && o < r.length; o++)
      r[o] && (r[o].__ = e, t = ko(r[o], t, n));
    return t;
  }
  e.__e != t && (n.insertBefore(e.__e, t || null), t = e.__e);
  do
    t = t && t.nextSibling;
  while (t != null && t.nodeType === 8);
  return t;
}
function vu(e, t, n, r) {
  var o = e.key, i = e.type, s = n - 1, a = n + 1, c = t[n];
  if (c === null || c && o == c.key && i === c.type)
    return n;
  if (r > (c != null && !(131072 & c.__u) ? 1 : 0))
    for (; s >= 0 || a < t.length; ) {
      if (s >= 0) {
        if ((c = t[s]) && !(131072 & c.__u) && o == c.key && i === c.type)
          return s;
        s--;
      }
      if (a < t.length) {
        if ((c = t[a]) && !(131072 & c.__u) && o == c.key && i === c.type)
          return a;
        a++;
      }
    }
  return -1;
}
function Cr(e, t, n) {
  t[0] === "-" ? e.setProperty(t, n ?? "") : e[t] = n == null ? "" : typeof n != "number" || bu.test(t) ? n : n + "px";
}
function yt(e, t, n, r, o) {
  var i;
  e:
    if (t === "style")
      if (typeof n == "string")
        e.style.cssText = n;
      else {
        if (typeof r == "string" && (e.style.cssText = r = ""), r)
          for (t in r)
            n && t in n || Cr(e.style, t, "");
        if (n)
          for (t in n)
            r && n[t] === r[t] || Cr(e.style, t, n[t]);
      }
    else if (t[0] === "o" && t[1] === "n")
      i = t !== (t = t.replace(/(PointerCapture)$|Capture$/i, "$1")), t = t.toLowerCase() in e ? t.toLowerCase().slice(2) : t.slice(2), e.l || (e.l = {}), e.l[t + i] = n, n ? r ? n.u = r.u : (n.u = Date.now(), e.addEventListener(t, i ? Ir : Nr, i)) : e.removeEventListener(t, i ? Ir : Nr, i);
    else {
      if (o)
        t = t.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (t !== "width" && t !== "height" && t !== "href" && t !== "list" && t !== "form" && t !== "tabIndex" && t !== "download" && t !== "rowSpan" && t !== "colSpan" && t !== "role" && t in e)
        try {
          e[t] = n ?? "";
          break e;
        } catch {
        }
      typeof n == "function" || (n == null || n === !1 && t[4] !== "-" ? e.removeAttribute(t) : e.setAttribute(t, n));
    }
}
function Nr(e) {
  if (this.l) {
    var t = this.l[e.type + !1];
    if (e.t) {
      if (e.t <= t.u)
        return;
    } else
      e.t = Date.now();
    return t(T.event ? T.event(e) : e);
  }
}
function Ir(e) {
  if (this.l)
    return this.l[e.type + !0](T.event ? T.event(e) : e);
}
function Tn(e, t, n, r, o, i, s, a, c, l) {
  var d, u, _, f, p, R, y, E, k, P, B, ne, V, K, ie, h = t.type;
  if (t.constructor !== void 0)
    return null;
  128 & n.__u && (c = !!(32 & n.__u), i = [a = t.__e = n.__e]), (d = T.__b) && d(t);
  e:
    if (typeof h == "function")
      try {
        if (E = t.props, k = (d = h.contextType) && r[d.__c], P = d ? k ? k.props.value : d.__ : r, n.__c ? y = (u = t.__c = n.__c).__ = u.__E : ("prototype" in h && h.prototype.render ? t.__c = u = new h(E, P) : (t.__c = u = new kt(E, P), u.constructor = h, u.render = ku), k && k.sub(u), u.props = E, u.state || (u.state = {}), u.context = P, u.__n = r, _ = u.__d = !0, u.__h = [], u._sb = []), u.__s == null && (u.__s = u.state), h.getDerivedStateFromProps != null && (u.__s == u.state && (u.__s = Ee({}, u.__s)), Ee(u.__s, h.getDerivedStateFromProps(E, u.__s))), f = u.props, p = u.state, u.__v = t, _)
          h.getDerivedStateFromProps == null && u.componentWillMount != null && u.componentWillMount(), u.componentDidMount != null && u.__h.push(u.componentDidMount);
        else {
          if (h.getDerivedStateFromProps == null && E !== f && u.componentWillReceiveProps != null && u.componentWillReceiveProps(E, P), !u.__e && (u.shouldComponentUpdate != null && u.shouldComponentUpdate(E, u.__s, P) === !1 || t.__v === n.__v)) {
            for (t.__v !== n.__v && (u.props = E, u.state = u.__s, u.__d = !1), t.__e = n.__e, t.__k = n.__k, t.__k.forEach(function(m) {
              m && (m.__ = t);
            }), B = 0; B < u._sb.length; B++)
              u.__h.push(u._sb[B]);
            u._sb = [], u.__h.length && s.push(u);
            break e;
          }
          u.componentWillUpdate != null && u.componentWillUpdate(E, u.__s, P), u.componentDidUpdate != null && u.__h.push(function() {
            u.componentDidUpdate(f, p, R);
          });
        }
        if (u.context = P, u.props = E, u.__P = e, u.__e = !1, ne = T.__r, V = 0, "prototype" in h && h.prototype.render) {
          for (u.state = u.__s, u.__d = !1, ne && ne(t), d = u.render(u.props, u.state, u.context), K = 0; K < u._sb.length; K++)
            u.__h.push(u._sb[K]);
          u._sb = [];
        } else
          do
            u.__d = !1, ne && ne(t), d = u.render(u.props, u.state, u.context), u.state = u.__s;
          while (u.__d && ++V < 25);
        u.state = u.__s, u.getChildContext != null && (r = Ee(Ee({}, r), u.getChildContext())), _ || u.getSnapshotBeforeUpdate == null || (R = u.getSnapshotBeforeUpdate(f, p)), wo(e, In(ie = d != null && d.type === ut && d.key == null ? d.props.children : d) ? ie : [ie], t, n, r, o, i, s, a, c, l), u.base = t.__e, t.__u &= -161, u.__h.length && s.push(u), y && (u.__E = u.__ = null);
      } catch (m) {
        t.__v = null, c || i != null ? (t.__e = a, t.__u |= c ? 160 : 32, i[i.indexOf(a)] = null) : (t.__e = n.__e, t.__k = n.__k), T.__e(m, t, n);
      }
    else
      i == null && t.__v === n.__v ? (t.__k = n.__k, t.__e = n.__e) : t.__e = wu(n.__e, t, n, r, o, i, s, c, l);
  (d = T.diffed) && d(t);
}
function dn(e, t, n) {
  for (var r = 0; r < n.length; r++)
    Dn(n[r], n[++r], n[++r]);
  T.__c && T.__c(t, e), e.some(function(o) {
    try {
      e = o.__h, o.__h = [], e.some(function(i) {
        i.call(o);
      });
    } catch (i) {
      T.__e(i, o.__v);
    }
  });
}
function wu(e, t, n, r, o, i, s, a, c) {
  var l, d, u, _, f, p, R, y = n.props, E = t.props, k = t.type;
  if (k === "svg" && (o = !0), i != null) {
    for (l = 0; l < i.length; l++)
      if ((f = i[l]) && "setAttribute" in f == !!k && (k ? f.localName === k : f.nodeType === 3)) {
        e = f, i[l] = null;
        break;
      }
  }
  if (e == null) {
    if (k === null)
      return document.createTextNode(E);
    e = o ? document.createElementNS("http://www.w3.org/2000/svg", k) : document.createElement(k, E.is && E), i = null, a = !1;
  }
  if (k === null)
    y === E || a && e.data === E || (e.data = E);
  else {
    if (i = i && Pt.call(e.childNodes), y = n.props || rt, !a && i != null)
      for (y = {}, l = 0; l < e.attributes.length; l++)
        y[(f = e.attributes[l]).name] = f.value;
    for (l in y)
      f = y[l], l == "children" || (l == "dangerouslySetInnerHTML" ? u = f : l === "key" || l in E || yt(e, l, null, f, o));
    for (l in E)
      f = E[l], l == "children" ? _ = f : l == "dangerouslySetInnerHTML" ? d = f : l == "value" ? p = f : l == "checked" ? R = f : l === "key" || a && typeof f != "function" || y[l] === f || yt(e, l, f, y[l], o);
    if (d)
      a || u && (d.__html === u.__html || d.__html === e.innerHTML) || (e.innerHTML = d.__html), t.__k = [];
    else if (u && (e.innerHTML = ""), wo(e, In(_) ? _ : [_], t, n, r, o && k !== "foreignObject", i, s, i ? i[0] : n.__k && Ge(n, 0), a, c), i != null)
      for (l = i.length; l--; )
        i[l] != null && So(i[l]);
    a || (l = "value", p !== void 0 && (p !== e[l] || k === "progress" && !p || k === "option" && p !== y[l]) && yt(e, l, p, y[l], !1), l = "checked", R !== void 0 && R !== e[l] && yt(e, l, R, y[l], !1));
  }
  return e;
}
function Dn(e, t, n) {
  try {
    typeof e == "function" ? e(t) : e.current = t;
  } catch (r) {
    T.__e(r, n);
  }
}
function fn(e, t, n) {
  var r, o;
  if (T.unmount && T.unmount(e), (r = e.ref) && (r.current && r.current !== e.__e || Dn(r, null, t)), (r = e.__c) != null) {
    if (r.componentWillUnmount)
      try {
        r.componentWillUnmount();
      } catch (i) {
        T.__e(i, t);
      }
    r.base = r.__P = null, e.__c = void 0;
  }
  if (r = e.__k)
    for (o = 0; o < r.length; o++)
      r[o] && fn(r[o], t, n || typeof e.type != "function");
  n || e.__e == null || So(e.__e), e.__ = e.__e = e.__d = void 0;
}
function ku(e, t, n) {
  return this.constructor(e, n);
}
function xu(e, t, n) {
  var r, o, i, s;
  T.__ && T.__(e, t), o = (r = typeof n == "function") ? null : n && n.__k || t.__k, i = [], s = [], Tn(t, e = (!r && n || t).__k = b(ut, null, [e]), o || rt, rt, t.ownerSVGElement !== void 0, !r && n ? [n] : o ? null : t.firstChild ? Pt.call(t.childNodes) : null, i, !r && n ? n : o ? o.__e : t.firstChild, r, s), e.__d = void 0, dn(i, e, s);
}
Pt = Nn.slice, T = { __e: function(e, t, n, r) {
  for (var o, i, s; t = t.__; )
    if ((o = t.__c) && !o.__)
      try {
        if ((i = o.constructor) && i.getDerivedStateFromError != null && (o.setState(i.getDerivedStateFromError(e)), s = o.__d), o.componentDidCatch != null && (o.componentDidCatch(e, r || {}), s = o.__d), s)
          return o.__E = o;
      } catch (a) {
        e = a;
      }
  throw e;
} }, bo = 0, kt.prototype.setState = function(e, t) {
  var n;
  n = this.__s != null && this.__s !== this.state ? this.__s : this.__s = Ee({}, this.state), typeof e == "function" && (e = e(Ee({}, n), this.props)), e && Ee(n, e), e != null && this.__v && (t && this._sb.push(t), xr(this));
}, kt.prototype.forceUpdate = function(e) {
  this.__v && (this.__e = !0, e && this.__h.push(e), xr(this));
}, kt.prototype.render = ut, ke = [], Eo = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, ln = function(e, t) {
  return e.__v.__b - t.__v.__b;
}, Rt.__r = 0;
var pe, I, Yt, Tr, qe = 0, xo = [], xt = [], M = T, Dr = M.__b, Rr = M.__r, Lr = M.diffed, Mr = M.__c, Or = M.unmount, $r = M.__;
function Le(e, t) {
  M.__h && M.__h(I, e, qe || t), qe = 0;
  var n = I.__H || (I.__H = { __: [], __h: [] });
  return e >= n.__.length && n.__.push({ __V: xt }), n.__[e];
}
function Ae(e) {
  return qe = 1, Co(Io, e);
}
function Co(e, t, n) {
  var r = Le(pe++, 2);
  if (r.t = e, !r.__c && (r.__ = [n ? n(t) : Io(void 0, t), function(a) {
    var c = r.__N ? r.__N[0] : r.__[0], l = r.t(c, a);
    c !== l && (r.__N = [l, r.__[1]], r.__c.setState({}));
  }], r.__c = I, !I.u)) {
    var o = function(a, c, l) {
      if (!r.__c.__H)
        return !0;
      var d = r.__c.__H.__.filter(function(_) {
        return !!_.__c;
      });
      if (d.every(function(_) {
        return !_.__N;
      }))
        return !i || i.call(this, a, c, l);
      var u = !1;
      return d.forEach(function(_) {
        if (_.__N) {
          var f = _.__[0];
          _.__ = _.__N, _.__N = void 0, f !== _.__[0] && (u = !0);
        }
      }), !(!u && r.__c.props === a) && (!i || i.call(this, a, c, l));
    };
    I.u = !0;
    var i = I.shouldComponentUpdate, s = I.componentWillUpdate;
    I.componentWillUpdate = function(a, c, l) {
      if (this.__e) {
        var d = i;
        i = void 0, o(a, c, l), i = d;
      }
      s && s.call(this, a, c, l);
    }, I.shouldComponentUpdate = o;
  }
  return r.__N || r.__;
}
function Cu(e, t) {
  var n = Le(pe++, 3);
  !M.__s && Rn(n.__H, t) && (n.__ = e, n.i = t, I.__H.__h.push(n));
}
function No(e, t) {
  var n = Le(pe++, 4);
  !M.__s && Rn(n.__H, t) && (n.__ = e, n.i = t, I.__h.push(n));
}
function Nu(e) {
  return qe = 5, lt(function() {
    return { current: e };
  }, []);
}
function Iu(e, t, n) {
  qe = 6, No(function() {
    return typeof e == "function" ? (e(t()), function() {
      return e(null);
    }) : e ? (e.current = t(), function() {
      return e.current = null;
    }) : void 0;
  }, n == null ? n : n.concat(e));
}
function lt(e, t) {
  var n = Le(pe++, 7);
  return Rn(n.__H, t) ? (n.__V = e(), n.i = t, n.__h = e, n.__V) : n.__;
}
function Ue(e, t) {
  return qe = 8, lt(function() {
    return e;
  }, t);
}
function Tu(e) {
  var t = I.context[e.__c], n = Le(pe++, 9);
  return n.c = e, t ? (n.__ == null && (n.__ = !0, t.sub(I)), t.props.value) : e.__;
}
function Du(e, t) {
  M.useDebugValue && M.useDebugValue(t ? t(e) : e);
}
function Ru(e) {
  var t = Le(pe++, 10), n = Ae();
  return t.__ = e, I.componentDidCatch || (I.componentDidCatch = function(r, o) {
    t.__ && t.__(r, o), n[1](r);
  }), [n[0], function() {
    n[1](void 0);
  }];
}
function Lu() {
  var e = Le(pe++, 11);
  if (!e.__) {
    for (var t = I.__v; t !== null && !t.__m && t.__ !== null; )
      t = t.__;
    var n = t.__m || (t.__m = [0, 0]);
    e.__ = "P" + n[0] + "-" + n[1]++;
  }
  return e.__;
}
function Mu() {
  for (var e; e = xo.shift(); )
    if (e.__P && e.__H)
      try {
        e.__H.__h.forEach(Ct), e.__H.__h.forEach(_n), e.__H.__h = [];
      } catch (t) {
        e.__H.__h = [], M.__e(t, e.__v);
      }
}
M.__b = function(e) {
  I = null, Dr && Dr(e);
}, M.__ = function(e, t) {
  t.__k && t.__k.__m && (e.__m = t.__k.__m), $r && $r(e, t);
}, M.__r = function(e) {
  Rr && Rr(e), pe = 0;
  var t = (I = e.__c).__H;
  t && (Yt === I ? (t.__h = [], I.__h = [], t.__.forEach(function(n) {
    n.__N && (n.__ = n.__N), n.__V = xt, n.__N = n.i = void 0;
  })) : (t.__h.forEach(Ct), t.__h.forEach(_n), t.__h = [], pe = 0)), Yt = I;
}, M.diffed = function(e) {
  Lr && Lr(e);
  var t = e.__c;
  t && t.__H && (t.__H.__h.length && (xo.push(t) !== 1 && Tr === M.requestAnimationFrame || ((Tr = M.requestAnimationFrame) || Ou)(Mu)), t.__H.__.forEach(function(n) {
    n.i && (n.__H = n.i), n.__V !== xt && (n.__ = n.__V), n.i = void 0, n.__V = xt;
  })), Yt = I = null;
}, M.__c = function(e, t) {
  t.some(function(n) {
    try {
      n.__h.forEach(Ct), n.__h = n.__h.filter(function(r) {
        return !r.__ || _n(r);
      });
    } catch (r) {
      t.some(function(o) {
        o.__h && (o.__h = []);
      }), t = [], M.__e(r, n.__v);
    }
  }), Mr && Mr(e, t);
}, M.unmount = function(e) {
  Or && Or(e);
  var t, n = e.__c;
  n && n.__H && (n.__H.__.forEach(function(r) {
    try {
      Ct(r);
    } catch (o) {
      t = o;
    }
  }), n.__H = void 0, t && M.__e(t, n.__v));
};
var Fr = typeof requestAnimationFrame == "function";
function Ou(e) {
  var t, n = function() {
    clearTimeout(r), Fr && cancelAnimationFrame(t), setTimeout(e);
  }, r = setTimeout(n, 100);
  Fr && (t = requestAnimationFrame(n));
}
function Ct(e) {
  var t = I, n = e.__c;
  typeof n == "function" && (e.__c = void 0, n()), I = t;
}
function _n(e) {
  var t = I;
  e.__c = e.__(), I = t;
}
function Rn(e, t) {
  return !e || e.length !== t.length || t.some(function(n, r) {
    return n !== e[r];
  });
}
function Io(e, t) {
  return typeof t == "function" ? t(e) : t;
}
const $u = {
  __proto__: null,
  useCallback: Ue,
  useContext: Tu,
  useDebugValue: Du,
  useEffect: Cu,
  useErrorBoundary: Ru,
  useId: Lu,
  useImperativeHandle: Iu,
  useLayoutEffect: No,
  useMemo: lt,
  useReducer: Co,
  useRef: Nu,
  useState: Ae
}, Fu = "http://www.w3.org/2000/svg";
function Pu() {
  const e = (r) => C.createElementNS(Fu, r), t = X(e("svg"), {
    width: "32",
    height: "30",
    viewBox: "0 0 72 66",
    fill: "inherit"
  }), n = X(e("path"), {
    transform: "translate(11, 11)",
    d: "M29,2.26a4.67,4.67,0,0,0-8,0L14.42,13.53A32.21,32.21,0,0,1,32.17,40.19H27.55A27.68,27.68,0,0,0,12.09,17.47L6,28a15.92,15.92,0,0,1,9.23,12.17H4.62A.76.76,0,0,1,4,39.06l2.94-5a10.74,10.74,0,0,0-3.36-1.9l-2.91,5a4.54,4.54,0,0,0,1.69,6.24A4.66,4.66,0,0,0,4.62,44H19.15a19.4,19.4,0,0,0-8-17.31l2.31-4A23.87,23.87,0,0,1,23.76,44H36.07a35.88,35.88,0,0,0-16.41-31.8l4.67-8a.77.77,0,0,1,1.05-.27c.53.29,20.29,34.77,20.66,35.17a.76.76,0,0,1-.68,1.13H40.6q.09,1.91,0,3.81h4.78A4.59,4.59,0,0,0,50,39.43a4.49,4.49,0,0,0-.62-2.28Z"
  });
  return t.appendChild(n), t;
}
const Pr = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/modal/components/DialogHeader.tsx";
function Au({ options: e }) {
  const t = lt(() => ({ __html: Pu().outerHTML }), []);
  return b(
    "h2",
    { class: "dialog__header", __self: this, __source: { fileName: Pr, lineNumber: 16 } },
    e.formTitle,
    e.showBranding ? b(
      "a",
      {
        class: "brand-link",
        target: "_blank",
        href: "https://sentry.io/welcome/",
        title: "Powered by Sentry",
        rel: "noopener noreferrer",
        dangerouslySetInnerHTML: t,
        __self: this,
        __source: { fileName: Pr, lineNumber: 19 }
      }
    ) : null
  );
}
function Uu(e, t) {
  const n = [];
  return t.isNameRequired && !e.name && n.push(t.nameLabel), t.isEmailRequired && !e.email && n.push(t.emailLabel), e.message || n.push(t.messageLabel), n;
}
const L = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/modal/components/Form.tsx";
function Gt(e, t) {
  const n = e.get(t);
  return typeof n == "string" ? n.trim() : "";
}
function Hu({
  options: e,
  defaultEmail: t,
  defaultName: n,
  onFormClose: r,
  onSubmit: o,
  onSubmitSuccess: i,
  onSubmitError: s,
  showEmail: a,
  showName: c,
  screenshotInput: l
}) {
  const {
    tags: d,
    addScreenshotButtonLabel: u,
    removeScreenshotButtonLabel: _,
    cancelButtonLabel: f,
    emailLabel: p,
    emailPlaceholder: R,
    isEmailRequired: y,
    isNameRequired: E,
    messageLabel: k,
    messagePlaceholder: P,
    nameLabel: B,
    namePlaceholder: ne,
    submitButtonLabel: V,
    isRequiredLabel: K
  } = e, [ie, h] = Ae(null), [m, v] = Ae(!1), S = l && l.input, [U, re] = Ae(null), O = Ue((G) => {
    re(G), v(!1);
  }, []), Y = Ue(
    (G) => {
      const J = Uu(G, {
        emailLabel: p,
        isEmailRequired: y,
        isNameRequired: E,
        messageLabel: k,
        nameLabel: B
      });
      return J.length > 0 ? h(`Please enter in the following required fields: ${J.join(", ")}`) : h(null), J.length === 0;
    },
    [p, y, E, k, B]
  ), Me = Ue(
    async (G) => {
      try {
        if (G.preventDefault(), !(G.target instanceof HTMLFormElement))
          return;
        const J = new FormData(G.target), Oe = await (l && m ? l.value() : void 0), he = {
          name: Gt(J, "name"),
          email: Gt(J, "email"),
          message: Gt(J, "message"),
          attachments: Oe ? [Oe] : void 0
        };
        if (!Y(he))
          return;
        try {
          await o(
            {
              name: he.name,
              email: he.email,
              message: he.message,
              source: au,
              tags: d
            },
            { attachments: he.attachments }
          ), i(he);
        } catch (ze) {
          vt && g.error(ze), h(ze), s(ze);
        }
      } catch {
      }
    },
    [l && m, i, s]
  );
  return b(
    "form",
    { class: "form", onSubmit: Me, __self: this, __source: { fileName: L, lineNumber: 144 } },
    S && m ? b(S, { onError: O, __self: this, __source: { fileName: L, lineNumber: 146 } }) : null,
    b(
      "div",
      { class: "form__right", "data-sentry-feedback": !0, __self: this, __source: { fileName: L, lineNumber: 149 } },
      b(
        "div",
        { class: "form__top", __self: this, __source: { fileName: L, lineNumber: 150 } },
        ie ? b("div", { class: "form__error-container", __self: this, __source: { fileName: L, lineNumber: 151 } }, ie) : null,
        c ? b(
          "label",
          { for: "name", class: "form__label", __self: this, __source: { fileName: L, lineNumber: 154 } },
          b(qt, { label: B, isRequiredLabel: K, isRequired: E, __self: this, __source: { fileName: L, lineNumber: 155 } }),
          b(
            "input",
            {
              class: "form__input",
              defaultValue: n,
              id: "name",
              name: "name",
              placeholder: ne,
              required: E,
              type: "text",
              __self: this,
              __source: { fileName: L, lineNumber: 156 }
            }
          )
        ) : b("input", { "aria-hidden": !0, value: n, name: "name", type: "hidden", __self: this, __source: { fileName: L, lineNumber: 167 } }),
        a ? b(
          "label",
          { for: "email", class: "form__label", __self: this, __source: { fileName: L, lineNumber: 171 } },
          b(qt, { label: p, isRequiredLabel: K, isRequired: y, __self: this, __source: { fileName: L, lineNumber: 172 } }),
          b(
            "input",
            {
              class: "form__input",
              defaultValue: t,
              id: "email",
              name: "email",
              placeholder: R,
              required: y,
              type: "email",
              __self: this,
              __source: { fileName: L, lineNumber: 173 }
            }
          )
        ) : b("input", { "aria-hidden": !0, value: t, name: "email", type: "hidden", __self: this, __source: { fileName: L, lineNumber: 184 } }),
        b(
          "label",
          { for: "message", class: "form__label", __self: this, __source: { fileName: L, lineNumber: 187 } },
          b(qt, { label: k, isRequiredLabel: K, isRequired: !0, __self: this, __source: { fileName: L, lineNumber: 188 } }),
          b(
            "textarea",
            {
              autoFocus: !0,
              class: "form__input form__input--textarea",
              id: "message",
              name: "message",
              placeholder: P,
              required: !0,
              rows: 5,
              __self: this,
              __source: { fileName: L, lineNumber: 189 }
            }
          )
        ),
        S ? b(
          "label",
          { for: "screenshot", class: "form__label", __self: this, __source: { fileName: L, lineNumber: 201 } },
          b(
            "button",
            {
              class: "btn btn--default",
              type: "button",
              onClick: () => {
                re(null), v((G) => !G);
              },
              __self: this,
              __source: { fileName: L, lineNumber: 202 }
            },
            m ? _ : u
          ),
          U ? b("div", { class: "form__error-container", __self: this, __source: { fileName: L, lineNumber: 212 } }, U.message) : null
        ) : null
      ),
      b(
        "div",
        { class: "btn-group", __self: this, __source: { fileName: L, lineNumber: 216 } },
        b(
          "button",
          { class: "btn btn--primary", type: "submit", __self: this, __source: { fileName: L, lineNumber: 217 } },
          V
        ),
        b(
          "button",
          { class: "btn btn--default", type: "button", onClick: r, __self: this, __source: { fileName: L, lineNumber: 220 } },
          f
        )
      )
    )
  );
}
function qt({
  label: e,
  isRequired: t,
  isRequiredLabel: n
}) {
  return b(
    "span",
    { class: "form__label__text", __self: this, __source: { fileName: L, lineNumber: 239 } },
    e,
    t && b("span", { class: "form__label__text--required", __self: this, __source: { fileName: L, lineNumber: 241 } }, n)
  );
}
const bt = 16, Ar = 17, ju = "http://www.w3.org/2000/svg";
function Bu() {
  const e = (c) => ce.document.createElementNS(ju, c), t = X(e("svg"), {
    width: `${bt}`,
    height: `${Ar}`,
    viewBox: `0 0 ${bt} ${Ar}`,
    fill: "inherit"
  }), n = X(e("g"), {
    clipPath: "url(#clip0_57_156)"
  }), r = X(e("path"), {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M3.55544 15.1518C4.87103 16.0308 6.41775 16.5 8 16.5C10.1217 16.5 12.1566 15.6571 13.6569 14.1569C15.1571 12.6566 16 10.6217 16 8.5C16 6.91775 15.5308 5.37103 14.6518 4.05544C13.7727 2.73985 12.5233 1.71447 11.0615 1.10897C9.59966 0.503466 7.99113 0.34504 6.43928 0.653721C4.88743 0.962403 3.46197 1.72433 2.34315 2.84315C1.22433 3.96197 0.462403 5.38743 0.153721 6.93928C-0.15496 8.49113 0.00346625 10.0997 0.608967 11.5615C1.21447 13.0233 2.23985 14.2727 3.55544 15.1518ZM4.40546 3.1204C5.46945 2.40946 6.72036 2.03 8 2.03C9.71595 2.03 11.3616 2.71166 12.575 3.92502C13.7883 5.13838 14.47 6.78405 14.47 8.5C14.47 9.77965 14.0905 11.0306 13.3796 12.0945C12.6687 13.1585 11.6582 13.9878 10.476 14.4775C9.29373 14.9672 7.99283 15.0953 6.73777 14.8457C5.48271 14.596 4.32987 13.9798 3.42502 13.075C2.52018 12.1701 1.90397 11.0173 1.65432 9.76224C1.40468 8.50718 1.5328 7.20628 2.0225 6.02404C2.5122 4.8418 3.34148 3.83133 4.40546 3.1204Z"
  }), o = X(e("path"), {
    d: "M6.68775 12.4297C6.78586 12.4745 6.89218 12.4984 7 12.5C7.11275 12.4955 7.22315 12.4664 7.32337 12.4145C7.4236 12.3627 7.51121 12.2894 7.58 12.2L12 5.63999C12.0848 5.47724 12.1071 5.28902 12.0625 5.11098C12.0178 4.93294 11.9095 4.77744 11.7579 4.67392C11.6064 4.57041 11.4221 4.52608 11.24 4.54931C11.0579 4.57254 10.8907 4.66173 10.77 4.79999L6.88 10.57L5.13 8.56999C5.06508 8.49566 4.98613 8.43488 4.89768 8.39111C4.80922 8.34735 4.713 8.32148 4.61453 8.31498C4.51605 8.30847 4.41727 8.32147 4.32382 8.35322C4.23038 8.38497 4.14413 8.43484 4.07 8.49999C3.92511 8.63217 3.83692 8.81523 3.82387 9.01092C3.81083 9.2066 3.87393 9.39976 4 9.54999L6.43 12.24C6.50187 12.3204 6.58964 12.385 6.68775 12.4297Z"
  });
  t.appendChild(n).append(o, r);
  const i = e("defs"), s = X(e("clipPath"), {
    id: "clip0_57_156"
  }), a = X(e("rect"), {
    width: `${bt}`,
    height: `${bt}`,
    fill: "white",
    transform: "translate(0 0.5)"
  });
  return s.appendChild(a), i.appendChild(s), t.appendChild(i).appendChild(s).appendChild(a), t;
}
const ue = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/modal/components/Dialog.tsx";
function Yu({ open: e, onFormSubmitted: t, ...n }) {
  const r = n.options, o = lt(() => ({ __html: Bu().outerHTML }), []), [i, s] = Ae(null), a = Ue(() => {
    i && (clearTimeout(i), s(null)), t();
  }, [i]), c = Ue(
    (l) => {
      n.onSubmitSuccess(l), s(
        setTimeout(() => {
          t(), s(null);
        }, uu)
      );
    },
    [t]
  );
  return b(
    ut,
    { __self: this, __source: { fileName: ue, lineNumber: 48 } },
    i ? b(
      "div",
      { class: "success__position", onClick: a, __self: this, __source: { fileName: ue, lineNumber: 50 } },
      b(
        "div",
        { class: "success__content", __self: this, __source: { fileName: ue, lineNumber: 51 } },
        r.successMessageText,
        b("span", { class: "success__icon", dangerouslySetInnerHTML: o, __self: this, __source: { fileName: ue, lineNumber: 53 } })
      )
    ) : b(
      "dialog",
      { class: "dialog", onClick: r.onFormClose, open: e, __self: this, __source: { fileName: ue, lineNumber: 57 } },
      b(
        "div",
        { class: "dialog__position", __self: this, __source: { fileName: ue, lineNumber: 58 } },
        b(
          "div",
          {
            class: "dialog__content",
            onClick: (l) => {
              l.stopPropagation();
            },
            __self: this,
            __source: { fileName: ue, lineNumber: 59 }
          },
          b(Au, { options: r, __self: this, __source: { fileName: ue, lineNumber: 66 } }),
          b(Hu, { ...n, onSubmitSuccess: c, __self: this, __source: { fileName: ue, lineNumber: 67 } })
        )
      )
    )
  );
}
const Gu = `
.dialog {
  position: fixed;
  z-index: var(--z-index);
  margin: 0;
  inset: 0;

  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  height: 100vh;
  width: 100vw;

  color: var(--dialog-color, var(--foreground));
  fill: var(--dialog-color, var(--foreground));
  line-height: 1.75em;

  background-color: rgba(0, 0, 0, 0.05);
  border: none;
  inset: 0;
  opacity: 1;
  transition: opacity 0.2s ease-in-out;
}

.dialog__position {
  position: fixed;
  z-index: var(--z-index);
  inset: var(--dialog-inset);
  padding: var(--page-margin);
  display: flex;
  max-height: calc(100vh - (2 * var(--page-margin)));
}
@media (max-width: 600px) {
  .dialog__position {
    inset: var(--page-margin);
    padding: 0;
  }
}

.dialog__position:has(.editor) {
  inset: var(--page-margin);
  padding: 0;
}

.dialog:not([open]) {
  opacity: 0;
  pointer-events: none;
  visibility: hidden;
}
.dialog:not([open]) .dialog__content {
  transform: translate(0, -16px) scale(0.98);
}

.dialog__content {
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding: var(--dialog-padding, 24px);
  max-width: 100%;
  width: 100%;
  max-height: 100%;
  overflow: auto;

  background: var(--dialog-background, var(--background));
  border-radius: var(--dialog-border-radius, 20px);
  border: var(--dialog-border, var(--border));
  box-shadow: var(--dialog-box-shadow, var(--box-shadow));
  transform: translate(0, 0) scale(1);
  transition: transform 0.2s ease-in-out;
}
`, qu = `
.dialog__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-weight: var(--dialog-header-weight, 600);
  margin: 0;
}

.brand-link {
  display: inline-flex;
}
.brand-link:focus-visible {
  outline: var(--outline);
}
`, Xu = `
.form {
  display: flex;
  overflow: auto;
  flex-direction: row;
  gap: 16px;
  flex: 1 0;
}

.form__right {
  flex: 0 0 var(--form-width, 272px);
  width: var(--form-width, 272px);
  display: flex;
  overflow: auto;
  flex-direction: column;
  justify-content: space-between;
  gap: 20px;
}

@media (max-width: 600px) {
  .form__right {
    width: auto;
  }
}

.form__top {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.form__error-container {
  color: var(--error-color);
  fill: var(--error-color);
}

.form__label {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin: 0px;
}

.form__label__text {
  display: flex;
  gap: 4px;
  align-items: center;
}

.form__label__text--required {
  font-size: 0.85em;
}

.form__input {
  font-family: inherit;
  line-height: inherit;
  background: transparent;
  box-sizing: border-box;
  border: var(--input-border, var(--border));
  border-radius: var(--input-border-radius, 6px);
  color: var(--input-color, inherit);
  fill: var(--input-color, inherit);
  font-size: var(--input-font-size, inherit);
  font-weight: var(--input-font-weight, 500);
  padding: 6px 12px;
}

.form__input::placeholder {
  opacity: 0.65;
  color: var(--input-placeholder-color, inherit);
  filter: var(--interactive-filter);
}

.form__input:focus-visible {
  outline: var(--input-focus-outline, var(--outline));
}

.form__input--textarea {
  font-family: inherit;
  resize: vertical;
}

.error {
  color: var(--error-color);
  fill: var(--error-color);
}
`, Wu = `
.btn-group {
  display: grid;
  gap: 8px;
}

.btn {
  line-height: inherit;
  border: var(--button-border, var(--border));
  border-radius: var(--button-border-radius, 6px);
  cursor: pointer;
  font-family: inherit;
  font-size: var(--button-font-size, inherit);
  font-weight: var(--button-font-weight, 600);
  padding: var(--button-padding, 6px 16px);
}
.btn[disabled] {
  opacity: 0.6;
  pointer-events: none;
}

.btn--primary {
  color: var(--button-primary-color, var(--accent-foreground));
  fill: var(--button-primary-color, var(--accent-foreground));
  background: var(--button-primary-background, var(--accent-background));
  border: var(--button-primary-border, var(--border));
  border-radius: var(--button-primary-border-radius, 6px);
  font-weight: var(--button-primary-font-weight, 500);
}
.btn--primary:hover {
  color: var(--button-primary-hover-color, var(--accent-foreground));
  fill: var(--button-primary-hover-color, var(--accent-foreground));
  background: var(--button-primary-hover-background, var(--accent-background));
  filter: var(--interactive-filter);
}
.btn--primary:focus-visible {
  background: var(--button-primary-hover-background, var(--accent-background));
  filter: var(--interactive-filter);
  outline: var(--button-primary-focus-outline, var(--outline));
}

.btn--default {
  color: var(--button-color, var(--foreground));
  fill: var(--button-color, var(--foreground));
  background: var(--button-background, var(--background));
  border: var(--button-border, var(--border));
  border-radius: var(--button-border-radius, 6px);
  font-weight: var(--button-font-weight, 500);
}
.btn--default:hover {
  color: var(--button-color, var(--foreground));
  fill: var(--button-color, var(--foreground));
  background: var(--button-hover-background, var(--background));
  filter: var(--interactive-filter);
}
.btn--default:focus-visible {
  background: var(--button-hover-background, var(--background));
  filter: var(--interactive-filter);
  outline: var(--button-focus-outline, var(--outline));
}
`, zu = `
.success__position {
  position: fixed;
  inset: var(--dialog-inset);
  padding: var(--page-margin);
  z-index: var(--z-index);
}
.success__content {
  background: var(--success-background, var(--background));
  border: var(--success-border, var(--border));
  border-radius: var(--success-border-radius, 1.7em/50%);
  box-shadow: var(--success-box-shadow, var(--box-shadow));
  font-weight: var(--success-font-weight, 600);
  color: var(--success-color);
  fill: var(--success-color);
  padding: 12px 24px;
  line-height: 1.75em;

  display: grid;
  align-items: center;
  grid-auto-flow: column;
  gap: 6px;
  cursor: default;
}

.success__icon {
  display: flex;
}
`;
function Vu(e) {
  const t = C.createElement("style");
  return t.textContent = `
:host {
  --dialog-inset: var(--inset);
}

${Gu}
${qu}
${Xu}
${Wu}
${zu}
`, e && t.setAttribute("nonce", e), t;
}
const Ku = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/modal/integration.tsx";
function Ju() {
  const e = te().getUser(), t = We().getUser(), n = to().getUser();
  return e && Object.keys(e).length ? e : t && Object.keys(t).length ? t : n;
}
const Zu = () => ({
  name: "FeedbackModal",
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  setupOnce() {
  },
  createDialog: ({ options: e, screenshotIntegration: t, sendFeedback: n, shadow: r }) => {
    const o = r, i = e.useSentryUser, s = Ju(), a = C.createElement("div"), c = Vu(e.styleNonce);
    let l = "";
    const d = {
      get el() {
        return a;
      },
      appendToDom() {
        !o.contains(c) && !o.contains(a) && (o.appendChild(c), o.appendChild(a));
      },
      removeFromDom() {
        o.removeChild(a), o.removeChild(c), C.body.style.overflow = l;
      },
      open() {
        _(!0), e.onFormOpen && e.onFormOpen(), l = C.body.style.overflow, C.body.style.overflow = "hidden";
      },
      close() {
        _(!1), C.body.style.overflow = l;
      }
    }, u = t && t.createInput({ h: b, hooks: $u, dialog: d, options: e }), _ = (f) => {
      xu(
        b(
          Yu,
          {
            options: e,
            screenshotInput: u,
            showName: e.showName || e.isNameRequired,
            showEmail: e.showEmail || e.isEmailRequired,
            defaultName: i && s && s[i.name] || "",
            defaultEmail: i && s && s[i.email] || "",
            onFormClose: () => {
              _(!1), e.onFormClose && e.onFormClose();
            },
            onSubmit: n,
            onSubmitSuccess: (p) => {
              _(!1), e.onSubmitSuccess && e.onSubmitSuccess(p);
            },
            onSubmitError: (p) => {
              e.onSubmitError && e.onSubmitError(p);
            },
            onFormSubmitted: () => {
              e.onFormSubmitted && e.onFormSubmitted();
            },
            open: f,
            __self: void 0,
            __source: { fileName: Ku, lineNumber: 67 }
          }
        ),
        a
      );
    };
    return d;
  }
}), Qu = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/screenshot/components/CropCorner.tsx";
function el({
  h: e
  // eslint-disable-line @typescript-eslint/no-unused-vars
}) {
  return function({
    top: n,
    left: r,
    corner: o,
    onGrabButton: i
  }) {
    return e(
      "button",
      {
        class: `editor__crop-corner editor__crop-corner--${o} `,
        style: {
          top: n,
          left: r
        },
        onMouseDown: (s) => {
          s.preventDefault(), i(s, o);
        },
        onClick: (s) => {
          s.preventDefault();
        },
        __self: this,
        __source: { fileName: Qu, lineNumber: 22 }
      }
    );
  };
}
function tl(e) {
  const t = C.createElement("style"), n = "#1A141F", r = "#302735";
  return t.textContent = `
.editor {
  padding: 10px;
  padding-top: 65px;
  padding-bottom: 65px;
  flex-grow: 1;

  background-color: ${n};
  background-image: repeating-linear-gradient(
      -145deg,
      transparent,
      transparent 8px,
      ${n} 8px,
      ${n} 11px
    ),
    repeating-linear-gradient(
      -45deg,
      transparent,
      transparent 15px,
      ${r} 15px,
      ${r} 16px
    );
}

.editor__canvas-container {
  width: 100%;
  height: 100%;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.editor__canvas-container canvas {
  object-fit: contain;
  position: relative;
}

.editor__crop-btn-group {
  padding: 8px;
  gap: 8px;
  border-radius: var(--menu-border-radius, 6px);
  background: var(--button-primary-background, var(--background));
  width: 175px;
  position: absolute;
}

.editor__crop-corner {
  width: 30px;
  height: 30px;
  position: absolute;
  background: none;
  border: 3px solid #ffffff;
}

.editor__crop-corner--top-left {
  cursor: nwse-resize;
  border-right: none;
  border-bottom: none;
}
.editor__crop-corner--top-right {
  cursor: nesw-resize;
  border-left: none;
  border-bottom: none;
}
.editor__crop-corner--bottom-left {
  cursor: nesw-resize;
  border-right: none;
  border-top: none;
}
.editor__crop-corner--bottom-right {
  cursor: nwse-resize;
  border-left: none;
  border-top: none;
}
`, e && t.setAttribute("nonce", e), t;
}
function nl({ hooks: e }) {
  return function({ onBeforeScreenshot: n, onScreenshot: r, onAfterScreenshot: o, onError: i }) {
    e.useEffect(() => {
      (async () => {
        n();
        const a = await et.mediaDevices.getDisplayMedia({
          video: {
            width: ce.innerWidth * ce.devicePixelRatio,
            height: ce.innerHeight * ce.devicePixelRatio
          },
          audio: !1,
          // @ts-expect-error experimental flags: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia#prefercurrenttab
          monitorTypeSurfaces: "exclude",
          preferCurrentTab: !0,
          selfBrowserSurface: "include",
          surfaceSwitching: "exclude"
        }), c = C.createElement("video");
        await new Promise((l, d) => {
          c.srcObject = a, c.onloadedmetadata = () => {
            r(c), a.getTracks().forEach((u) => u.stop()), l();
          }, c.play().catch(d);
        }), o();
      })().catch(i);
    }, []);
  };
}
const Z = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/screenshot/components/ScreenshotEditor.tsx", tt = 30, le = 3, ge = tt + le, q = ce.devicePixelRatio, Ze = (e) => ({
  x: Math.min(e.startX, e.endX),
  y: Math.min(e.startY, e.endY),
  width: Math.abs(e.startX - e.endX),
  height: Math.abs(e.startY - e.endY)
}), Xt = (e) => {
  const t = e.clientHeight, n = e.clientWidth, r = e.width / e.height;
  let o = t * r, i = t;
  o > n && (o = n, i = n / r);
  const s = (n - o) / 2, a = (t - i) / 2;
  return { startX: s, startY: a, endX: o + s, endY: i + a };
};
function rl({
  h: e,
  hooks: t,
  imageBuffer: n,
  dialog: r,
  options: o
}) {
  const i = nl({ hooks: t });
  return function({ onError: a }) {
    const c = t.useMemo(() => ({ __html: tl(o.styleNonce).innerText }), []), l = el({ h: e }), d = t.useRef(null), u = t.useRef(null), _ = t.useRef(null), [f, p] = t.useState({ startX: 0, startY: 0, endX: 0, endY: 0 }), [R, y] = t.useState(!1), [E, k] = t.useState(!1);
    t.useEffect(() => {
      ce.addEventListener("resize", P, !1);
    }, []);
    function P() {
      const h = _.current, m = Ze(Xt(n));
      if (h) {
        h.width = m.width * q, h.height = m.height * q, h.style.width = `${m.width}px`, h.style.height = `${m.height}px`;
        const S = h.getContext("2d");
        S && S.scale(q, q);
      }
      const v = u.current;
      v && (v.style.width = `${m.width}px`, v.style.height = `${m.height}px`), p({ startX: 0, startY: 0, endX: m.width, endY: m.height });
    }
    t.useEffect(() => {
      const h = _.current;
      if (!h)
        return;
      const m = h.getContext("2d");
      if (!m)
        return;
      const v = Ze(Xt(n)), S = Ze(f);
      m.clearRect(0, 0, v.width, v.height), m.fillStyle = "rgba(0, 0, 0, 0.5)", m.fillRect(0, 0, v.width, v.height), m.clearRect(S.x, S.y, S.width, S.height), m.strokeStyle = "#ffffff", m.lineWidth = 3, m.strokeRect(S.x + 1, S.y + 1, S.width - 2, S.height - 2), m.strokeStyle = "#000000", m.lineWidth = 1, m.strokeRect(S.x + 3, S.y + 3, S.width - 6, S.height - 6);
    }, [f]);
    function B(h, m) {
      y(!1), k(!0);
      const v = ne(m), S = () => {
        C.removeEventListener("mousemove", v), C.removeEventListener("mouseup", S), y(!0), k(!1);
      };
      C.addEventListener("mouseup", S), C.addEventListener("mousemove", v);
    }
    const ne = t.useCallback((h) => function(m) {
      if (!_.current)
        return;
      const v = _.current, S = v.getBoundingClientRect(), U = m.clientX - S.x, re = m.clientY - S.y;
      switch (h) {
        case "top-left":
          p((O) => ({
            ...O,
            startX: Math.min(Math.max(0, U), O.endX - ge),
            startY: Math.min(Math.max(0, re), O.endY - ge)
          }));
          break;
        case "top-right":
          p((O) => ({
            ...O,
            endX: Math.max(Math.min(U, v.width / q), O.startX + ge),
            startY: Math.min(Math.max(0, re), O.endY - ge)
          }));
          break;
        case "bottom-left":
          p((O) => ({
            ...O,
            startX: Math.min(Math.max(0, U), O.endX - ge),
            endY: Math.max(Math.min(re, v.height / q), O.startY + ge)
          }));
          break;
        case "bottom-right":
          p((O) => ({
            ...O,
            endX: Math.max(Math.min(U, v.width / q), O.startX + ge),
            endY: Math.max(Math.min(re, v.height / q), O.startY + ge)
          }));
          break;
      }
    }, []), V = t.useRef({ initialX: 0, initialY: 0 });
    function K(h) {
      if (E)
        return;
      V.current = { initialX: h.clientX, initialY: h.clientY };
      const m = (S) => {
        const U = _.current;
        if (!U)
          return;
        const re = S.clientX - V.current.initialX, O = S.clientY - V.current.initialY;
        p((Y) => {
          const Me = Math.max(
            0,
            Math.min(Y.startX + re, U.width / q - (Y.endX - Y.startX))
          ), G = Math.max(
            0,
            Math.min(Y.startY + O, U.height / q - (Y.endY - Y.startY))
          ), J = Me + (Y.endX - Y.startX), Oe = G + (Y.endY - Y.startY);
          return V.current.initialX = S.clientX, V.current.initialY = S.clientY, {
            startX: Me,
            startY: G,
            endX: J,
            endY: Oe
          };
        });
      }, v = () => {
        C.removeEventListener("mousemove", m), C.removeEventListener("mouseup", v);
      };
      C.addEventListener("mousemove", m), C.addEventListener("mouseup", v);
    }
    function ie() {
      const h = C.createElement("canvas"), m = Ze(Xt(n)), v = Ze(f);
      h.width = v.width * q, h.height = v.height * q;
      const S = h.getContext("2d");
      S && n && S.drawImage(
        n,
        v.x / m.width * n.width,
        v.y / m.height * n.height,
        v.width / m.width * n.width,
        v.height / m.height * n.height,
        0,
        0,
        h.width,
        h.height
      );
      const U = n.getContext("2d");
      U && (U.clearRect(0, 0, n.width, n.height), n.width = h.width, n.height = h.height, n.style.width = `${v.width}px`, n.style.height = `${v.height}px`, U.drawImage(h, 0, 0), P());
    }
    return i({
      onBeforeScreenshot: t.useCallback(() => {
        r.el.style.display = "none";
      }, []),
      onScreenshot: t.useCallback(
        (h) => {
          const m = n.getContext("2d");
          if (!m)
            throw new Error("Could not get canvas context");
          n.width = h.videoWidth, n.height = h.videoHeight, n.style.width = "100%", n.style.height = "100%", m.drawImage(h, 0, 0);
        },
        [n]
      ),
      onAfterScreenshot: t.useCallback(() => {
        r.el.style.display = "block";
        const h = d.current;
        h && h.appendChild(n), P();
      }, []),
      onError: t.useCallback((h) => {
        r.el.style.display = "block", a(h);
      }, [])
    }), e(
      "div",
      { class: "editor", __self: this, __source: { fileName: Z, lineNumber: 315 } },
      e("style", { nonce: o.styleNonce, dangerouslySetInnerHTML: c, __self: this, __source: { fileName: Z, lineNumber: 316 } }),
      e(
        "div",
        { class: "editor__canvas-container", ref: d, __self: this, __source: { fileName: Z, lineNumber: 317 } },
        e(
          "div",
          { class: "editor__crop-container", style: { position: "absolute", zIndex: 1 }, ref: u, __self: this, __source: { fileName: Z, lineNumber: 318 } },
          e(
            "canvas",
            {
              onMouseDown: K,
              style: { position: "absolute", cursor: R ? "move" : "auto" },
              ref: _,
              __self: this,
              __source: { fileName: Z, lineNumber: 319 }
            }
          ),
          e(
            l,
            {
              left: f.startX - le,
              top: f.startY - le,
              onGrabButton: B,
              corner: "top-left",
              __self: this,
              __source: { fileName: Z, lineNumber: 324 }
            }
          ),
          e(
            l,
            {
              left: f.endX - tt + le,
              top: f.startY - le,
              onGrabButton: B,
              corner: "top-right",
              __self: this,
              __source: { fileName: Z, lineNumber: 330 }
            }
          ),
          e(
            l,
            {
              left: f.startX - le,
              top: f.endY - tt + le,
              onGrabButton: B,
              corner: "bottom-left",
              __self: this,
              __source: { fileName: Z, lineNumber: 336 }
            }
          ),
          e(
            l,
            {
              left: f.endX - tt + le,
              top: f.endY - tt + le,
              onGrabButton: B,
              corner: "bottom-right",
              __self: this,
              __source: { fileName: Z, lineNumber: 342 }
            }
          ),
          e(
            "div",
            {
              style: {
                left: Math.max(0, f.endX - 191),
                top: Math.max(0, f.endY + 8),
                display: R ? "flex" : "none"
              },
              class: "editor__crop-btn-group",
              __self: this,
              __source: { fileName: Z, lineNumber: 348 }
            },
            e(
              "button",
              {
                onClick: (h) => {
                  h.preventDefault(), _.current && p({
                    startX: 0,
                    startY: 0,
                    endX: _.current.width / q,
                    endY: _.current.height / q
                  }), y(!1);
                },
                class: "btn btn--default",
                __self: this,
                __source: { fileName: Z, lineNumber: 356 }
              },
              o.cancelButtonLabel
            ),
            e(
              "button",
              {
                onClick: (h) => {
                  h.preventDefault(), ie(), y(!1);
                },
                class: "btn btn--primary",
                __self: this,
                __source: { fileName: Z, lineNumber: 373 }
              },
              o.confirmButtonLabel
            )
          )
        )
      )
    );
  };
}
const ol = () => ({
  name: "FeedbackScreenshot",
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  setupOnce() {
  },
  createInput: ({ h: e, hooks: t, dialog: n, options: r }) => {
    const o = C.createElement("canvas");
    return {
      input: rl({
        h: e,
        hooks: t,
        imageBuffer: o,
        dialog: n,
        options: r
      }),
      // eslint-disable-line @typescript-eslint/no-explicit-any
      value: async () => {
        const i = await new Promise((s) => {
          o.toBlob(s, "image/png");
        });
        if (i)
          return {
            data: new Uint8Array(await i.arrayBuffer()),
            filename: "screenshot.png",
            contentType: "application/png"
            // attachmentType?: string;
          };
      }
    };
  }
}), ul = yu({
  lazyLoadIntegration: qc,
  getModalIntegration: () => Zu,
  getScreenshotIntegration: () => ol
});
export {
  cl as a,
  va as b,
  sl as c,
  ul as f,
  al as i
};
