import { r as g, c as u, d as r, h as d, H as y, g as f, a as C } from "./index-cd93b584.js";
import { N as A, e as R } from "./index.es-ef72cd61-3075f564.js";
import { C as S, N as p } from "./scheduler-store-8e74959b-ffa0b3c6.js";
import { C as m } from "./scheduler-config-store-ed4a8dfd-622802c7.js";
import "react";
import "react-dom";
class w {
  constructor(t, e) {
    this.nylasAuth = t, this.nylasAuthStore = e;
  }
  async validateSession() {
    const t = await this.isAccessTokenValid();
    if (!t)
      this.logout();
    else {
      let e = await this.nylasAuth.getTokenInfo();
      if (e) {
        const o = Math.floor(Date.now() / 1e3);
        if (e.expires_in && e.expires_in - o < 3e5 && (r("[NylasAuthConnectorMixin] Refreshing access token"), e = await this.nylasAuth.refreshAccessToken(), !e)) {
          r("[NylasAuthConnectorMixin] Token is expired and could not be refreshed. Logging out."), this.logout();
          return;
        }
        this.nylasAuthStore.state.tokenInfo = e;
      }
    }
    this.nylasAuthStore.state.isAuthenticated = t;
  }
  async isAuthenticated() {
    return this.nylasAuth.isAuthenticated();
  }
  async getTokenInfo() {
    return this.nylasAuth.getTokenInfo();
  }
  async isAccessTokenValid() {
    return this.nylasAuth.isAccessTokenValid();
  }
  async logout() {
    await this.nylasAuth.logout();
  }
  async getHostedAuthRedirectURL(t, e, n) {
    return this.nylasAuth.getHostedAuthRedirectURL(t, e, n);
  }
  async manageHostedAuthCodeExchange(t) {
    const n = new URL(t).searchParams.get("code");
    if (n) {
      const o = await this.nylasAuth.exchangeAuthCodeForTokenInfo(n);
      if (o)
        return this.nylasAuthStore.state.tokenInfo = o, this.nylasAuthStore.state.isAuthenticated = !0, o;
    }
    return null;
  }
}
class P {
  constructor(t, e, n, o, a, i = "https://api.us.nylas.com") {
    this.router = t, this.schedulerAPIURL = i, this.nylasAuth = e, this.nylasAuthStore = n, this.nylasSchedulerStore = o, this.nylasSchedulerConfigStore = a;
  }
  init() {
    r("NylasConnector init");
  }
  get authStore() {
    return this.nylasAuthStore;
  }
  get schedulerStore() {
    return this.nylasSchedulerStore;
  }
  get schedulerConfigStore() {
    return this.nylasSchedulerConfigStore;
  }
  get auth() {
    return this._authConnector ? this._authConnector : (this._authConnector = new w(this.nylasAuth, this.nylasAuthStore), this._authConnector);
  }
  get scheduler() {
    return this._schedulerAPIConnector ? this._schedulerAPIConnector : (this._schedulerAPIConnector = new p({
      schedulerAPIURL: this.schedulerAPIURL,
      schedulerStore: this.schedulerStore
    }), this._schedulerAPIConnector);
  }
  getAuth() {
    return this.nylasAuth;
  }
  resetStores() {
    this.nylasAuthStore.reset();
  }
  async logout() {
    await this.nylasAuth.logout(), this.resetStores();
  }
}
class v extends Event {
  constructor(t, e) {
    super(t, e), this.oldURL = e.oldURL, this.newURL = e.newURL;
  }
}
class L {
  constructor() {
    this.routeChangeListeners = [], r("HashRouter constructor");
  }
  destroy() {
    r("HashRouter destroy"), window.removeEventListener("hashchange", this.onRouteChange.bind(this));
  }
  init() {
    if (r("HashRouter init"), window.addEventListener("hashchange", this.onRouteChange.bind(this)), typeof HashChangeEvent < "u") {
      const t = new HashChangeEvent("hashchange", { oldURL: "", newURL: window.location.href });
      this.onRouteChange(t);
    } else {
      const t = new v("hashchange", { oldURL: "", newURL: window.location.href });
      this.onRouteChange(t);
    }
  }
  addRouteChangeListener(t, e) {
    r("HashRouter addRouteChangeListener"), this.routeChangeListeners.push([t, e]);
  }
  navigate(t, e) {
    if (r("HashRouter navigate"), e)
      return window.history.pushState(null, "", `#${t}`);
    window.location.hash = t;
  }
  setRoute(t) {
    r("HashRouter setRoute"), window.location.hash = t;
  }
  matchRoute(t, e) {
    const n = t.split("/"), o = e.split("/");
    if (r(`HashRouter matchRoute route=${t} path=${e}`, { routeParts: n, pathParts: o }), n[1] === "" && o[0] === "")
      return !0;
    if (n.length !== o.length)
      return !1;
    for (let a = 0; a < n.length; a++) {
      const i = n[a], h = o[a];
      if (!i.startsWith(":") && i !== h)
        return !1;
    }
    return !0;
  }
  getRouteParams(t) {
    r("HashRouter getRouteParams");
    const e = {}, n = t.split("/"), o = window.location.hash.split("/");
    return n.forEach((a, i) => {
      if (a.startsWith(":")) {
        const h = a.substring(1);
        e[h] = o[i];
      }
    }), e;
  }
  getRouteWithParams(t, e) {
    r("HashRouter getRouteWithParams");
    let n = t;
    return Object.keys(e).forEach((o) => {
      n = n.replace(`:${o}`, e[o]);
    }), n;
  }
  getRoute() {
    return r("HashRouter getRoute"), window.location.hash;
  }
  onRouteChange(t) {
    this.routeChangeListeners.forEach(async ([e, n]) => {
      const o = t.newURL.indexOf("#") === -1 ? "" : t.newURL.substring(t.newURL.indexOf("#") + 1);
      if (r(`HashRouter onRouteChange route=${e} path=${o}`, { event: t }), !this.matchRoute(e, o)) {
        r(`HashRouter onRouteChange route=${e} path=${o} does not match`);
        return;
      }
      const a = this.getRouteParams(e);
      await n(e, o, a);
    });
  }
  getBasePath() {
    return r("HashRouter getBasePath"), "";
  }
}
function b(s = {}) {
  const t = {
    isAuthenticated: !1,
    tokenInfo: null,
    state: "ready",
    ...s
  }, e = C(t);
  return e.reset = () => {
    for (const n in t) {
      const o = t[n];
      e.set(n, o);
    }
  }, e;
}
const H = ":host{display:contents}", I = H, k = class {
  constructor(s) {
    g(this, s), this.init = u(this, "init", 7), this.loggedIn = u(this, "loggedIn", 7), this.loggedOut = u(this, "loggedOut", 7), this.handleAuthChange = async (t) => {
      t ? this.loggedIn.emit(this.host) : this.loggedOut.emit(this.host);
    }, this.authConfig = void 0, this.eventOverrides = {}, this.automaticComponentRegistration = !0;
  }
  connectedCallback() {
    r("[nylas-provider] connectedCallback");
  }
  async componentWillLoad() {
    var a, i, h, c, l;
    r("[nylas-provider] componentWillLoad"), this.stores = {
      auth: b(),
      scheduler: S(),
      schedulerConfig: m()
    }, this.baseProvider = new A(this.host, this.stores, this.automaticComponentRegistration, this.eventOverrides);
    const s = new L();
    this.nylasAuth = R({
      apiUri: "https://api.us.nylas.com",
      elementsApiUri: "https://elements.us.nylas.com",
      storageType: "indexeddb",
      clientId: "YOUR_CLIENT_ID",
      defaultScopes: [],
      redirectURI: "/",
      ...this.authConfig
    });
    const t = (a = this.baseProvider) == null ? void 0 : a.getStore("auth");
    if (!t)
      throw new Error("The auth store is not set");
    const e = (i = this.baseProvider) == null ? void 0 : i.getStore("scheduler");
    if (!e)
      throw new Error("The scheduler store is not set");
    const n = (h = this.baseProvider) == null ? void 0 : h.getStore("schedulerConfig");
    if (!n)
      throw new Error("The scheduler config store is not set");
    this.nylasConnector = new P(s, this.nylasAuth, t, e, n), this.init.emit(this.host).defaultPrevented || await ((c = this.nylasConnector) == null ? void 0 : c.auth.validateSession()), this.handleAuthChange(t.state.isAuthenticated), (l = this.baseProvider) == null || l.componentWillLoad(this.nylasConnector);
  }
  componentDidLoad() {
    var t, e;
    const s = (t = this.baseProvider) == null ? void 0 : t.getStore("auth");
    s == null || s.onChange("isAuthenticated", this.handleAuthChange), (e = this.baseProvider) == null || e.componentDidLoad();
  }
  componentDisconnected() {
    var s;
    (s = this.baseProvider) == null || s.componentDisconnected();
  }
  async registerComponentHandler(s) {
    var t;
    (t = this.baseProvider) == null || t.registerComponent(s.detail);
  }
  async unregisterComponentHandler(s) {
    var t;
    (t = this.baseProvider) == null || t.unregisterComponent(s.detail);
  }
  async getNylasAuth() {
    return this.nylasAuth;
  }
  async getNylasConnector() {
    return this.nylasConnector;
  }
  async getAuthStore() {
    var s;
    return (s = this.baseProvider) == null ? void 0 : s.getStore("auth");
  }
  async getNylasSchedulerStore() {
    var s;
    return (s = this.baseProvider) == null ? void 0 : s.getStore("scheduler");
  }
  async getNylasSchedulerConfigStore() {
    var s;
    return (s = this.baseProvider) == null ? void 0 : s.getStore("schedulerConfig");
  }
  render() {
    return d(y, { key: "24d8f54d35e72ef3906567058947859b05e4ef4d" }, d("slot", { key: "421dbd31175cfb81fbce8e88f484521f0a9458ec" }));
  }
  get host() {
    return f(this);
  }
};
k.style = I;
export {
  k as nylas_provider
};
